<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NetHack Roguelike</title>
  <style>
    body {
      margin: 0;
      padding: 10px;
      background: #000;
      color: #0f0;
      font-family: 'Courier New', monospace;
      display: flex;
      justify-content: center;
    }
    #game-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 100%;
    }
    canvas {
      border: 2px solid #0f0;
      background: #000;
      image-rendering: pixelated;
    }
    #stats, #inventory, #log {
      padding: 10px;
      border: 2px solid #0f0;
      background: #001100;
      font-size: 12px;
    }
    #log {
      max-height: 150px;
      overflow-y: auto;
    }
    .log-entry { margin: 2px 0; }
    .damage { color: #f00; }
    .pickup { color: #ff0; }
    .death { color: #f0f; }
    #inventory {
      max-height: 150px;
      overflow-y: auto;
    }
    #inventory-list {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 5px;
    }
    .inventory-btn {
      background: #001100;
      border: 2px solid #0f0;
      color: #0f0;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      padding: 6px;
      cursor: pointer;
      transition: all 0.1s;
    }
    .inventory-btn:hover {
      background: #002200;
      border-color: #0ff;
    }
    #controls {
      display: grid;
      grid-template-columns: repeat(3, 50px);
      grid-template-rows: repeat(3, 50px);
      gap: 5px;
      margin: 0 auto;
      width: fit-content;
    }
    .control-btn {
      background: #001100;
      border: 2px solid #0f0;
      color: #0f0;
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.1s;
    }
    .control-btn:hover {
      background: #002200;
      border-color: #0ff;
    }
    .control-btn:active {
      background: #003300;
    }
    #toggle-action {
      background: #002200;
      border: 2px solid #0f0;
      color: #0f0;
      padding: 10px 20px;
      font-size: 14px;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      margin: 10px auto;
      width: fit-content;
      border-radius: 4px;
      transition: all 0.2s;
    }
    #toggle-action:hover, #toggle-action:active {
      background: #003300;
      border-color: #0ff;
      color: #0ff;
    }
    #restart-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #restart-modal.show {
      display: flex;
    }
    .modal-content {
      background: #001100;
      border: 3px solid #f00;
      padding: 20px;
      text-align: center;
      max-width: 90%;
      width: 300px;
    }
    .modal-content h2 {
      color: #f00;
      margin: 0 0 15px 0;
      font-size: 24px;
    }
    .modal-stats {
      margin: 15px 0;
      color: #0f0;
      font-size: 14px;
      line-height: 1.6;
    }
    #restart-btn {
      background: #002200;
      border: 2px solid #0f0;
      color: #0f0;
      padding: 10px 20px;
      font-size: 14px;
      font-family: 'Courier New', monospace;
      cursor: pointer;
    }
    #restart-btn:hover {
      background: #003300;
    }
    @media (max-width: 768px) {
      body { padding: 5px; }
      #game-container { flex-direction: column; align-items: center; }
      canvas { width: 100%; max-width: 100%; height: auto; }
      #stats, #inventory, #log { width: 100%; max-width: 100%; font-size: 10px; }
      #controls { grid-template-columns: repeat(3, 40px); grid-template-rows: repeat(3, 40px); gap: 3px; }
      .control-btn { font-size: 16px; }
      .inventory-btn { font-size: 10px; padding: 4px; }
      #toggle-action { font-size: 12px; padding: 8px 16px; }
      #log { max-height: 100px; }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="nethack" width="640" height="480"></canvas>
    <div id="stats">
      <div>HP: <span id="hp">20/20</span> | Lvl: <span id="level">1</span> | XP: <span id="xp">0</span> | Depth: <span id="depth">1</span></div>
      <div>Weapon: <span id="weapon">Fists</span> | Gold: <span id="gold">0</span> | <span id="status">Normal</span></div>
    </div>
    <div id="inventory">
      <div>Inventory (1-5 use | 'd' + 1-5 drop):</div>
      <div id="inventory-list"></div>
    </div>
    <div id="controls">
      <button class="control-btn" data-dir="nw">↖</button>
      <button class="control-btn" data-dir="n">↑</button>
      <button class="control-btn" data-dir="ne">↗</button>
      <button class="control-btn" data-dir="w">←</button>
      <button class="control-btn" data-dir="wait">•</button>
      <button class="control-btn" data-dir="e">→</button>
      <button class="control-btn" data-dir="sw">↙</button>
      <button class="control-btn" data-dir="s">↓</button>
      <button class="control-btn" data-dir="se">↘</button>
    </div>
    <button id="toggle-action">Drop Mode (Off)</button>
    <div id="log">
      <div class="log-entry">Welcome! Arrow keys move, Space waits. Find stairs (>) to descend!</div>
    </div>
  </div>
  <div id="restart-modal">
    <div class="modal-content">
      <h2>You Died</h2>
      <div class="modal-stats">
        <div>Final Level: <span id="final-level">1</span></div>
        <div>Gold: <span id="final-gold">0</span></div>
        <div>Kills: <span id="final-kills">0</span></div>
        <div>Turns: <span id="final-turns">0</span></div>
      </div>
      <button id="restart-btn">Play Again</button>
    </div>
  </div>
  <script>
    const canvas = document.getElementById("nethack");
    const ctx = canvas.getContext("2d");
    let TILE_SIZE = 16;
    const WIDTH = 40;
    const HEIGHT = 30;
    let player = {
      x: 0, y: 0, glyph: '@', color: '#fff',
      hp: 20, maxHp: 20, level: 1, xp: 0,
      weapon: null, gold: 0, inventory: [],
      inventorySize: 5, inventoryMaxItems: 20,
      poisonTurns: 0, hitChance: 70
    };
    let dungeon = { tiles: [], width: WIDTH, height: HEIGHT, rooms: [] };
    let monsters = [];
    let items = [];
    let traps = [];
    let turn = 0;
    let kills = 0;
    let dungeonLevel = 1;
    let itemAction = 'use';
    let visible = Array(HEIGHT).fill().map(() => Array(WIDTH).fill(false));
    let explored = Array(HEIGHT).fill().map(() => Array(WIDTH).fill(false));
    const MONSTER_TYPES = [
      { glyph: 'g', name: 'goblin', color: '#0a0', hp: 4, damage: 1, xp: 5, defense: 5, hitChance: 75 },
      { glyph: 'o', name: 'orc', color: '#f80', hp: 6, damage: 2, xp: 10, defense: 10, hitChance: 80 },
      { glyph: 'T', name: 'troll', color: '#0f0', hp: 12, damage: 4, xp: 20, defense: 15, hitChance: 85 },
      { glyph: 'D', name: 'dragon', color: '#f00', hp: 25, damage: 6, xp: 50, defense: 20, hitChance: 90 }
    ];
    const ITEM_TYPES = [
      { glyph: ')', name: 'dagger', color: '#ccc', damage: 3 },
      { glyph: ')', name: 'sword', color: '#aaf', damage: 5 },
      { glyph: ')', name: 'axe', color: '#faa', damage: 7 },
      { glyph: '$', name: 'gold', color: '#ff0', value: 0 },
      { glyph: '!', name: 'potion', color: '#0ff', heal: 5 },
      { glyph: '>', name: 'stairs', color: '#fff', isStairs: true }
    ];
    const TRAP_TYPES = [
      { glyph: '^', name: 'spike trap', color: '#f00', damage: 5, hidden: true },
      { glyph: '^', name: 'teleporter', color: '#0ff', teleport: true, hidden: true },
      { glyph: '^', name: 'poison trap', color: '#0f0', poison: 3, hidden: true }
    ];
    function generateDungeon(w, h) {
      console.log("Generating dungeon, attempt started...");
      for (let attempt = 0; attempt < 10; attempt++) {
        let tiles = Array(h).fill().map(() => Array(w).fill('#'));
        let rooms = [];
        for (let i = 0; i < 12; i++) {
          let rw = Math.floor(Math.random() * 6) + 4;
          let rh = Math.floor(Math.random() * 4) + 3;
          let rx = Math.floor(Math.random() * (w - rw - 2)) + 1;
          let ry = Math.floor(Math.random() * (h - rh - 2)) + 1;
          let overlap = rooms.some(r => 
            rx < r.x + r.w + 1 && rx + rw + 1 > r.x &&
            ry < r.y + r.h + 1 && ry + rh + 1 > r.y
          );
          if (!overlap) {
            for (let y = ry; y < ry + rh; y++) {
              for (let x = rx; x < rx + rw; x++) {
                tiles[y][x] = '.';
              }
            }
            rooms.push({ x: rx, y: ry, w: rw, h: rh, cx: Math.floor(rx + rw/2), cy: Math.floor(ry + rh/2) });
          }
        }
        if (rooms.length < 3) {
          console.warn(`Attempt ${attempt + 1}: Too few rooms (${rooms.length}), retrying...`);
          continue;
        }
        let connected = new Set([0]);
        while (connected.size < rooms.length) {
          let minDist = Infinity;
          let bestPair = null;
          for (let i of connected) {
            for (let j = 0; j < rooms.length; j++) {
              if (!connected.has(j)) {
                let dist = Math.hypot(rooms[i].cx - rooms[j].cx, rooms[i].cy - rooms[j].cy);
                if (dist < minDist) {
                  minDist = dist;
                  bestPair = [i, j];
                }
              }
            }
          }
          if (bestPair) {
            let [i, j] = bestPair;
            let x1 = rooms[i].cx, y1 = rooms[i].cy;
            let x2 = rooms[j].cx, y2 = rooms[j].cy;
            while (x1 !== x2) {
              tiles[y1][x1] = '.';
              x1 += x1 < x2 ? 1 : -1;
            }
            while (y1 !== y2) {
              tiles[y1][x1] = '.';
              y1 += y1 < y2 ? 1 : -1;
            }
            connected.add(j);
          } else break;
        }
        if (connected.size === rooms.length) {
          console.log(`Dungeon generated successfully with ${rooms.length} rooms`);
          return { tiles, width: w, height: h, rooms };
        }
        console.warn(`Attempt ${attempt + 1}: Failed to connect all rooms (${connected.size}/${rooms.length})`);
      }
      console.warn("Failed to generate fully connected dungeon, using fallback.");
      return { tiles: Array(h).fill().map(() => Array(w).fill('.')), width: w, height: h, rooms: [] };
    }
    function computeFOV(x, y, radius) {
      visible = Array(HEIGHT).fill().map(() => Array(WIDTH).fill(false));
      visible[y][x] = true;
      explored[y][x] = true;
      for (let octant = 0; octant < 8; octant++) {
        castLight(x, y, 1, 1.0, 0.0, radius, octant);
      }
    }
    function castLight(cx, cy, row, start, end, radius, octant) {
      if (start < end) return;
      for (let j = row; j <= radius; j++) {
        let blocked = false;
        let newStart = 0;
        for (let dx = -j; dx <= 0; dx++) {
          let dy = -j;
          let [X, Y] = transform(cx, cy, dx, dy, octant);
          if (X < 0 || X >= WIDTH || Y < 0 || Y >= HEIGHT) continue;
          let lSlope = (dx - 0.5) / (dy + 0.5);
          let rSlope = (dx + 0.5) / (dy - 0.5);
          if (start < rSlope || end > lSlope) continue;
          if (dx * dx + dy * dy <= radius * radius) {
            visible[Y][X] = true;
            explored[Y][X] = true;
          }
          if (blocked) {
            if (dungeon.tiles[Y][X] === '#') {
              newStart = rSlope;
              continue;
            }
            blocked = false;
            start = newStart;
          } else if (dungeon.tiles[Y][X] === '#' && j < radius) {
            blocked = true;
            castLight(cx, cy, j + 1, start, lSlope, radius, octant);
            newStart = rSlope;
          }
        }
        if (blocked) break;
      }
    }
    function transform(cx, cy, dx, dy, octant) {
      switch (octant) {
        case 0: return [cx + dx, cy - dy];
        case 1: return [cx + dy, cy - dx];
        case 2: return [cx - dy, cy - dx];
        case 3: return [cx - dx, cy - dy];
        case 4: return [cx - dx, cy + dy];
        case 5: return [cx - dy, cy + dx];
        case 6: return [cx + dy, cy + dx];
        case 7: return [cx + dx, cy + dy];
      }
    }
    function findWalkable() {
      for (let i = 0; i < 100; i++) {
        let x = Math.floor(Math.random() * (WIDTH - 2)) + 1;
        let y = Math.floor(Math.random() * (HEIGHT - 2)) + 1;
        if (dungeon.tiles[y][x] === '.' && 
            !(x === player.x && y === player.y) &&
            !monsters.some(m => m.x === x && m.y === x) &&
            !items.some(i => i.x === x && i.y === y)) {
          return { x, y };
        }
      }
      return { x: Math.min(WIDTH - 2, player.x + 1), y: player.y };
    }
    function spawnMonsters(count) {
      monsters = [];
      let maxType = Math.min(MONSTER_TYPES.length - 1, Math.floor(dungeonLevel / 2));
      for (let i = 0; i < count; i++) {
        let type = MONSTER_TYPES[Math.floor(Math.random() * (maxType + 1))];
        let pos = findWalkable();
        monsters.push({
          ...pos,
          glyph: type.glyph,
          color: type.color,
          name: type.name,
          hp: type.hp,
          maxHp: type.hp,
          damage: Math.min(type.damage + Math.floor(dungeonLevel / 3), type.damage * 2),
          xp: Math.min(type.xp * dungeonLevel, type.xp * 10),
          defense: Math.min(type.defense + Math.floor(dungeonLevel / 2), type.defense * 2),
          hitChance: type.hitChance
        });
      }
    }
    function spawnItems(count) {
      items = [];
      let pos = findWalkable();
      items.push({ ...pos, glyph: '>', color: '#fff', name: 'stairs', isStairs: true });
      const spawnableItems = ITEM_TYPES.filter(item => !item.isStairs);
      for (let i = 0; i < count; i++) {
        let type = spawnableItems[Math.floor(Math.random() * spawnableItems.length)];
        pos = findWalkable();
        let item = { ...pos, glyph: type.glyph, color: type.color, name: type.name };
        if (type.damage) item.damage = type.damage;
        if (type.value !== undefined) item.value = Math.floor(Math.random() * 50) + 10;
        if (type.heal) item.heal = type.heal;
        items.push(item);
      }
    }
    function spawnTraps(count) {
      traps = [];
      for (let i = 0; i < count; i++) {
        let type = TRAP_TYPES[Math.floor(Math.random() * TRAP_TYPES.length)];
        let pos = findWalkable();
        traps.push({ ...pos, ...type });
      }
    }
    function initGame(restart = false) {
      console.log("Initializing game...");
      if (restart) {
        player = {
          x: 0, y: 0, glyph: '@', color: '#fff',
          hp: 20, maxHp: 20, level: 1, xp: 0,
          weapon: null, gold: 0, inventory: [],
          inventorySize: 5, inventoryMaxItems: 20,
          poisonTurns: 0, hitChance: 70
        };
        dungeonLevel = 1;
        kills = 0;
        document.getElementById('log').innerHTML = '<div class="log-entry">Welcome! Arrow keys move, Space waits. Find stairs (>) to descend!</div>';
      }
      dungeon = generateDungeon(WIDTH, HEIGHT);
      if (dungeon.rooms.length > 0) {
        player.x = dungeon.rooms[0].cx;
        player.y = dungeon.rooms[0].cy;
        console.log(`Player placed at room center: (${player.x}, ${player.y})`);
      } else {
        let pos = findWalkable();
        player.x = pos.x;
        player.y = pos.y;
        console.warn(`No rooms, player placed at: (${player.x}, ${player.y})`);
      }
      player.hp = player.maxHp;
      player.poisonTurns = 0;
      visible = Array(HEIGHT).fill().map(() => Array(WIDTH).fill(false));
      explored = Array(HEIGHT).fill().map(() => Array(WIDTH).fill(false));
      spawnMonsters(Math.min(30, 10 + dungeonLevel * 2));
      spawnItems(8);
      spawnTraps(5);
      turn = 0;
      document.getElementById('restart-modal').classList.remove('show');
      computeFOV(player.x, player.y, 8);
      updateStats();
      gameLoop();
    }
    function gameLoop() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      let tilesDrawn = 0;
      for (let y = 0; y < HEIGHT; y++) {
        for (let x = 0; x < WIDTH; x++) {
          if (!explored[y][x]) continue;
          ctx.fillStyle = visible[y][x] ? '#0f0' : '#050';
          ctx.fillText(dungeon.tiles[y][x], x * TILE_SIZE, (y + 1) * TILE_SIZE);
          tilesDrawn++;
        }
      }
      console.log(`gameLoop: ${tilesDrawn} tiles drawn`);
      for (let trap of traps) {
        if (visible[trap.y][trap.x] && !trap.hidden) {
          ctx.fillStyle = trap.color;
          ctx.fillText(trap.glyph, trap.x * TILE_SIZE, (trap.y + 1) * TILE_SIZE);
        }
      }
      for (let item of items) {
        if (visible[item.y][item.x]) {
          ctx.fillStyle = item.color;
          ctx.fillText(item.glyph, item.x * TILE_SIZE, (item.y + 1) * TILE_SIZE);
        }
      }
      for (let monster of monsters) {
        if (visible[monster.y][monster.x]) {
          ctx.fillStyle = monster.color;
          ctx.fillText(monster.glyph, monster.x * TILE_SIZE, (monster.y + 1) * TILE_SIZE);
        }
      }
      ctx.fillStyle = player.color;
      ctx.fillText(player.glyph, player.x * TILE_SIZE, (player.y + 1) * TILE_SIZE);
    }
    function log(msg, cls = '') {
      const div = document.getElementById('log');
      const entry = document.createElement('div');
      entry.className = `log-entry ${cls}`;
      entry.textContent = msg;
      div.appendChild(entry);
      div.scrollTop = div.scrollHeight;
    }
    function useItem(i) {
      if (!player.inventory[i]) return;
      const item = player.inventory[i];
      if (item.damage) {
        if (player.weapon && player.weapon.name === item.name) {
          log(`Already equipped!`, 'damage');
          return;
        }
        player.weapon = { name: item.name, damage: item.damage };
        log(`Equipped ${item.name}!`, 'pickup');
        item.count--;
      } else if (item.heal) {
        let healed = Math.min(item.heal, player.maxHp - player.hp);
        player.hp += healed;
        if (player.poisonTurns > 0) {
          player.poisonTurns = 0;
          log(`Healed ${healed} HP and cured poison!`, 'pickup');
        } else if (healed > 0) {
          log(`Healed ${healed} HP!`, 'pickup');
        } else {
          log(`Already at full HP!`, 'damage');
          return;
        }
        item.count--;
      }
      if (item.count <= 0) {
        player.inventory.splice(i, 1);
      }
      updateStats();
      turn++;
      handleTurnEnd();
    }
    function dropItem(i) {
      if (!player.inventory[i]) return;
      const item = player.inventory[i];
      items.push({
        x: player.x,
        y: player.y,
        glyph: item.glyph,
        color: item.color,
        name: item.name,
        damage: item.damage,
        heal: item.heal
      });
      log(`Dropped ${item.name}`, 'pickup');
      item.count--;
      if (item.count <= 0) {
        if (player.weapon && player.weapon.name === item.name) {
          player.weapon = null;
        }
        player.inventory.splice(i, 1);
      }
      itemAction = 'use';
      document.getElementById('toggle-action').textContent = 'Drop Mode (Off)';
      updateStats();
      turn++;
      handleTurnEnd();
    }
    function updateStats() {
      document.getElementById('hp').textContent = `${player.hp}/${player.maxHp}`;
      document.getElementById('level').textContent = player.level;
      document.getElementById('xp').textContent = player.xp;
      document.getElementById('weapon').textContent = player.weapon ? player.weapon.name : 'Fists';
      document.getElementById('gold').textContent = player.gold;
      document.getElementById('depth').textContent = dungeonLevel;
      document.getElementById('status').textContent = player.poisonTurns > 0 ? `Poisoned (${player.poisonTurns})` : 'Normal';
      document.getElementById('status').style.color = player.poisonTurns > 0 ? '#f00' : '#0f0';
      const inv = document.getElementById('inventory-list');
      inv.innerHTML = '';
      if (player.inventory.length === 0) {
        inv.innerHTML = '<div>Empty</div>';
      } else {
        player.inventory.forEach((item, i) => {
          const btn = document.createElement('button');
          btn.className = 'inventory-btn';
          btn.textContent = `${i+1}. ${item.name} x${item.count}`;
          btn.onclick = () => itemAction === 'use' ? useItem(i) : dropItem(i);
          inv.appendChild(btn);
        });
      }
    }
    function attack(attacker, defender) {
      if (Math.random() * 100 > (attacker === player ? player.hitChance : attacker.hitChance)) {
        log(attacker === player ? 'Miss!' : `${attacker.name} misses!`, 'damage');
        return false;
      }
      let dmg = attacker === player ? (player.weapon ? player.weapon.damage : 2) : attacker.damage;
      dmg = Math.max(1, dmg + Math.floor(Math.random() * 3) - 1 - Math.floor((defender.defense || 0) / 10));
      defender.hp -= dmg;
      log(attacker === player ? `Hit ${defender.name} for ${dmg}!` : `${attacker.name} hits for ${dmg}!`, 'damage');
      if (defender.hp <= 0) {
        if (defender === player) {
          log('You died!', 'death');
          setTimeout(showDeathScreen, 500);
        } else {
          kills++;
          player.xp += defender.xp;
          monsters = monsters.filter(m => m !== defender);
          log(`Killed ${defender.name}!`, 'death');
          checkLevelUp();
        }
        return true;
      }
      return false;
    }
    function checkLevelUp() {
      while (player.xp >= player.level * 20) {
        player.level++;
        player.maxHp += 5;
        player.hp = player.maxHp;
        player.hitChance = Math.min(95, player.hitChance + 5);
        log(`Level ${player.level}!`, 'pickup');
      }
      updateStats();
    }
    function moveEntity(entity, dx, dy) {
      let newX = entity.x + dx;
      let newY = entity.y + dy;
      if (newX < 0 || newX >= WIDTH || newY < 0 || newY >= HEIGHT) return false;
      if (dungeon.tiles[newY][newX] === '#') return false;
      if (entity === player) {
        let m = monsters.find(m => m.x === newX && m.y === newY);
        if (m) {
          attack(player, m);
          return true;
        }
        let item = items.find(i => i.x === newX && i.y === newY);
        if (item) {
          if (item.isStairs) {
            dungeonLevel++;
            log(`Descend to level ${dungeonLevel}!`, 'pickup');
            initGame();
            return true;
          }
          if (item.value) {
            player.gold += item.value;
            log(`+${item.value} gold!`, 'pickup');
            items = items.filter(i => i !== item);
          } else if (item.damage || item.heal) {
            let total = player.inventory.reduce((s, i) => s + i.count, 0);
            if (total >= player.inventoryMaxItems) {
              log('Inventory full!', 'damage');
              return false;
            }
            let ex = player.inventory.find(i => i.name === item.name);
            if (ex) {
              ex.count++;
            } else if (player.inventory.length < player.inventorySize) {
              player.inventory.push({ ...item, count: 1 });
            } else {
              log('Too many item types!', 'damage');
              return false;
            }
            log(`Picked up ${item.name}!`, 'pickup');
            items = items.filter(i => i !== item);
          }
          updateStats();
        }
        let trap = traps.find(t => t.x === newX && t.y === newY);
        if (trap) {
          trap.hidden = false;
          if (trap.damage) {
            player.hp -= trap.damage;
            log(`Trap! -${trap.damage} HP!`, 'damage');
            if (player.hp <= 0) {
              log('You died!', 'death');
              setTimeout(showDeathScreen, 500);
            }
          } else if (trap.teleport) {
            let pos = findWalkable();
            player.x = pos.x;
            player.y = pos.y;
            log('Teleported!', 'pickup');
            traps = traps.filter(t => t !== trap);
            computeFOV(player.x, player.y, 8);
            updateStats();
            return true;
          } else if (trap.poison) {
            player.poisonTurns = trap.poison;
            player.hp -= 1;
            log(`Poisoned for ${trap.poison} turns!`, 'damage');
            if (player.hp <= 0) {
              log('You died!', 'death');
              setTimeout(showDeathScreen, 500);
            }
          }
          traps = traps.filter(t => t !== trap);
          updateStats();
        }
      }
      entity.x = newX;
      entity.y = newY;
      return true;
    }
    function getPath(startX, startY, targetX, targetY) {
      let openSet = [{ x: startX, y: startY, f: 0, g: 0, h: 0 }];
      let closedSet = new Set();
      let cameFrom = new Map();
      const calculateH = (x, y) => Math.abs(x - targetX) + Math.abs(y - targetY);
      while (openSet.length > 0) {
        openSet.sort((a, b) => a.f - b.f);
        let current = openSet.shift();
        if (current.x === targetX && current.y === targetY) {
          let path = [];
          let curr = { x: current.x, y: current.y };
          while (cameFrom.has(`${curr.x},${curr.y}`)) {
            path.unshift({ x: curr.x, y: curr.y });
            curr = cameFrom.get(`${curr.x},${curr.y}`);
          }
          if (path.length > 0 && path[0].x === startX && path[0].y === startY) {
            path.shift();
          }
          return path;
        }
        closedSet.add(`${current.x},${current.y}`);
        for (let [dx, dy] of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {
          let newX = current.x + dx;
          let newY = current.y + dy;
          if (newX < 0 || newX >= WIDTH || newY < 0 || newY >= HEIGHT) continue;
          if (dungeon.tiles[newY][newX] === '#') continue;
          if ((newX !== targetX || newY !== targetY) && monsters.some(m => m.x === newX && m.y === newY)) continue;
          if (items.some(i => i.x === newX && i.y === newY)) continue;
          if (traps.some(t => t.x === newX && t.y === newY && !t.teleport)) continue;
          if (closedSet.has(`${newX},${newY}`)) continue;
          let g = current.g + 1;
          let h = calculateH(newX, newY);
          let f = g + h;
          let existing = openSet.find(node => node.x === newX && node.y === newY);
          if (!existing) {
            openSet.push({ x: newX, y: newY, f, g, h });
            cameFrom.set(`${newX},${newY}`, { x: current.x, y: current.y });
          } else if (g < existing.g) {
            existing.f = f;
            existing.g = g;
            cameFrom.set(`${newX},${newY}`, { x: current.x, y: current.y });
          }
        }
      }
      return [];
    }
    function moveMonsters() {
      monsters.sort((a, b) => Math.hypot(a.x - player.x, a.y - player.y) - Math.hypot(b.x - player.x, b.y - player.y));
      for (let m of monsters) {
        if (player.hp <= 0) return;
        if (Math.abs(m.x - player.x) <= 1 && Math.abs(m.y - player.y) <= 1) {
          attack(m, player);
        } else {
          let path = getPath(m.x, m.y, player.x, player.y);
          if (path.length > 0) {
            let next = path[0];
            moveEntity(m, next.x - m.x, next.y - m.y);
          }
        }
      }
    }
    function handleTurnEnd() {
      if (player.poisonTurns > 0) {
        player.hp -= 1;
        player.poisonTurns--;
        log(`Poison! -1 HP`, 'damage');
        if (player.hp <= 0) {
          log('Died from poison!', 'death');
          setTimeout(showDeathScreen, 500);
          return;
        }
      }
      moveMonsters();
      if (player.hp > 0) {
        computeFOV(player.x, player.y, 8);
        updateStats();
        gameLoop();
      }
    }
    function handleMove(dx, dy) {
      if (player.hp <= 0) return;
      if (dx === 0 && dy === 0) { log('Wait', 'pickup'); turn++; handleTurnEnd(); }
      else { if (moveEntity(player, dx, dy)) { turn++; handleTurnEnd(); } else gameLoop(); }
    }
    function showDeathScreen() {
      document.getElementById('final-level').textContent = player.level;
      document.getElementById('final-gold').textContent = player.gold;
      document.getElementById('final-kills').textContent = kills;
      document.getElementById('final-turns').textContent = turn;
      document.getElementById('restart-modal').classList.add('show');
    }
    document.addEventListener('keydown', e => {
      if (player.hp <= 0) return;
      let dx = 0, dy = 0;
      if (e.key === 'ArrowUp' || e.key === 'k') dy = -1;
      else if (e.key === 'ArrowDown' || e.key === 'j') dy = 1;
      else if (e.key === 'ArrowLeft' || e.key === 'h') dx = -1;
      else if (e.key === 'ArrowRight' || e.key === 'l') dx = 1;
      else if (e.key === 'y') { dx = -1; dy = -1; }
      else if (e.key === 'u') { dx = 1; dy = -1; }
      else if (e.key === 'b') { dx = -1; dy = 1; }
      else if (e.key === 'n') { dx = 1; dy = 1; }
      else if (e.key === ' ') { e.preventDefault(); handleMove(0, 0); return; }
      else if (e.key >= '1' && e.key <= '5') {
        let i = parseInt(e.key) - 1;
        if (itemAction === 'use') useItem(i);
        else dropItem(i);
        return;
      }
      else if (e.key === 'd') {
        itemAction = 'drop';
        document.getElementById('toggle-action').textContent = 'Drop Mode (On)';
        log('Drop mode ON', 'pickup');
        return;
      }
      else return;
      e.preventDefault();
      handleMove(dx, dy);
    });
    document.querySelectorAll('.control-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const dir = btn.dataset.dir;
        let dx = 0, dy = 0;
        if (dir === 'wait') handleMove(0, 0);
        else { if (dir.includes('n')) dy = -1; if (dir.includes('s')) dy = 1; if (dir.includes('w')) dx = -1; if (dir.includes('e')) dx = 1; handleMove(dx, dy); }
      });
    });
    document.getElementById('toggle-action').addEventListener('click', () => {
      itemAction = itemAction === 'use' ? 'drop' : 'use';
      document.getElementById('toggle-action').textContent = itemAction === 'drop' ? 'Drop Mode (On)' : 'Drop Mode (Off)';
      log(itemAction === 'drop' ? 'Drop mode ON' : 'Drop mode OFF', 'pickup');
    });
    document.getElementById('restart-btn').addEventListener('click', () => initGame(true));
    function resizeCanvas() {
      const w = window.innerWidth < 768 ? window.innerWidth - 40 : 640;
      canvas.width = w;
      canvas.height = (w / WIDTH) * HEIGHT;
      TILE_SIZE = w / WIDTH;
      ctx.font = `${TILE_SIZE}px monospace`;
      console.log(`Canvas resized: ${canvas.width}x${canvas.height}, TILE_SIZE: ${TILE_SIZE}`);
      gameLoop();
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    initGame(true);
  </script>
</body>
</html>
