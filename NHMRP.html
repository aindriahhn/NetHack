<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, user-scalable=no" name="viewport" />
  <meta content="width=device-width, initial-scale=1.0" name="viewport" />
  <title>NetHack Roguelike (Mobile)</title>
  <style>
    body {
      margin: 0;
      padding: 5px;
      background: #002000;
      color: #0f0;
      font-family: 'Courier New', monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      box-sizing: border-box;
      padding-top: 16vh;
    }
    h1 {
      color: #0f0;
      border-bottom: 2px solid #0f0;
      padding-bottom: 5px;
      margin-bottom: 10px;
      font-weight: normal;
      font-size: 1.5rem;
      text-align: center;
      opacity: 0.5;
      transition: all 1s ease;
    }

h1.flash {
/* --- START BRIGHTENING EFFECT --- */
transition: all 2s ease;
opacity: 1; /* Start at full opacity */
text-shadow: 0 0 10px #0f0, 0 0 20px #00ff00; /* Start with a strong glow */
transition: all 1s ease; /* Transition ALL properties (opacity, shadow, etc.) quickly */
/* --- END BRIGHTENING EFFECT --- */
}

    h1.fade-out {
      opacity: 0;
      text-shadow: none; 
      transition: all 10s ease;
    }

    h1.hide {
      opacity: 0;
      transform: scale(0.8);
      height: 10;
      margin: 0;
      padding: 0;
      border: none;
      overflow: hidden;
      transition: all 1.5s ease;
    }
    #game-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
      max-width: 640px;
    }
    canvas {
      border: 2px solid #0f0;
      background: #002000;
      image-rendering: pixelated;
      width: 100%;
      height: auto;
      max-width: 100%;
    }
    #stats, #inventory, #log {
      padding: 8px;
      border: 2px solid #0f0;
      background: #000100;
      font-size: 10px;
      line-height: 1.4;
      border-radius: 4px;
    }
    #stats {
      overflow: hidden;
      transition: max-height 0.3s ease, opacity 0.3s ease;
      max-height: 1000px;
      /* enough to fit everything */
      opacity: 1;
    }

    #stats.collapsed {
      max-height: 8px;
      /* only show the top line */
      opacity: 0.8;
      cursor: pointer;
    }
    .death {
      color: #f0f;
    }
    .info {
      color: #0ff;
    }
    .modal-btn:disabled {
      background: #222;
      border-color: #555;
      color: #555;
      cursor: not-allowed;
    }
    #inventory {
      max-height: 140px;
      overflow-y: auto;
    }
    #inventory-list {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 5px;
    }
    .inventory-btn {
      background: #002200;
      border: 2px solid #0f0;
      color: #0f0;
      font-size: 10px;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      padding: 4px 6px;
      border-radius: 4px;
      transition: all 0.1s;
    }
    .inventory-btn:active {
      background: #003300;
      border-color: #0ff;
    }
    .action-mode-selected {
      background: #440 !important;
      border-color: #ff0 !important;
      color: #002000 !important;
    }
    #controls-group {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
      margin: 10px 0;
    }
    #controls {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 3px;
    }
    .control-btn {
      background: #002200;
      border: 2px solid #0f0;
      color: #0f0;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.1s;
      width: 50px;
      height: 50px;
      min-width: 40px;
      min-height: 40px;
      border-radius: 6px;
    }
    .control-btn[data-dir="wait"] {
      background: #333;
    }
    .control-btn:active {
      background: #333;
      border-color: #0ff;
    }
    #action-btns {
      display: flex;
      flex-direction: column;
      gap: 5px;
      align-items: stretch;
      justify-content: flex-start;
      height: 100%;
    }
    .action-btn {
      background: #002200;
      border: 2px solid #0f0;
      color: #0f0;
      font-size: 14px;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      padding: 8px 10px;
      border-radius: 4px;
      transition: all 0.2s;
      min-width: 100px;
      text-align: center;
      font-weight: bold;
    }
    #toggle-action.drop-mode {
      background: #400;
      border-color: #f00;
    }
    #throw-mode-btn.action-mode,
    #look-btn.action-mode {
      background: #004400;
      border-color: #0ff;
    }
    .action-btn:active {
      background: #003300;
      border-color: #0ff;
    }
    #monster-guide {
      padding: 10px;
      border: 2px solid #0f0;
      background: #000100;
      font-size: 12px;
      margin-top: 10px;
      width: 100%;
      max-width: 640px;
      box-sizing: border-box;
      border-radius: 4px;
    }
    #monster-guide h2 {
      margin: 0 0 10px 0;
      text-align: center;
      font-weight: normal;
      font-size: 14px;
    }
    #monster-guide ul {
      list-style-type: none;
      padding: 0;
      margin: 0;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px;
    }
    #monster-guide li {
      background: #002200;
      padding: 4px 8px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
@media (max-width: 450px) {
      #controls {
        grid-template-columns: repeat(3, 1fr);
        width: 150px;
        height: 150px;
      }
      .control-btn {
        width: 100%;
        height: 100%;
      }
      #action-btns {
        flex-grow: 1;
      }
    }
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .modal.show {
      display: flex;
    }
    .modal-content {
      background: #000100;
      border: 3px solid #0f0;
      padding: 20px;
      text-align: center;
      max-width: 90%;
      width: 340px;
      border-radius: 8px;
    }
    .modal-content h2 {
      color: #0f0;
      margin: 0 0 15px 0;
      font-size: 24px;
    }
    .modal-stats {
      margin: 15px 0;
      color: #0f0;
      font-size: 14px;
      line-height: 1.6;
    }
    .modal-btn {
      background: #002200;
      border: 2px solid #0f0;
      color: #0f0;
      padding: 10px 20px;
      font-size: 16px;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      border-radius: 4px;
      margin: 5px;
    }
    .modal-btn:active {
      background: #003300;
    }
    #restart-modal .modal-content {
      border-color: #f00;
    }
    #restart-modal h2 {
      color: #f00;
    }
    .role-desc {
      font-size: 12px;
      margin-bottom: 15px;
      color: #ccc;
    }
    #dead-runs-modal .modal-content {
      max-height: 85vh;
      overflow-y: auto;
      box-sizing: border-box;
    }
    #debug-overlay {
      position: fixed;
      bottom: 8px;
      right: 8px;
      background: rgba(0, 17, 0, 0.85);
      border: 1px solid #0f0;
      border-radius: 4px;
      padding: 6px 8px;
      font-size: 10px;
      color: #0f0;
      display: none;
      z-index: 1100;
    }
    #debug-toggle {
      background: #002200;
      border: 2px solid #0f0;
      color: #0f0;
      font-size: 12px;
      padding: 6px 8px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 6px;
      font-family: 'Courier New', monospace;
    }
    #log {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      width: 100%;
      box-sizing: border-box;
      height: 16vh;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.85);
      border-bottom: 2px solid #00ff00;
      color: #00ff00;
      padding: 6px;
      z-index: 200;
      transition: height 0.3s ease, opacity 0.3s ease, background 0.3s ease;
      backdrop-filter: blur(2px);
    }
    #log.log-entry {
      opacity: 0.6;
      transition: opacity 0.3s ease, color 0.3s ease;
      opacity: 1.5;
      margin: 2px 0;
    }
    #log.log-entry.latest {
      opacity: 1;
      color: #0f0;
      font-weight: bold;
      animation: logGlow10sease-out;
    }
    #log.expanded {
      height: 60vh;
      opacity: 0.3;
      background: rgba(0, 0, 0, 0.95);
    }
    #/* === Floating console overlay === */
    #log {
      position: fixed;
      top: 0;
      left: 0;
      transform: translateX(-50%);
      width: 92%;
      max-width: 720px;
      box-sizing: border-box;
      height: 12vh;
      /* default contracted height */
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.75);
      border-top: 2px solid #00ff00;
      color: #00ff00;
      padding: 4px;
      z-index: 200;
      touch-action: manipulation;
      opacity 0.2s;
      height: 12vh;
      /* contracted */
      transition: height 0.3s ease;
    }

    #log:not(.expanded) {
      transition: height 0.3s ease, opacity 0.7s ease, background 0.15s ease;
    }
    #log.expanded {
      height: 60vh;
      /* expanded */
    }
    #log.dragging {
      opacity: 0.85;
      border-color: #0f0;
    }

    #log.floating {
      opacity: 0.3;
      background: rgba(0, 0, 0, 0.4);
    }
    #log:hover,
    #log:active,
    #log.interacting {
      opacity: 1;
      background: rgba(0, 0, 0, 0.9);
    }
    #log.dragging {
      opacity: 0.3;
      border-color: #0f0;
    }
    #log .damage {
      color: #f00;
    }
    #log .pickup {
      color: #ff0;
    }
    #log .death {
      color: #f0f;
    }
    #log .info {
      color: #0ff;
    }

    /* 4. Keyframes (Definitions for Animations) */

@keyframes logGlow {
      0% {
        text-shadow: 0 0 0px #0f0;
      }
      30% {
        text-shadow: 0 0 25px #0f0;
      }
      100% {
        text-shadow: 0 0 0px #0f0;
      }
    }
@-webkit-keyframes scanFlicker {
      0%, 100% {
        opacity: 0.68;
      }
      25%, 75% {
        opacity: 0.68;
      }
      50% {
        opacity: 0.70;
      }
    }
@keyframes scanFlicker {
      0%, 100% {
        opacity: 0.68;
      }
      25%, 75% {
        opacity: 0.68;
      }
      50% {
        opacity: 0.70;
      }
    }
@-webkit-keyframes scanSweep {
      0% {
        -webkit-transform: translateY(-3px);
        transform: translateY(-3px);
        opacity: 0;
      }
      10% {
        opacity: 0.35;
      }
      50% {
        opacity: 0.30;
      }
      90% {
        opacity: 0.35;
      }
      100% {
        -webkit-transform: translateY(100vh);
        transform: translateY(100vh);
        opacity: 0;
      }
    }
@keyframes scanSweep {
      0% {
        transform: translateY(-10px);
        opacity: 0;
      }
      10% {
        opacity: 0.8;
      }
      50% {
        opacity: 0.6;
      }
      90% {
        opacity: 0.8;
      }
      100% {
        transform: translateY(100vh);
        opacity: 0;
      }
    }

    /* 5. CRT Overlay Styles (Uses Keyframes defined above, requires class="crt" on <body>) */

    body.crt::before {
      content: '';
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
      repeating-linear-gradient(0deg, rgba(0,0,0,0.5) 0, rgba(0,0,0,0.15) 1px, transparent 2px),
      radial-gradient(circle at 50% 50%, rgba(0,255,0,0.1), transparent 70%);
      mix-blend-mode: overlay;
      z-index: 5000;
      display: block;
      will-change: opacity;
      -webkit-animation: scanFlicker 1.2s ease-in-out infinite;
      animation: scanFlicker 1.2s ease-in-out infinite;
    }

    body.crt::after {
      content: '';
      position: fixed;
      left: 0;
      right: 0;
      top: 0;
      pointer-events: none;
      height: 8px;
      background: linear-gradient(
      to bottom,
      rgba(0, 255, 0, 0) 0%,
      rgba(0, 255, 0, 0.5) 50%,
      rgba(0, 255, 0, 0) 100%
      );
      box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
      mix-blend-mode: screen;
      z-index: 5001;
      display: block;
      will-change: transform;
 -webkit-animation: scanSweep 6s linear infinite;
animation: scanSweep 6s linear infinite;
    }
  </style>
</head>
<body class="crt">
  <h1>NetHack Style Roguelike (Mobile)</h1>
  <div id="game-container">
    <div id="log">
      <div class="log-entry">
        Welcome! Use the on-screen controls to move. Find stairs (&gt;) to descend!
      </div>
    </div>
    <canvas height="480" id="nethack" width="640"></canvas>
    <div id="stats">
      <div id="stats-header"
        style="background:#002; padding:4px; text-align:center; font-weight:bold; cursor:pointer;">
        <span id="stats-arrow">▼</span>
        <span id="stats-summary" style="font-weight:normal;">
          HP: <span id="hp">20/20</span>
          $<span id="gold">0</span>
          AP: <span id="ap">100/100</span>  <span id="status">Normal</span>/<span id="hunger">Satiated</span>
        </span>
        <span id="stats-arrow-2">▼</span>
      </div>
      <div id="stats-body" style="display:block; text-align:center;">
        <div>
          Lvl: <span id="level">1</span> | XP: <span id="xp">0</span> | Depth: <span id="depth">1</span>
        </div>
        <div>
          DR: <span id="dr">1</span> | Dodge: <span id="dodge">5%</span>
        </div>
        <div>
          Weapon: <span id="weapon">Fists</span> | Armor: <span id="armor">None</span>
        </div>
      </div>
    </div>
    <div id="uiSegment">
      <div id="controls-group">
        <div style="display: flex; flex-direction: column; gap: 5px;">
          <div id="controls">
            <button class="control-btn" data-dir="nw">↖</button>
            <button class="control-btn" data-dir="n">↑</button>
            <button class="control-btn" data-dir="ne">↗</button>
            <button class="control-btn" data-dir="w">←</button>
            <button class="control-btn" data-dir="wait">•</button>
            <button class="control-btn" data-dir="e">→</button>
            <button class="control-btn" data-dir="sw">↙</button>
            <button class="control-btn" data-dir="s">↓</button>
            <button class="control-btn" data-dir="se">↘</button>
          </div>
          <div style="background:#020; padding:4px; text-align:center; font-weight:bold;">
            ACTIONS
          </div>
          <div id="quick-actions" style="display: flex; flex-direction: column; gap: 3px;">
            <button class="action-btn" data-action="use-feature" style="font-size: 12px; padding: 6px;">⬇️ Activate</button>
            <button class="action-btn" data-action="look-throw" style="font-size: 12px; padding: 6px;">🎯 Look-Throw</button>
            <button class="action-btn" data-action="look-zap" style="font-size: 12px; padding: 6px;">⚡️ Look-Zap</button>
            <button class="action-btn" data-action="look-shoot" style="font-size: 12px; padding: 6px;">🏹 Look-Shoot</button>
            <button class="action-btn" data-action="apply" style="font-size: 12px; padding: 6px;">🔧 Use Tool</button>
            <button class="action-btn" id="zoom-toggle-btn">🔍 Zoom: 1x</button>
          </div>
        </div>
        <div id="action-btns">
          <button class="action-btn" id="look-btn">🔍 Look Mode</button>
          <button class="action-btn" id="activate-btn">⬇️ Activate</button>
          <button class="action-btn" id="class-skill-btn">🎯 Class Skill</button>
          <button class="action-btn" id="toggle-action">Use/Drop Mode</button>
          <button class="action-btn" id="actions-btn">🙏 Actions</button>
          <button class="action-btn" id="save-btn">💾 Save</button>
          <button class="action-btn" id="load-btn">📂 Load</button>
          <button id="debug-toggle">Debug</button>
        </div>
      </div>
    </div>
    <div id="inventory">
      <div id="inventory-header" style="background:#020; padding:4px; text-align:center; font-weight:bold; cursor:pointer;">
        Inventory ▼
      </div>
      <div id="inventory-body">
        <div>
          Inventory (Tap to Use/Drop/Throw):
        </div>
        <div id="inventory-list"></div>
      </div>
    </div>
    <div id="status-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; padding: 8px; border: 2px solid #0f0; background: #000100; margin: 8px 0; border-radius: 4px;">
    </div>
  </div>
  <div id="monster-guide" style="text-align:center;">
    <h2>Monster Guide</h2>
    <ul>
      <li>(r) Rat <span style="background: #964; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(b) Bat (erratic) <span style="background: #555; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(s) Spider (erratic) <span style="background: #770; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(g) Goblin (equips) <span style="background: #0a0; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(k) Kobold (coward) <span style="background: #a52a2a; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(j) Slime (divides) <span style="background: #9f9; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(w) Wolf (chaser) <span style="background: #888; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(a) Giant Ant (swarm) <span style="background: #c60; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(G) Gnome (equips) <span style="background: #a55; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(S) Snake (poisoner) <span style="background: #0a0; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(f) Fungi (spore) <span style="background: #9c6; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(h) Hobgoblin <span style="background: #f60; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(c) Cockatrice (petrify) <span style="background: #cc0; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(i) Imp (teleporter) <span style="background: #f0f; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(Z) Zombie (slow) <span style="background: #6a6; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(o) Orc <span style="background: #f80; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(m) Mimic (ambusher) <span style="background: #964; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(R) Rust Monster (corrodes) <span style="background: #c84; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(y) Yellow Light (explodes) <span style="background: #ff0; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(s) Skeleton (resists) <span style="background: #eee; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(n) Nymph (thief) <span style="background: #0cf; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(Q) Quasit (ranged) (D7) <span style="background: #909; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(u) Unicorn (peaceful) (D7) <span style="background: #fff; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(W) Wraith (drainer) (D8) <span style="background: #999; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(v) Vampire (drainer) (D9) <span style="background: #a00; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(T) Troll <span style="background: #0f0; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(O) Ogre <span style="background: #f99; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(D) Dragon <span style="background: #f00; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(x) Xorn (phaser) <span style="background: #c90; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(M) Minotaur (chaser) <span style="background: #a44; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(E) Elemental (summoner) <span style="background: #0af; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(V) Vampire Lord <span style="background: #600; width: 10px; height: 10px; display: inline-block;"></span></li>
      <li>(L) Lich (ranged) <span style="background: #a0f; width: 10px; height: 10px; display: inline-block;"></span></li>
    </ul>
  </div>
</div>
<div class="modal" id="start-screen-modal">
  <div class="modal-content">
    <h2 style="font-size: 28px; border-bottom: 2px solid #0f0; padding-bottom: 10px;">NetHack Roguelike</h2>
    <div class="modal-stats" style="color: #ccc; font-size: 14px;">
      Delve into the Mobile-est Version of the Dungeons of Doom!
    </div>
    <button class="modal-btn" id="start-new-game-btn">New Game</button>
    <button class="modal-btn" disabled="" id="start-load-game-btn">Load Game</button>
  </div>
</div>
<div class="modal" id="char-select-modal">
  <div class="modal-content">
    <h2>Choose your Role</h2>
    <div class="role-desc">
      Each role starts with different stats and gear.
    </div>
    <input id="player-name-input" maxlength="20" placeholder="Enter your name" style="
    margin-bottom: 10px;
    padding: 6px 8px;
    font-family: 'Courier New', monospace;
    font-size: 14px;
    width: 100%;
    border: 2px solid #0f0;
    background: #000100;
    color: #0f0;
    border-radius: 4px;
    box-sizing: border-box;
    " type="text" />
    <button class="modal-btn" id="role-barbarian">Barbarian</button>
    <button class="modal-btn" id="role-wizard">Wizard</button>
    <button class="modal-btn" id="role-rogue">Rogue</button>
    <button class="modal-btn" id="role-archer">Archer</button>
    <button class="modal-btn" id="view-dead-runs-btn">🪦 View Dead Runs</button>
  </div>
</div>
<div class="modal" id="dead-runs-modal">
  <div class="modal-content">
    <h2>🪦 Dead Runs</h2>
    <div id="dead-runs-list"></div>
    <button class="modal-btn" id="clear-dead-runs-btn">Clear Dead Runs</button>
    <button class="modal-btn" id="close-dead-runs-btn">Close</button>
  </div>
</div>
<div class="modal" id="actions-modal">
  <div class="modal-content">
    <h2>Actions</h2>
    <button class="modal-btn" data-action="spellbook">📖 Spellbook</button>
    <button class="modal-btn" data-action="pray">🙏 Pray (100 AP)</button>
    <button class="modal-btn" data-action="kick">🦶 Kick (120 AP)</button>
    <button class="modal-btn" data-action="disarm">🔧 Disarm Trap (150 AP)</button>
    <button class="modal-btn" data-action="engrave">✍️ Engrave 'Elbereth' (150 AP)</button>
    <button class="modal-btn" data-action="close">Close</button>
  </div>
</div>
<div class="modal" id="shop-modal">
  <div class="modal-content" style="max-width: 95%; width: 480px; max-height: 85vh; overflow-y: auto;">
    <h2 id="shop-title">General Store - Depth <span id="shop-depth">1</span></h2>
    <div style="display: flex; gap: 5px; margin-bottom: 10px;">
      <button class="modal-btn" id="shop-buy-tab" style="flex: 1; font-size: 14px; background: #004400;">
        Buy
      </button>
      <button class="modal-btn" id="shop-sell-tab" style="flex: 1; font-size: 14px;">
        Sell
      </button>
      <button class="modal-btn" id="shop-steal-tab" style="flex: 1; font-size: 14px;">
        Steal
      </button>
    </div>
    <div style="text-align: center; color: #ff0; margin-bottom: 10px; font-size: 14px; border: 1px solid #ff0; padding: 5px; border-radius: 4px;">
      Your Gold: <span id="shop-player-gold">0</span>
    </div>
    <div id="shop-item-list" style="max-height: 320px; overflow-y: auto; margin-bottom: 10px;">
    </div>
    <div id="shop-status" style="color: #0af; font-size: 11px; min-height: 20px; margin-bottom: 8px; text-align: center;">
      Select an item to see details
    </div>
    <div style="display: flex; gap: 8px;">
      <button class="modal-btn" id="shop-close" style="flex: 1;">
        Leave Shop
      </button>
    </div>
  </div>
</div>
<div class="modal" id="restart-modal">
  <div class="modal-content">
    <h2>You Died</h2>
    <div class="modal-stats">
      <div>
        Final Level: <span id="final-level">1</span>
      </div>
      <div>
        Gold: <span id="final-gold">0</span>
      </div>
      <div>
        Kills: <span id="final-kills">0</span>
      </div>
      <div>
        Turns: <span id="final-turns">0</span>
      </div>
    </div>
    <button class="modal-btn" id="restart-btn">Play Again</button>
  </div>
</div>
<div id="debug-overlay"></div>
</div>
<div class="modal" id="spellbook-modal">
  <div class="modal-content" style="max-width: 500px;">
    <h2 style="color: #0af;">📖 Spellbook</h2>
    <div id="spell-list" style="display: flex; flex-direction: column; gap: 8px; margin: 15px 0;"></div>
    <button class="modal-btn" id="close-spellbook">Close</button>
  </div>
</div>
<div class="modal" id="enchant-shop-modal">
  <div class="modal-content" style="max-width: 500px;">
    <h2 style="color: #0f0;">🔮 Enchanter's Workshop</h2>
    <div style="color: #ff0; text-align: center; margin: 10px 0;">
      Your Gold: <span id="enchant-gold">0</span>
    </div>
    <div style="color: #888; font-size: 11px; text-align: center; margin-bottom: 15px;">
      Select equipment to enhance
    </div>
    <div id="enchant-equipment-list" style="display: flex; flex-direction: column; gap: 8px;"></div>
    <button class="modal-btn" id="close-enchant-shop">Leave</button>
  </div>
</div>

<script>
const canvas = document.getElementById("nethack");
const ctx = canvas.getContext("2d");
let TILE_SIZE = 16;
const WIDTH = 80;
const HEIGHT = 60;
let zoomLevel = 1;
const ZOOM_CONFIGS = {
1: {
viewWidth: 40,
viewHeight: 30,
tileSize: 16
},
2: {
viewWidth: 20,
viewHeight: 15,
tileSize: 32
},
3: {
viewWidth: 13,
viewHeight: 10,
tileSize: 48
}
};

function getViewWidth() {
return ZOOM_CONFIGS[zoomLevel].viewWidth;
}

function getViewHeight() {
return ZOOM_CONFIGS[zoomLevel].viewHeight;
}

function getTileSize() {
return ZOOM_CONFIGS[zoomLevel].tileSize;
}

const AP_COSTS = {
MOVE: 100,
ATTACK: 100,
WAIT: 0,
SEARCH: 200,
USE_ITEM: 50,
THROW: 100,
OPEN_DOOR: 50,
BASH_DOOR: 250,
KICK: 220,
PRAY: 200,
ENGRAVE: 300,
ZAP: 100,
APPLY: 200,
RAGE: 100,
SHOOT: 200,
AUTO_SHOOT: 0,
AUTO_ZAP: 0
};
//Must Fix this⬇️
const LEVEL_XP_REQUIREMENTS = [0, 25, 50, 75, 100, 125, 250, 450, 700, 1000, 1400, 1900, 2500, 3200, 4000];
const EFFECT_TYPES = {
identify: {
identify: true
},
teleport: {
teleport: true
},
magicMap: {
magicMap: true
},
removeCurse: {
removeCurse: true
},
telepathy: {
telepathy: true,
radius: 16
},
strength: {
strength: 20
},
confusion: {
confusion: 15
},
speed: {
speed: 10
},
satiate: {
nutrition: 500
},
burning: {
damage: 2,
turns: 3,
spreadChance: 0.15
}
};
class WeaponMod {
constructor({
bonus = 0, element = null, cursed = false, apModifier = 0
}) {
this.bonus = bonus;
this.element = element;
this.cursed = cursed;
this.apModifier = apModifier;
}

getNamePrefix() {
if (this.cursed) return 'Cursed';
if (this.element) {
const elementNames = {
fire: 'Flaming',
ice: 'Freezing',
poison: 'Venomous',
shock: 'Shocking'
};
return elementNames[this.element] || this.element;
}
return '';
}

applyTo(baseWeapon) {
return {
...baseWeapon,
damage: baseWeapon.damage + this.bonus,
apCost: Math.max(10, (baseWeapon.apCost || AP_COSTS.ATTACK) - this.apModifier),
element: this.element,
cursed: this.cursed,
mod: this
};
}

onHit(attacker, target) {
if (!this.element) return;

switch (this.element) {
case 'fire':
const fireDamage = rollDice(1, 3);
if (target === player) {
takeDamage(fireDamage, 'fire');
} else {
takeMonsterDamage(target, fireDamage, 'fire', attacker);
}
if (attacker === player) {
log(`Your weapon burns ${target.name} for ${fireDamage} extra damage!`, 'damage');
}
break;

case 'ice':
if (Math.random() < 0.3) {
if (target === player) {
player.paralyzedTurns += 1;
log('You feel frozen!', 'damage');
} else {
target.ap = Math.max(0, target.ap - 50);
if (attacker === player) log(`${target.name} is slowed by frost!`, 'pickup');
}
}
break;

case 'poison':
if (target === player) {
player.poisonTurns += 3;
log('The venomous weapon poisons you!', 'damage');
} else {
target.poisonTurns = (target.poisonTurns || 0) + 3;
if (attacker === player) log(`${target.name} is poisoned!`, 'pickup');
}
break;

case 'shock':
if (Math.random() < 0.25 && attacker === player) {
const nearbyMonster = monsters.find(m =>
m !== target &&
Math.hypot(m.x - target.x, m.y - target.y) < 2
);
if (nearbyMonster) {
const chainDamage = rollDice(1, 2);
nearbyMonster.hp -= chainDamage;
log(`Lightning chains to ${nearbyMonster.name} for ${chainDamage} damage!`, 'damage');
if (nearbyMonster.hp <= 0) handleEntityDeath(player, nearbyMonster);
}
}
break;
}
}
}

let player;
let dungeon = {
tiles: [],
width: WIDTH,
height: HEIGHT,
rooms: [],
features: [],
engravings: []
};
let environmentals = [];
let monsters = [];
let pets = [];
let items = [];
let traps = [];
let turn = 0;
let kills = 0;
let dungeonLevel = 1;
let itemAction = 'use';
let visible = Array(HEIGHT).fill().map(() => Array(WIDTH).fill(false));
let explored = Array(HEIGHT).fill().map(() => Array(WIDTH).fill(false));
let espVisible = Array(HEIGHT).fill().map(() => Array(WIDTH).fill(false));

let itemVisualToTypeMap = {};
let needsRedraw = true;
let currentActionContext = null;
let target = null;
let targetName = null;
let targetHP = null;
let stunTurns;

const OFFLINE_SAVE_KEY = 'NetHackSave';
let lastAutosaveTurn = 0;

const DUNGEON_TYPES = [
  {
    type: 'normal',
    name: 'Stone Corridors',
    weight: 40,
    description: 'Standard dungeon corridors',
    modifiers: {
      monsterSpawnMult: 1.0,
      itemSpawnMult: 1.0,
      trapSpawnMult: 1.0,
      darkChance: 0.3,
      roomCount: 20
    },
    tileColors: {
      floor: '#0f0',
      wall: '#050'
    }
  },
  {
    type: 'crypt',
    name: 'Ancient Crypt',
    weight: 15,
    description: 'Dusty tombs filled with undead',
    modifiers: {
      monsterSpawnMult: 1.3,
      itemSpawnMult: 0.8,
      trapSpawnMult: 1.2,
      darkChance: 0.6,
      roomCount: 15,
      forceMonsterTypes: ['zombie', 'skeleton', 'wraith', 'vampire'],
      bonusGold: 1.5
    },
    tileColors: {
      floor: '#888',
      wall: '#333'
    }
  },
  {
    type: 'flooded',
    name: 'Flooded Halls',
    weight: 12,
    description: 'Water-logged passages',
    modifiers: {
      monsterSpawnMult: 0.9,
      itemSpawnMult: 1.2,
      trapSpawnMult: 0.5,
      darkChance: 0.2,
      roomCount: 18,
      forceMonsterTypes: ['slime', 'snake'],
      waterFeatures: true
    },
    tileColors: {
      floor: '#0af',
      wall: '#035'
    }
  },
  {
    type: 'inferno',
    name: 'Infernal Chamber',
    weight: 10,
    description: 'Flames dance on every surface',
    modifiers: {
      monsterSpawnMult: 1.1,
      itemSpawnMult: 0.7,
      trapSpawnMult: 0.8,
      darkChance: 0.1, // Well lit by flames
      roomCount: 16,
      forceMonsterTypes: ['dragon', 'elemental', 'imp'],
      fireHazards: true,
      burnResistRecommended: true
    },
    tileColors: {
      floor: '#f80',
      wall: '#820'
    }
  },
  {
    type: 'treasure',
    name: 'Treasure Vault',
    weight: 5,
    description: 'Gold glitters everywhere',
    modifiers: {
      monsterSpawnMult: 0.7,
      itemSpawnMult: 2.5,
      trapSpawnMult: 2.0,
      darkChance: 0.1,
      roomCount: 12,
      forceMonsterTypes: ['mimic', 'nymph', 'dragon'],
      bonusGold: 3.0,
      guaranteedVault: true
    },
    tileColors: {
      floor: '#ff0',
      wall: '#880'
    }
  },
  {
    type: 'maze',
    name: 'Twisted Maze',
    weight: 8,
    description: 'Confusing winding passages',
    modifiers: {
      monsterSpawnMult: 0.8,
      itemSpawnMult: 0.9,
      trapSpawnMult: 1.5,
      darkChance: 0.5,
      roomCount: 25,
      narrowCorridors: true,
      confusingLayout: true
    },
    tileColors: {
      floor: '#0f0',
      wall: '#030'
    }
  },
  {
    type: 'cathedral',
    name: 'Grand Cathedral',
    weight: 6,
    description: 'Echoing holy halls',
    modifiers: {
      monsterSpawnMult: 0.6,
      itemSpawnMult: 1.3,
      trapSpawnMult: 0.3,
      darkChance: 0.2,
      roomCount: 10,
      largeRooms: true,
      guaranteedAltar: true,
      holyGround: true
    },
    tileColors: {
      floor: '#fff',
      wall: '#888'
    }
  },
  {
    type: 'fungal',
    name: 'Fungal Grove',
    weight: 10,
    description: 'Strange mushrooms everywhere',
    modifiers: {
      monsterSpawnMult: 1.2,
      itemSpawnMult: 1.1,
      trapSpawnMult: 0.6,
      darkChance: 0.7,
      roomCount: 17,
      forceMonsterTypes: ['fungi', 'slime'],
      gasHazards: true,
      poisonResistRecommended: true
    },
    tileColors: {
      floor: '#9c6',
      wall: '#460'
    }
  }
];

const PET_TYPES = [{
glyph: 'd',
name: 'little dog',
color: '#ccc',
hp: 10,
damage: 2,
defense: 5,
hitChance: 75,
apRegen: 110
}];

const MONSTER_TYPES = [
// === DEPTH 1 ===
{
glyph: 'r',
name: 'rat',
color: '#964',
hp: 3,
damage: 1,
xp: 3,
defense: 0,
hitChance: 70,
depth: 1,
apRegen: 50,
ap: 100,
maxAP: 100,
exhaustedTurns: 0
},
{
glyph: 'b',
name: 'bat',
color: '#555',
hp: 4,
damage: 1,
xp: 4,
defense: 5,
hitChance: 75,
depth: 1,
apRegen: 50,
maxAP: 100,
ap: 100,
exhaustedTurns: 0,
behavior: 'erratic'
},
{
glyph: 's',
name: 'spider',
color: '#770',
hp: 6,
damage: 2,
xp: 6,
defense: 3,
hitChance: 78,
depth: 1,
apRegen: 60,
ap: 120,
maxAP: 120,
exhaustedTurns: 0,
behavior: 'erratic'
},
{
glyph: 'g',
name: 'goblin',
color: '#0a0',
hp: 5,
damage: 2,
xp: 5,
defense: 5,
hitChance: 80,
depth: 1,
apRegen: 50,
maxAP: 100,
ap: 100,
exhaustedTurns: 0,
behavior: 'equipper'
},
{
glyph: 'k',
name: 'kobold',
color: '#a52a2a',
hp: 4,
damage: 1,
xp: 4,
defense: 2,
hitChance: 75,
depth: 1,
apRegen: 100,
maxAP: 100,
ap: 100,
exhaustedTurns: 0,
behavior: 'coward'
},

// === DEPTH 2 ===
{
glyph: 'j',
name: 'slime',
color: '#9f9',
hp: 12,
damage: 2,
xp: 12,
defense: 5,
hitChance: 80,
depth: 2,
apRegen: 100,
maxAP: 100,
ap: 0,
exhaustedTurns: 0,
behavior: 'divider'
},
{
glyph: 'w',
name: 'wolf',
color: '#888',
hp: 8,
damage: 3,
xp: 8,
defense: 6,
hitChance: 82,
depth: 2,
apRegen: 70,
ap: 140,
maxAP: 140,
exhaustedTurns: 0,
behavior: 'chaser'
},
{
glyph: 'a',
name: 'giant ant',
color: '#c60',
hp: 5,
damage: 2,
xp: 5,
defense: 4,
hitChance: 75,
depth: 2,
apRegen: 60,
ap: 120,
maxAP: 120,
exhaustedTurns: 0,
behavior: 'swarm'
},
{
glyph: 'G',
name: 'gnome',
color: '#a55',
hp: 6,
damage: 2,
xp: 6,
defense: 6,
hitChance: 78,
depth: 2,
apRegen: 60,
maxAP: 100,
ap: 100,
exhaustedTurns: 0,
behavior: 'equipper'
},
{
glyph: 'S',
name: 'snake',
color: '#0a0',
hp: 6,
damage: 2,
xp: 6,
defense: 5,
hitChance: 80,
depth: 2,
apRegen: 70,
maxAP: 140,
ap: 140,
exhaustedTurns: 0,
behavior: 'poisoner'
},

// === DEPTH 3 ===
{
glyph: 'f',
name: 'fungi',
color: '#9c6',
hp: 8,
damage: 1,
xp: 6,
defense: 2,
hitChance: 70,
depth: 3,
apRegen: 40,
maxAP: 80,
ap: 80,
exhaustedTurns: 0,
behavior: 'spore'
},
{
glyph: 'h',
name: 'hobgoblin',
color: '#f60',
hp: 10,
damage: 3,
xp: 12,
defense: 8,
hitChance: 83,
depth: 3,
apRegen: 70,
maxAP: 140,
ap: 140,
exhaustedTurns: 0
},

// === DEPTH 4 ===
{
glyph: 'c',
name: 'cockatrice',
color: '#cc0',
hp: 7,
damage: 2,
xp: 12,
defense: 6,
hitChance: 80,
depth: 4,
apRegen: 50,
maxAP: 100,
ap: 100,
exhaustedTurns: 0,
behavior: 'petrifier'
},
{
glyph: 'i',
name: 'imp',
color: '#f0f',
hp: 6,
damage: 2,
xp: 8,
defense: 10,
hitChance: 85,
depth: 4,
apRegen: 80,
maxAP: 160,
ap: 160,
exhaustedTurns: 0,
behavior: 'teleporter'
},
{
glyph: 'Z',
name: 'zombie',
color: '#6a6',
hp: 12,
damage: 3,
xp: 15,
defense: 8,
hitChance: 75,
depth: 4,
apRegen: 40,
maxAP: 80,
ap: 0,
exhaustedTurns: 0,
behavior: 'shambler',
intrinsics: {
poisonResist: true
}
},

// === DEPTH 5 ===
{
glyph: 'o',
name: 'orc',
color: '#f80',
hp: 8,
damage: 3,
xp: 10,
defense: 10,
hitChance: 85,
depth: 5,
apRegen: 100,
maxAP: 100,
ap: 100,
exhaustedTurns: 0
},
{
glyph: 'm',
name: 'mimic',
color: '#964',
hp: 12,
damage: 3,
xp: 15,
defense: 12,
hitChance: 80,
depth: 5,
apRegen: 50,
maxAP: 100,
ap: 0,
exhaustedTurns: 0,
behavior: 'ambusher',
mimicItem: true
},
{
glyph: 'R',
name: 'rust monster',
color: '#c84',
hp: 12,
damage: 2,
xp: 18,
defense: 10,
hitChance: 82,
depth: 5,
apRegen: 60,
maxAP: 120,
ap: 120,
exhaustedTurns: 0,
behavior: 'corroder'
},
{
glyph: 'y',
name: 'yellow light',
color: '#ff0',
hp: 8,
damage: 3,
xp: 12,
defense: 0,
hitChance: 85,
depth: 5,
apRegen: 100,
maxAP: 200,
ap: 200,
exhaustedTurns: 0,
behavior: 'exploder'
},

// === DEPTH 6 ===
{
glyph: 's',
name: 'skeleton',
color: '#eee',
hp: 10,
damage: 4,
xp: 15,
defense: 12,
hitChance: 88,
depth: 6,
apRegen: 50,
maxAP: 100,
ap: 0,
exhaustedTurns: 0,
resists: 'piercing'
},
{
glyph: 'n',
name: 'nymph',
color: '#0cf',
hp: 8,
damage: 1,
xp: 10,
defense: 15,
hitChance: 90,
depth: 6,
apRegen: 100,
maxAP: 200,
ap: 200,
exhaustedTurns: 0,
behavior: 'thief'
},

// === DEPTH 7 ===
{
glyph: 'Q',
name: 'quasit',
color: '#909',
hp: 10,
damage: 3,
xp: 15,
defense: 10,
hitChance: 85,
depth: 7,
apRegen: 80,
maxAP: 160,
ap: 160,
exhaustedTurns: 0,
behavior: 'ranged',
intrinsics: {
poisonResist: true
}
},
{
glyph: 'u',
name: 'unicorn',
color: '#fff',
hp: 15,
damage: 4,
xp: 20,
defense: 12,
hitChance: 88,
depth: 7,
apRegen: 100,
maxAP: 200,
ap: 200,
exhaustedTurns: 0,
behavior: 'peaceful',
alignment: 'lawful'
},

// === DEPTH 8 ===
{
glyph: 'W',
name: 'wraith',
color: '#999',
hp: 14,
damage: 4,
xp: 25,
defense: 16,
hitChance: 88,
depth: 8,
apRegen: 70,
maxAP: 140,
ap: 0,
exhaustedTurns: 0,
behavior: 'drainer',
intrinsics: {
coldResist: true,
poisonResist: true
}
},

// === DEPTH 9 ===
{
glyph: 'v',
name: 'vampire',
color: '#a00',
hp: 18,
damage: 5,
xp: 30,
defense: 14,
hitChance: 90,
depth: 9,
apRegen: 80,
maxAP: 160,
ap: 0,
exhaustedTurns: 0,
behavior: 'drainer',
intrinsics: {
coldResist: true
}
},

// === DEPTH 10 ===
{
glyph: 'T',
name: 'troll',
color: '#0f0',
hp: 15,
damage: 5,
xp: 20,
defense: 15,
hitChance: 90,
depth: 10,
apRegen: 50,
maxAP: 100,
exhaustedTurns: 0,
ap: 0
},
{
glyph: 'O',
name: 'ogre',
color: '#f99',
hp: 25,
damage: 7,
xp: 40,
defense: 18,
hitChance: 92,
depth: 10,
apRegen: 50,
maxAP: 100,
ap: 0,
exhaustedTurns: 0
},
{
glyph: 'D',
name: 'dragon',
color: '#f00',
hp: 30,
damage: 8,
xp: 50,
defense: 20,
hitChance: 95,
depth: 10,
apRegen: 200,
maxAP: 200,
ap: 0,
exhaustedTurns: 0,
intrinsics: {
fireResist: true,
coldResist: true,
shockResist: true
}
},

// === DEPTH 11 ===
{
glyph: 'x',
name: 'xorn',
color: '#c90',
hp: 20,
damage: 6,
xp: 35,
defense: 20,
hitChance: 92,
depth: 11,
apRegen: 60,
maxAP: 120,
ap: 0,
exhaustedTurns: 0,
behavior: 'phaser'
},

// === DEPTH 12 ===
{
glyph: 'M',
name: 'minotaur',
color: '#a44',
hp: 28,
damage: 7,
xp: 50,
defense: 16,
hitChance: 92,
depth: 12,
apRegen: 80,
maxAP: 160,
ap: 0,
exhaustedTurns: 0,
behavior: 'chaser'
},
{
glyph: 'E',
name: 'elemental',
color: '#0af',
hp: 22,
damage: 6,
xp: 40,
defense: 18,
hitChance: 90,
depth: 12,
apRegen: 100,
maxAP: 200,
ap: 0,
exhaustedTurns: 0,
behavior: 'summoner',
intrinsics: {
fireResist: true,
coldResist: true
}
},

// === DEPTH 14 ===
{
glyph: 'V',
name: 'vampire lord',
color: '#600',
hp: 30,
damage: 8,
xp: 80,
defense: 20,
hitChance: 95,
depth: 14,
apRegen: 100,
maxAP: 200,
ap: 0,
exhaustedTurns: 0,
behavior: 'drainer',
intrinsics: {
coldResist: true,
poisonResist: true
}
},

// === DEPTH 15 ===
{
glyph: 'L',
name: 'lich',
color: '#a0f',
hp: 40,
damage: 10,
xp: 100,
defense: 25,
hitChance: 98,
depth: 15,
apRegen: 150,
maxAP: 150,
ap: 0,
exhaustedTurns: 0,
behavior: 'ranged',
intrinsics: {
poisonResist: true,
coldResist: true
}
}];

const MONSTER_STATES = {
sleeping: {
wakeDistance: 2,
wakeChance: 0.01,
canAct: false
},
wandering: {
moveChance: 0.5,
sleepChance: 0.01,
canAct: true
},
chasing: {
aggressive: true,
canAct: true
},
fleeing: {
avoidPlayer: true,
canAct: true
},
confused: {
randomMove: true,
canAct: true
},
hunting: {
persistent: true,
canAct: true
},
guarding: {
patrolRadius: 3,
canAct: true
}
};

const ITEM_TYPES = [{
glyph: '>',
name: 'stairs',
color: '#fff',
isStairs: true,
status: 'Normal',
identified: true,
depth: 1
},
{
glyph: ')',
baseName: 'shortbow',
name: 'bow',
color: '#8B4513',
damage: 5,
range: 8,
depth: 1,
type: 'ranged_weapon',
ammoType: 'arrows',
basePrice: 1
},
{
glyph: ')',
baseName: 'longbow',
name: 'bow',
color: '#8B4513',
damage: 5,
range: 10,
depth: 1,
type: 'ranged_weapon',
ammoType: 'arrows',
identified: false,
basePrice: 1
},
{
glyph: '{',
baseName: 'arrows',
name: 'arrows',
color: '#CD853F',
damage: 4,
depth: 1,
type: 'ammo',
stackable: true,
identified: false,
count: 1,
basePrice: 0.5
},
{
glyph: '[',
baseName: 'quiver',
name: 'quiver',
color: '#8B4513',
depth: 1,
type: 'accessory',
quiverCapacity: 50,
arrows: 0,
bolts: 0,
identified: false,
basePrice: 1
},
{
glyph: ')',
baseName: 'dagger',
color: '#ccc',
damage: 3,
visualName: 'short blade',
depth: 1,
type: 'weapon',
damageType: 'piercing',
basePrice: 1
},
{
glyph: ')',
baseName: 'mace',
color: '#f94',
damage: 4,
visualName: 'club',
depth: 1,
type: 'weapon',
damageType: 'blunt',
basePrice: 1
},
{
glyph: ')',
baseName: 'sword',
color: '#aaf',
damage: 5,
visualName: 'long blade',
depth: 2,
type: 'weapon',
damageType: 'slashing',
basePrice: 1
},
{
glyph: ')',
baseName: 'spear',
color: '#cc9',
damage: 6,
visualName: 'pointed stick',
depth: 3,
type: 'weapon',
damageType: 'piercing',
basePrice: 1
},
{
glyph: ')',
baseName: 'axe',
color: '#faa',
damage: 7,
visualName: 'heavy axe',
depth: 4,
type: 'weapon',
damageType: 'slashing',
basePrice: 1
},
{
glyph: '[',
baseName: 'leather armor',
color: '#8B4513',
defense: 2,
visualName: 'hide armor',
depth: 1,
type: 'armor',
basePrice: 1
},
{
glyph: '[',
baseName: 'chain mail',
color: '#aaa',
defense: 4,
visualName: 'metal rings',
depth: 3,
type: 'armor',
basePrice: 1
},
{
glyph: '[',
baseName: 'plate mail',
color: '#ddd',
defense: 6,
visualName: 'shiny armor',
depth: 5,
type: 'armor',
basePrice: 1
},
{
glyph: '!',
baseName: 'potion of healing',
color: '#0ff',
heal: 5,
visualName: 'potion of blue liquid',
depth: 1,
type: 'potion',
basePrice: 1
},
{
glyph: '!',
baseName: 'potion of burning',
color: '#f40',
effect: 'burning',
visualName: 'potion of orange liquid',
depth: 3,
type: 'potion',
basePrice: 1.5
},
{
glyph: '!',
baseName: 'potion of strength',
color: '#f00',
effect: {
strength: 20
},
visualName: 'potion of red liquid',
depth: 2,
type: 'potion',
basePrice: 2
},
{
glyph: '!',
baseName: 'potion of confusion',
color: '#0f0',
effect: {
confusion: 15,
},
visualName: 'potion of green liquid',
depth: 3,
type: 'potion',
basePrice: 1
},
{
glyph: '!',
baseName: 'potion of extra healing',
color: '#f0f',
heal: 10,
visualName: 'potion of pink liquid',
depth: 4,
type: 'potion',
basePrice: 2
},
{
glyph: '!',
baseName: 'potion of speed',
color: '#ff0',
effect: {
speed: 10
},
visualName: 'potion of yellow liquid',
depth: 3,
type: 'potion',
basePrice: 1.5
},
{
glyph: '?',
baseName: 'scroll of identify',
color: '#ff0',
effect: 'identify',
visualName: 'unreadable scroll',
depth: 1,
type: 'scroll',
basePrice: 5
},
{
glyph: '?',
baseName: 'scroll of teleportation',
color: '#0ff',
effect: 'teleport',
visualName: 'faded scroll',
depth: 2,
type: 'scroll',
basePrice: 0.8
},
{
glyph: '?',
baseName: 'scroll of magic mapping',
color: '#f0f',
effect: 'magicMap',
visualName: 'glowing scroll',
depth: 4,
type: 'scroll',
basePrice: 0.8
},
{
glyph: '?',
baseName: 'scroll of remove curse',
color: '#fff',
effect: 'removeCurse',
visualName: 'plain scroll',
depth: 2,
type: 'scroll',
basePrice: 10
},
{
glyph: '/',
baseName: 'wand of striking',
color: '#f80',
charges: 5,
visualName: 'glass wand',
depth: 2,
type: 'wand',
effect: 'strike',
basePrice: 2
},
{
glyph: '/',
baseName: 'wand of teleportation',
color: '#a0f',
charges: 3,
visualName: 'iron wand',
depth: 4,
type: 'wand',
effect: 'teleport',
basePrice: 2
},
{
glyph: '%',
baseName: 'food ration',
color: '#c60',
effect: 'satiate',
visualName: 'food ration',
depth: 1,
type: 'food',
identified: true,
basePrice: 1
},
{
glyph: '%',
baseName: 'slime mold',
color: '#9f9',
effect: {
nutrition: 100
},
visualName: 'slime mold',
depth: 2,
type: 'food',
identified: true,
basePrice: 2
},
{
glyph: '(',
baseName: 'pick-axe',
color: '#f60',
visualName: 'heavy hammer',
depth: 3,
type: 'tool',
basePrice: 5
},
{
glyph: '$',
name: 'gold',
color: '#ff0',
value: 1,
identified: true,
depth: 1,
type: 'gold'
},
{
glyph: '(',
baseName: 'skeleton key',
color: '#ccc',
name: 'key',
identified: true,
depth: 2,
type: 'key',
basePrice: 10
},
{
glyph: '(',
baseName: 'torch',
color: '#ff6600',
name: 'torch',
identified: true,
depth: 1,
type: 'tool',
turnsRemaining: 200,
basePrice: .2,
isLit: false
},
{
glyph: '=',
baseName: 'copper ring',
color: '#0ff',
visualName: 'copper ring',
depth: 1,
type: 'ring',
name: 'copper ring',
basePrice: 1
},
{
glyph: '=',
baseName: 'silver ring',
color: '#ff0',
visualName: 'silver ring',
depth: 1,
type: 'ring',
name: 'silver ring',
basePrice: 1.5
},
{
glyph: '=',
baseName: 'ruby ring',
color: '#f00',
visualName: 'ruby ring',
depth: 1,
type: 'ring',
name: 'ruby ring',
basePrice: 2
},
{
glyph: '=',
baseName: 'ring of regeneration',
color: '#0ff',
visualName: 'copper ring',
depth: 2,
type: 'ring',
name: 'ring of regeneration',
effect: {
regenBonus: 2
},
basePrice: 3
},
{
glyph: '=',
baseName: 'ring of protection',
color: '#aaf',
visualName: 'iron ring',
depth: 3,
type: 'ring',
name: 'ring of protection',
effect: {
drBonus: 3
},
basePrice: 4
},
{
glyph: '=',
baseName: 'ring of strength',
color: '#f00',
visualName: 'ruby ring',
depth: 3,
type: 'ring',
name: 'ring',
effect: {
damageBonus: 2
},
basePrice: 4
},
{
glyph: '=',
baseName: 'ring of speed',
color: '#ff0',
visualName: 'silver ring',
depth: 4,
type: 'ring',
name: 'ring',
effect: {
apRegenBonus: 20
},
basePrice: 5
},
{
glyph: '"',
baseName: 'amulet of life saving',
color: '#ff0',
visualName: 'strange amulet',
depth: 5,
type: 'amulet',
effect: {
revive: true
},
basePrice: 10
},
{
glyph: '"',
baseName: 'amulet of reflection',
color: '#0af',
visualName: 'shiny amulet',
depth: 4,
type: 'amulet',
effect: {
reflectChance: 0.3
},
basePrice: 6
},
{
glyph: '"',
baseName: 'amulet of ESP',
color: '#a0f',
visualName: 'glowing amulet',
depth: 3,
type: 'amulet',
effect: {
telepathy: true,
telepathyRadius: 100
},
basePrice: 5
}];

const ENCHANTMENT_TYPES = {
  // Weapon enchantments
  sharpness: {
    name: 'Sharpness',
    type: 'weapon',
    damageBonus: 2,
    cost: 100,
    description: '+2 damage'
  },
  speed: {
    name: 'Speed',
    type: 'weapon',
    apReduction: 20,
    cost: 150,
    description: '-20 AP cost to attack'
  },
  vampiric: {
    name: 'Vampiric',
    type: 'weapon',
    lifesteal: 0.25,
    cost: 200,
    description: 'Heal 25% of damage dealt'
  },
  
  // Armor enchantments
  fortification: {
    name: 'Fortification',
    type: 'armor',
    drBonus: 3,
    cost: 100,
    description: '+3 DR'
  },
  reflection: {
    name: 'Reflection',
    type: 'armor',
    reflectChance: 0.15,
    cost: 150,
    description: '15% chance to reflect projectiles'
  },
  regeneration: {
    name: 'Regeneration',
    type: 'armor',
    regenBonus: 2,
    cost: 200,
    description: '+2 HP regen per turn'
  }
};
// Upgrade system using formulas

const UPGRADE_BASE_COST = 50;
const UPGRADE_COST_MULTIPLIER = 2;
const UPGRADE_BONUS_PER_LEVEL = 0.2;
const MAX_UPGRADE_LEVEL = 10;

function getUpgradeCost(currentLevel) {
  return UPGRADE_BASE_COST * Math.pow(UPGRADE_COST_MULTIPLIER, currentLevel);
}

function getUpgradeMultiplier(newLevel) {
  return 1.0 + (UPGRADE_BONUS_PER_LEVEL * newLevel);
}

const SPELL_TYPES = {
  // Wizard spells
  magicMissile: {
    name: 'Magic Missile',
    cost: 30,
    damage: [2, 8],
    range: 8,
    class: 'Wizard',
    description: 'Fire magical bolts that never miss (30 AP)'
  },
  fireball: {
    name: 'Fireball',
    cost: 60,
    damage: [3, 6],
    radius: 2,
    range: 6,
    class: 'Wizard',
    description: 'Explosive fire damage in area (60 AP)'
  },
  slow: {
    name: 'Slow',
    cost: 40,
    duration: 8,
    range: 6,
    class: 'Wizard',
    description: 'Reduce enemy AP regen by 50% (40 AP)'
  },
  identify: {
    name: 'Identify',
    cost: 20,
    class: 'Wizard',
    description: 'Identify all items in inventory (20 AP)'
  },
  
  // Barbarian abilities
  whirlwind: {
    name: 'Whirlwind',
    cost: 100,
    radius: 1,
    class: 'Barbarian',
    description: 'Attack all adjacent enemies (100 AP)'
  },
  warcry: {
    name: 'War Cry',
    cost: 70,
    duration: 10,
    radius: 5,
    class: 'Barbarian',
    description: 'Frighten nearby enemies (70 AP)'
  },
  
  // Rogue abilities
  backstab: {
    name: 'Backstab',
    cost: 80,
    damageMultiplier: 3.0,
    class: 'Rogue',
    description: 'Massive damage from stealth (80 AP)'
  },
  poisonWeapon: {
    name: 'Poison Weapon',
    cost: 50,
    duration: 5,
    class: 'Rogue',
    description: 'Your attacks poison enemies (50 AP)'
  },
  
  // Archer abilities
  multishot: {
    name: 'Multishot',
    cost: 120,
    arrows: 3,
    class: 'Archer',
    description: 'Fire 3 arrows at once (120 AP)'
  },
  piercingShot: {
    name: 'Piercing Shot',
    cost: 80,
    class: 'Archer',
    description: 'Arrow passes through enemies (80 AP)'
  }
};

function initializeSpells(player) {
  player.spells = [];
  player.spellPower = 1.0;
  
  switch (player.role) {
    case 'Wizard':
      player.spells = ['magicMissile', 'identify'];
      player.maxAP = 150;
      break;
    case 'Barbarian':
      player.spells = ['whirlwind'];
      break;
    case 'Rogue':
      player.spells = ['backstab'];
      break;
    case 'Archer':
      player.spells = ['multishot'];
      break;
  }
}


function maybeGenerateMod(depth) {
const roll = Math.random();
if (roll < 0.6) return null;

const elements = ['fire',
'ice',
'poison',
'shock'];
const element = roll > 0.85 ? elements[Math.floor(Math.random() * elements.length)]: null;

return new WeaponMod({
bonus: Math.floor(Math.random() * 3) + 1,
element,
cursed: Math.random() < 0.08,
apModifier: element ? 15: 0
});
}

const ENEMY_ITEMS = {
dart: {
glyph: '*',
name: 'dart',
color: '#aaa',
type: 'enemyAmmo',
damage: 3,
despawnOnMiss: true
},
boulder: {
glyph: 'O',
name: 'boulder',
color: '#888',
type: 'enemyAmmo',
damage: 6,
despawnOnMiss: true
}

};

const TRAP_TYPES = [{
glyph: '^',
name: 'spike trap',
color: '#f00',
damage: 5,
hidden: true
},
{
glyph: '^',
name: 'teleporter',
color: '#0ff',
teleport: true,
hidden: true
},
{
glyph: '^',
name: 'poison trap',
color: '#0f0',
poison: 3,
hidden: true
},
{
glyph: '^',
name: 'dart launcher',
color: '#aaa',
hasDart: true,
ap: 0,
apRegen: 50,
maxAP: 100
},
{
glyph: '^',
name: 'boulder launcher',
color: '#888',
hasBoulder: true,
ap: 0,
apRegen: 10,
maxAP: 100
}];

const ENVIRONMENTAL_TYPES = [
  // CONTAINERS (openable, contain loot)
  {
    glyph: '▢',
    name: 'wooden chest',
    color: '#8B4513',
    type: 'container',
    hp: 15,
    maxHp: 15,
    depth: 1,
    canOpen: true,
    isOpen: false,
    lootTable: ['weapon', 'armor', 'potion', 'gold'],
    lootCount: [2, 4],
    breakable: true,
    pushable: false
  },
  {
    glyph: '▢',
    name: 'iron chest',
    color: '#888',
    type: 'container',
    hp: 30,
    maxHp: 30,
    depth: 5,
    canOpen: true,
    isOpen: false,
    locked: true,
    lootTable: ['weapon', 'armor', 'ring', 'amulet', 'gold'],
    lootCount: [3, 6],
    breakable: true,
    pushable: false
  },
  {
    glyph: '⌸',
    name: 'barrel',
    color: '#A0522D',
    type: 'container',
    hp: 8,
    maxHp: 8,
    depth: 1,
    canOpen: true,
    isOpen: false,
    lootTable: ['food', 'potion', 'gold'],
    lootCount: [1, 2],
    breakable: true,
    pushable: true
  },
  {
    glyph: '⌁',
    name: 'bookshelf',
    color: '#654321',
    type: 'container',
    hp: 12,
    maxHp: 12,
    depth: 2,
    canOpen: true,
    isOpen: false,
    lootTable: ['scroll', 'scroll', 'scroll', 'potion'],
    lootCount: [2, 3],
    breakable: true,
    pushable: false
  },
  
  // BARRIERS (blocking, no loot)
  {
    glyph: '╬',
    name: 'wooden barrier',
    color: '#8B7355',
    type: 'barrier',
    hp: 20,
    maxHp: 20,
    depth: 1,
    canOpen: false,
    breakable: true,
    pushable: true
  },
  {
    glyph: '╬',
    name: 'iron barrier',
    color: '#A9A9A9',
    type: 'barrier',
    hp: 50,
    maxHp: 50,
    depth: 5,
    canOpen: false,
    breakable: true,
    pushable: false
  },
  
  // HAZARDS (damage on bump)
  {
    glyph: '╬',
    name: 'spiked barrier',
    color: '#DC143C',
    type: 'hazard',
    hp: 25,
    maxHp: 25,
    depth: 3,
    canOpen: false,
    breakable: true,
    pushable: false,
    bumpDamage: 3,
    damageMessage: 'You impale yourself on the spikes!'
  },
  {
    glyph: '※',
    name: 'thorny vines',
    color: '#228B22',
    type: 'hazard',
    hp: 15,
    maxHp: 15,
    depth: 2,
    canOpen: false,
    breakable: true,
    pushable: false,
    bumpDamage: 2,
    damageMessage: 'The thorns tear at your flesh!'
  },
  
  // SPECIAL (unique behaviors)
  {
    glyph: '⚗',
    name: 'explosive barrel',
    color: '#FF4500',
    type: 'explosive',
    hp: 5,
    maxHp: 5,
    depth: 4,
    canOpen: false,
    breakable: true,
    pushable: true,
    explosionRadius: 2,
    explosionDamage: [2, 6]
  }
];

const FEATURE_TYPES = [
    {
        type: 'altar',
        glyph: '_',
        color: '#fff',
        spawnChance: 0.8,  // 80% chance if rooms available
        minRooms: 3,       // Need at least 3 rooms
        unique: true,      // Only one per level
        depth: 1
    },
    {
        type: 'fountain',
        glyph: '{',
        color: '#0af',
        spawnChance: 0.8,
        minRooms: 3,
        unique: true,
        depth: 1
    },
    {
        type: 'sink',
        glyph: '≈',
        color: '#888',
        spawnChance: 0.6,
        minRooms: 4,
        unique: true,
        depth: 1,
        offset: { dx: 1, dy: 0 }  // Spawn offset from room center
    },
    {
        type: 'shop',
        glyph: '€',
        color: '#ff0',
        spawnChance: 0.7,
        minRooms: 5,
        unique: true,
        depth: 1,
        requiresInventory: true,
        shopkeeperAngry: false
    },
    {
        type: 'enchanter',
        glyph: '✦',
        color: '#0af',
        spawnChance: 0.15,
        minRooms: 4,
        unique: true,
        depth: 2
    },
    {
        type: 'door',
        glyph: '+',
        color: '#f80',
        spawnChance: 0.15,  // 15% chance per corridor tile
        unique: false,
        depth: 1,
        requiresCorridor: true,
        open: false,
        locked: false,
        discovered: false,
        lockedChance: 0.1
    }
];

const DEFAULT_INTRINSICS = {
fireResist: false,
coldResist: false,
poisonResist: false,
telepathy: false,
seeInvisible: false,
shockResist: false
};

const PLAYER_ROLES = {
Barbarian: {
hp: 30,
maxHp: 30,
ap: 100,
apRegen: 100,
maxAP: 100,
hpRegen: 2,
hpRegenCooldown: 10,
stunTurns: 0,
hitChance: 80,
canRage: true,
intrinsics: {
...DEFAULT_INTRINSICS,
coldResist: true
},
startingInventory: [{
baseName: 'axe',
identified: true
},
{
baseName: 'food ration',
identified: true
}]
},
Wizard: {
hp: 15,
maxHp: 15,
ap: 120,
apRegen: 120,
maxAP: 120,
hpRegen: 1,
hpRegenCooldown: 12,
stunTurns: 0,
hitChance: 60,
canRechargeWands: true,
intrinsics: {
...DEFAULT_INTRINSICS,
seeInvisible: true
},
startingInventory: [{
baseName: 'dagger',
identified: true
},
{
baseName: 'wand of striking',
identified: true
},
{
baseName: 'scroll of identify',
identified: true
}]
},
Rogue: {
hp: 20,
maxHp: 20,
ap: 110,
apRegen: 110,
maxAP: 110,
hpRegen: 1,
hpRegenCooldown: 10,
stunTurns: 0,
hitChance: 75,
disarmBonus: 25,
intrinsics: {
...DEFAULT_INTRINSICS
},
startingInventory: [{
baseName: 'dagger',
identified: true
},
{
baseName: 'leather armor',
identified: true
}]
},
Archer: {
hp: 25,
maxHp: 25,
ap: 105,
apRegen: 105,
maxAP: 105,
hpRegen: 1,
hpRegenCooldown: 8,
stunTurns: 0,
hitChance: 70,
canUseQuiver: true,
intrinsics: {
...DEFAULT_INTRINSICS
},
startingInventory: [{
baseName: 'shortbow',
identified: true
},
{
baseName: 'arrows',
identified: true,
count: 20
},
{
baseName: 'quiver',
identified: true
}]
}
};

function log(message, type = 'info') {
const logDiv = document.getElementById('log');
if (!logDiv) return;
const entry = document.createElement('div');
entry.className = 'log-entry ' + type;
entry.textContent = `Turn ${turn}: ${message}`;
logDiv.appendChild(entry);
while (logDiv.children.length > 120) {
logDiv.removeChild(logDiv.firstChild);
}
logDiv.scrollTop = logDiv.scrollHeight;
}

function saveGame(manual = false) {
try {
const state = {
player: {
...player,
weaponIndex: player.inventory.indexOf(player.weapon),
armorIndex: player.inventory.indexOf(player.armor),
accessoryIndex: player.inventory.indexOf(player.accessory),
ringIndex: player.inventory.indexOf(player.ring),
amuletIndex: player.inventory.indexOf(player.amulet)
},
dungeon,
monsters,
environmentals,
pets,
items,
traps,
turn,
kills,
dungeonLevel,
visible,
explored,
itemVisualToTypeMap
};

localStorage.setItem(OFFLINE_SAVE_KEY, JSON.stringify(state));
if (manual) log('Game saved.', 'pickup');
} catch (e) {
console.error(e);
log('Save failed.', 'damage');
}
}

function loadGame() {
try {
const data = localStorage.getItem(OFFLINE_SAVE_KEY);
if (!data) {
log('No save found.', 'info');
return;
}
const state = JSON.parse(data);

player = state.player;
player.inventory = player.inventory.map(saved => {
const template = ITEM_TYPES.find(t => t.baseName === saved.baseName);
return template ? {
...template, ...saved
}: saved;
});

if (player.weaponIndex >= 0) player.weapon = player.inventory[player.weaponIndex];
if (player.armorIndex >= 0) player.armor = player.inventory[player.armorIndex];
if (player.accessoryIndex >= 0) player.accessory = player.inventory[player.accessoryIndex];
if (player.ringIndex >= 0) player.ring = player.inventory[player.ringIndex];
if (player.amuletIndex >= 0) player.amulet = player.inventory[player.amuletIndex];

dungeon = state.dungeon;
monsters = state.monsters.map(m => ({
...m
}));
pets = state.pets;
items = state.items;
traps = state.traps;
environmentals = state.environmentals || [];
turn = state.turn;
kills = state.kills;
dungeonLevel = state.dungeonLevel;
visible = state.visible;
explored = state.explored;
itemVisualToTypeMap = state.itemVisualToTypeMap;

computeFOV(player.x, player.y, getVisionRadius());
updateStats();
updateClassSkillButton();
needsRedraw = true;
log('Game loaded.', 'pickup');
} catch (e) {
console.error(e);
log('Load failed.', 'damage');
}
}

function updateActivateButton() {
  const btn = document.getElementById('activate-btn');
  if (!btn) return;

  // Always reset button visual state first
  btn.classList.remove('action-mode');

  if (player.isLooking) {
    btn.classList.add('action-mode');
    switch (currentActionContext?.action) {
      case 'look-throw': btn.textContent = '🎯 THROW!'; break;
      case 'look-shoot': btn.textContent = '🏹 FIRE!'; break;
      case 'look-zap': btn.textContent = '⚡ ZAP!'; break;
      default: btn.textContent = '🔍 LOOK'; break;
    }
    return;
  }

  // Check for adjacent container
  const adjacentContainer = environmentals.find(e =>
    Math.abs(e.x - player.x) <= 1 &&
    Math.abs(e.y - player.y) <= 1 &&
    e.canOpen &&
    !e.isOpen
  );

  if (adjacentContainer) {
    btn.textContent = `🔓 Open ${adjacentContainer.name}`;
  } else if (isStairsAt(player.x, player.y)) {
    btn.textContent = '⬇️ Descend';
  } else {
    btn.textContent = '🔍 Search';
  }
}

function handleLookThrowAction() {
const throwableItems = player.inventory.filter(i =>
i.type === 'potion' || i.type === 'weapon' || i.type === 'scroll'
);

if (throwableItems.length === 0) {
log('You have nothing to throw!', 'damage');
return;
}

showThrowSelectionUI(throwableItems);
}

function updateStatusGrid() {
const grid = document.getElementById('status-grid');
if (!grid) return;

const statuses = [];
if (player.telepathy === true || player.telepathyTurns > 0) {
statuses.push({
icon: '🔮',
label: 'TEL',
color: '#0ff',
turns: player.telepathyTurns > 0 ? player.telepathyTurns: undefined
});
}
if (player.sneakTurns > 0) statuses.push({
icon: '🗡️',
label: 'SNEAK',
turns: player.sneakTurns,
color: '#0ff'
});
if (player.poisonTurns > 0) statuses.push({
icon: '☠️', label: 'PSN', turns: player.poisonTurns, color: '#0f0'
});
if (player.confusionTurns > 0) statuses.push({
icon: '😵', label: 'CNF', turns: player.confusionTurns, color: '#ff0'
});
if (player.rageTurns > 0) statuses.push({
icon: '💢', label: 'RAGE', turns: player.rageTurns, color: '#f00'
});
if (player.exhaustedTurns > 0) statuses.push({
icon: '😓', label: 'EXHAUST', turns: player.exhaustedTurns, color: '#888'
});
if (player.strengthTurns > 0) statuses.push({
icon: '💪', label: 'STR', turns: player.strengthTurns, color: '#f00'
});
if (player.speedTurns > 0) statuses.push({
icon: '⚡', label: 'SPD', turns: player.speedTurns, color: '#ff0'
});
if (player.paralyzedTurns > 0) statuses.push({
icon: '🥶', label: 'PAR', turns: player.paralyzedTurns, color: '#0af'
});
if (player.hp <= player.maxHp * 0.3) statuses.push({
icon: '❤️', label: 'LOW HP', color: '#f00'
});
if (player.hunger <= 200) statuses.push({
icon: '🍖', label: 'STARV', color: '#f00'
});
else if (player.hunger <= 500) statuses.push({
icon: '🍖', label: 'HGR', color: '#ff0'
});

if (statuses.length < 9) {
statuses.push({
icon: '🗡️', label: ' kills', value: kills, color: '#0af'
});
statuses.push({
icon: '⏱️', label: 'Turn', value: turn, color: '#0af'
});
const xpNeeded = LEVEL_XP_REQUIREMENTS[player.level] || '---';
statuses.push({
icon: '⭐', label: 'Next', value: xpNeeded - player.xp, color: '#0af'
});
}

grid.innerHTML = '';
const cellsToShow = Math.min(9, statuses.length);

for (let i = 0; i < cellsToShow; i++) {
const s = statuses[i];
const box = document.createElement('div');
box.style.cssText = `padding: 6px 4px; background: #002200; border: 2px solid ${s.color}; border-radius: 4px; text-align: center; font-size: 10px; color: ${s.color}; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 50px;`;

const displayValue = s.turns ? s.turns: (s.value !== undefined ? s.value: '');
box.innerHTML = `<div style="font-size: 20px; line-height: 1;">${s.icon}</div><div style="margin-top: 2px;">${s.label}</div>${displayValue ? `<div style="font-weight: bold;">${displayValue}</div>`: ''}`;
grid.appendChild(box);
}

if (cellsToShow === 0) {
grid.style.display = 'none';
} else {
grid.style.display = 'grid';
}
}

function autosave() {
if (turn - lastAutosaveTurn >= 20) {
saveGame(false);
lastAutosaveTurn = turn;
}
}

function createPlayer(role) {
  const baseRole = PLAYER_ROLES[role];
  player = {
    x: 0,
    y: 0,
    glyph: '@',
    color: '#fff',
    name: 'You',
    role: role,
    level: 1,
    xp: 0,
    ...baseRole,
    gold: 0,
    score: 0,
    inventory: [],
    inventoryMaxItems: 26,
    autoRange: false,
    telepathy: false,
    telepathyTurns: 0,
    telepathyRadius: 0,
    poisonTurns: 0,
    strengthTurns: 0,
    confusionTurns: 0,
    speedTurns: 0,
    paralyzedTurns: 0,
    baseDodgeChance: 5,
    isLooking: false,
    lookCursor: { x: 0, y: 0 },
    ap: baseRole.maxAP,
    hunger: 1000,
    maxHunger: 2000,
    weapon: null,
    armor: null,
    hpRegen: 0,
    hpRegenCooldown: 0,
    rageTurns: 0,
    exhaustedTurns: 0,
    accessory: null,
    quiver: { arrows: 0, bolts: 0, capacity: 0 },
    rangedWeapon: null,
    ring: null,
    amulet: null,
    hasUsedRevive: false,
    spells: [],
    spellPower: 1.0,
    poisonedWeaponTurns: 0
  };

  initializeSpells(player);

  baseRole.startingInventory.forEach(itemInfo => {
    const itemType = ITEM_TYPES.find(i => i.baseName === itemInfo.baseName);
    if (itemType) {
      let newItem = {
        ...itemType,
        ...itemInfo,
        name: itemType.baseName || itemType.name,
        identified: true,
        upgradeLevel: 0,
        enchantment: null
      };

      if (itemType.type === 'weapon') {
        const mod = maybeGenerateMod(dungeonLevel);
        if (mod) newItem = mod.applyTo(newItem);
      }

      player.inventory.push(newItem);
    }
  });

  player.inventory.forEach(item => {
    if (item.type === 'weapon' && !player.weapon) {
      item.equipped = true;
      player.weapon = item;
    }
    if (item.type === 'armor' && !player.armor) {
      item.equipped = true;
      player.armor = item;
    }
    if (item.type === 'ranged_weapon' && !player.rangedWeapon) {
      item.equipped = true;
      player.rangedWeapon = item;
    }
    if (item.baseName === 'quiver' && !player.accessory) {
      item.equipped = true;
      player.accessory = item;
      log('You ready your quiver.', 'info');
      autoRefillQuiver();
    }
  });
  
  updateClassSkillButton();
}

function rollDice(num, sides, modifier = 0) {
let result = modifier;
for (let i = 0; i < num; i++) result += Math.floor(Math.random() * sides) + 1;
return Math.max(1, result);
}

function traceLine(x0, y0, dx, dy, maxRange = 10) {
const line = [];
let x = x0;
let y = y0;

for (let step = 0; step < maxRange; step++) {
x += dx;
y += dy;

if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT) break;

line.push({
x, y
});

const tile = dungeon.tiles[y][x];
if (tile === '#' || tile === '+') break;
}

return line;
}

function gainXp(amount) {
player.xp += amount;
log(`You gain ${amount} experience points.`, 'info');
updateScore(amount);
checkLevelUp();
}

function checkLevelUp() {
let leveledUp = false;
while (player.level < LEVEL_XP_REQUIREMENTS.length && player.xp >= LEVEL_XP_REQUIREMENTS[player.level]) {
player.level++;
leveledUp = true;

let hpGain = player.role === 'Barbarian' ? rollDice(1, 8, 2): (player.role === 'Wizard' ? rollDice(1, 4, 1): rollDice(1, 6, 1));
player.maxHp += hpGain;
player.hp = player.maxHp;
player.apRegen += 5;
player.maxAP += 10;
player.ap = player.maxAP;
player.hitChance += 1;

log(`You reached level ${player.level}! Max HP increased by ${hpGain}.`, 'pickup');
}
if (leveledUp) updateStats();
}

function computeFOV(x, y, radius) {
visible = Array(HEIGHT).fill().map(() => Array(WIDTH).fill(false));
espVisible = Array(HEIGHT).fill().map(() => Array(WIDTH).fill(false));

visible[y][x] = true;
explored[y][x] = true;

for (let octant = 0; octant < 8; octant++) {
castLight(x, y, 1, 1.0, 0.0, radius, octant);
}

if (player.intrinsics.telepathy) {
monsters.forEach(m => {
if (telepathy(m)) {
if (!visible[m.y][m.x]) {
espVisible[m.y][m.x] = true;
explored[m.y][m.x] = true;
}
}
});
}

needsRedraw = true;
}

function getVisionRadius() {
if (!player || !player.inventory) return 8;

let radius = 8;

if (player.role === 'Wizard') radius += 2;

if (dungeon.isDarkLevel) radius -= 3;

const torch = player.inventory.find(i =>
i.baseName === 'torch' &&
i.equipped &&
i.isLit &&
i.turnsRemaining > 0
);

if (torch) radius += 4;

if (player.blindTurns > 0) radius = 0;

return Math.max(1, radius);
}

function telepathy(monster) {
if (!player.intrinsics.telepathy) return false;
const dist = Math.hypot(monster.x - player.x, monster.y - player.y);
return dist <= player.telepathyRadius && !visible[monster.y][monster.x];
}

function getTelepathyColor(monster) {
if (!monster || !monster.state) return '#a0f';
switch (monster.state) {
case 'chasing': return '#f55';
case 'fleeing': return '#55f';
case 'wandering': return '#a0f';
case 'sleeping': return '#888';
default: return '#a0f';
}
}

function castLight(cx, cy, row, start, end, radius, octant) {
if (start < end) return;
for (let j = row; j <= radius; j++) {
let blocked = false;
let newStart = 0;
for (let dx = -j; dx <= 0; dx++) {
let dy = -j;
let [X,
Y] = transform(cx, cy, dx, dy, octant);
if (X < 0 || X >= WIDTH || Y < 0 || Y >= HEIGHT) continue;
let lSlope = (dx - 0.5) / (dy + 0.5);
let rSlope = (dx + 0.5) / (dy - 0.5);
if (start < rSlope || end > lSlope) continue;
if (dx * dx + dy * dy <= radius * radius) {
visible[Y][X] = true;
explored[Y][X] = true;
}
const isWall = dungeon.tiles[Y][X] === '#' || dungeon.tiles[Y][X] === '+';
if (blocked) {
if (isWall) {
newStart = rSlope;
continue;
}
blocked = false;
start = newStart;
} else if (isWall && j < radius) {
blocked = true;
castLight(cx, cy, j + 1, start, lSlope, radius, octant);
newStart = rSlope;
}
}
if (blocked) break;
}
}

function transform(cx, cy, dx, dy, octant) {
switch (octant) {
case 0: return [cx + dx,
cy - dy];
case 1: return [cx + dy,
cy - dx];
case 2: return [cx - dy,
cy - dx];
case 3: return [cx - dx,
cy - dy];
case 4: return [cx - dx,
cy + dy];
case 5: return [cx - dy,
cy + dx];
case 6: return [cx + dy,
cy + dx];
case 7: return [cx + dx,
cy + dy];
}
}

function getCameraOffset(focusX, focusY) {
const viewWidth = getViewWidth();
const viewHeight = getViewHeight();

let offsetX = Math.max(0, Math.min(focusX - Math.floor(viewWidth / 2), WIDTH - viewWidth));
let offsetY = Math.max(0, Math.min(focusY - Math.floor(viewHeight / 2), HEIGHT - viewHeight));
return {
offsetX,
offsetY
};
}

function isWalkable(x, y) {
  if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT) return false;
  const tile = dungeon.tiles[y][x];
  
  const environmental = getEnvironmentalAt(x, y);
  if (environmental) {
    if (environmental.type === 'container' && environmental.isOpen) {
      return tile === '.' || tile === '\'' || tile === '>' || tile === '_' || tile === '{' || tile === '≈';
    }
    return false;
  }
  
  return tile === '.' || tile === '\'' || tile === '>' || tile === '_' || tile === '{' || tile === '≈';
}

function shuffleArray(array) {
for (let i = array.length - 1; i > 0; i--) {
const j = Math.floor(Math.random() * (i + 1));
[array[i],
array[j]] = [array[j],
array[i]];
}
}

function randomizeItemNames() {
itemVisualToTypeMap = {};
const typesToRandomize = ['potion',
'scroll',
'wand',
'tool'];
typesToRandomize.forEach(type => {
const itemSubtypes = ITEM_TYPES.filter(i => i.type === type && i.visualName);
const baseNames = itemSubtypes.map(p => p.baseName);
const visualNames = itemSubtypes.map(p => p.visualName);
shuffleArray(baseNames);
for (let i = 0; i < itemSubtypes.length; i++) itemVisualToTypeMap[visualNames[i]] = baseNames[i];
});
ITEM_TYPES.forEach(itemType => {
if (itemType.visualName) itemType.identified = false;
});
log('Item appearances have been shuffled for this run!',
'info');
}

function generateDungeon(w, h) {
    // Select dungeon type based on current stairs status or weighted random
    let selectedType;
    
    const stairsItem = items.find(i => i.isStairs);
    if (stairsItem) {
      if (stairsItem.status === 'Blessed') {
        // Blessed stairs lead to beneficial dungeons
        const beneficialTypes = DUNGEON_TYPES.filter(t => 
          t.type === 'treasure' || t.type === 'cathedral' || t.type === 'normal'
        );
        selectedType = beneficialTypes[Math.floor(Math.random() * beneficialTypes.length)];
        log('The blessed stairs shimmer with promise...', 'pickup');
      } else if (stairsItem.status === 'Cursed') {
        // Cursed stairs lead to dangerous dungeons
        const dangerousTypes = DUNGEON_TYPES.filter(t => 
          t.type === 'crypt' || t.type === 'inferno' || t.type === 'maze'
        );
        selectedType = dangerousTypes[Math.floor(Math.random() * dangerousTypes.length)];
        log('The cursed stairs fill you with dread...', 'damage');
      } else {
        // Normal stairs use weighted random
        selectedType = selectWeightedDungeonType();
      }
    } else {
      // First level or no stairs
      selectedType = DUNGEON_TYPES[0]; // Normal
    }
    
    currentDungeonType = selectedType;
    
    let tiles = Array(h).fill().map(() => Array(w).fill('#'));
    let rooms = [];
    let features = [];
    let engravings = [];
    
    // Apply dungeon type modifiers
    const mods = selectedType.modifiers;
    dungeon.isDarkLevel = Math.random() < (mods.darkChance || 0.3);
    
    if (dungeon.isDarkLevel) log('It is very dark here...', 'damage');
    log(`You enter ${selectedType.name}. ${selectedType.description}`, 'info');
    
    // Generate rooms with type-specific modifications
    const roomCount = mods.roomCount || 20;
    const minRoomSize = mods.largeRooms ? 7 : 5;
    const maxRoomSize = mods.largeRooms ? 12 : (minRoomSize + 5);
    
    for (let i = 0; i < roomCount; i++) {
        let rw = Math.floor(Math.random() * (maxRoomSize - minRoomSize)) + minRoomSize;
        let rh = Math.floor(Math.random() * 4) + 4;
        let rx = Math.floor(Math.random() * (w - rw - 2)) + 1;
        let ry = Math.floor(Math.random() * (h - rh - 2)) + 1;
        let overlap = rooms.some(r => rx < r.x + r.w + 1 && rx + rw + 1 > r.x && ry < r.y + r.h + 1 && ry + rh + 1 > r.y);
        if (!overlap) {
            for (let y = ry; y < ry + rh; y++) 
                for (let x = rx; x < rx + rw; x++) 
                    tiles[y][x] = '.';
            rooms.push({
                x: rx, y: ry, w: rw, h: rh, 
                cx: Math.floor(rx + rw/2), cy: Math.floor(ry + rh/2)
            });
        }
    }

    // Generate vault with type-specific behavior
    if (Math.random() < 0.15 || mods.guaranteedVault) {
        generateVault(tiles, rooms);
    }

    // Connect rooms with corridors
    rooms.sort((a, b) => a.x - b.x);
    for (let i = 0; i < rooms.length - 1; i++) {
        let x1 = rooms[i].cx, y1 = rooms[i].cy;
        let x2 = rooms[i+1].cx, y2 = rooms[i+1].cy;
        let hx = x1, hy = y1;
        while (hx !== x2 || hy !== y2) {
            if (Math.abs(x2 - hx) > Math.abs(y2 - hy) && hx !== x2) 
                hx += Math.sign(x2 - hx);
            else if (hy !== y2) 
                hy += Math.sign(y2 - hy);
            
            if (tiles[hy]?.[hx] === '#') {
                const doorType = FEATURE_TYPES.find(f => f.type === 'door');
                const isAdjacentToRoom = tiles[hy-1]?.[hx] === '.' || tiles[hy+1]?.[hx] === '.' || 
                                         tiles[hy][hx-1] === '.' || tiles[hy][hx+1] === '.';
                
                if (doorType && isAdjacentToRoom && Math.random() < doorType.spawnChance) {
                    tiles[hy][hx] = doorType.glyph;
                    features.push({
                        x: hx, y: hy, type: doorType.type,
                        glyph: doorType.glyph, color: doorType.color,
                        open: false,
                        locked: Math.random() < (doorType.lockedChance || 0.1),
                        discovered: false
                    });
                } else {
                    tiles[hy][hx] = '.';
                }
            }
        }
    }

    // Spawn type-specific hazards
    if (mods.fireHazards) {
        spawnFireHazards(tiles, rooms, features);
    }
    
    if (mods.waterFeatures) {
        spawnWaterFeatures(tiles, rooms, features);
    }
    
    if (mods.gasHazards) {
        spawnGasHazards(tiles, rooms, features);
    }
    
    // Guarantee altar in cathedral
    if (mods.guaranteedAltar) {
        const altarType = FEATURE_TYPES.find(f => f.type === 'altar');
        if (altarType && rooms.length > 0) {
            const room = rooms[Math.floor(rooms.length / 2)];
            features.push({
                x: room.cx,
                y: room.cy,
                type: 'altar',
                glyph: altarType.glyph,
                color: altarType.color
            });
            tiles[room.cy][room.cx] = altarType.glyph;
        }
    }

    spawnDungeonFeatures(tiles, rooms, features);

    dungeon.rooms = rooms;
    dungeon.features = features;
    dungeon.engravings = engravings;
    dungeon.type = selectedType;
    
    return { tiles, width: w, height: h, rooms, features, engravings };
}

function selectWeightedDungeonType() {
    const totalWeight = DUNGEON_TYPES.reduce((sum, t) => sum + t.weight, 0);
    let random = Math.random() * totalWeight;
    
    for (const type of DUNGEON_TYPES) {
        random -= type.weight;
        if (random <= 0) return type;
    }
    
    return DUNGEON_TYPES[0]; // Fallback to normal
}

// Helper functions for hazard spawning
function spawnFireHazards(tiles, rooms, features) {
    const hazardCount = Math.floor(rooms.length * 0.3);
    for (let i = 0; i < hazardCount; i++) {
        const room = rooms[Math.floor(Math.random() * rooms.length)];
        const x = room.x + Math.floor(Math.random() * room.w);
        const y = room.y + Math.floor(Math.random() * room.h);
        
        if (tiles[y][x] === '.') {
            features.push({
                x, y,
                type: 'fire',
                glyph: '}',
                color: '#f80',
                damage: 2,
                spreadChance: 0.05,
                duration: rollDice(2, 6, 5)
            });
            tiles[y][x] = '}';
        }
    }
}

function spawnWaterFeatures(tiles, rooms, features) {
    rooms.forEach(room => {
        if (Math.random() < 0.4) {
            const fountainType = FEATURE_TYPES.find(f => f.type === 'fountain');
            if (fountainType) {
                features.push({
                    x: room.cx,
                    y: room.cy,
                    type: 'fountain',
                    glyph: fountainType.glyph,
                    color: fountainType.color
                });
                tiles[room.cy][room.cx] = fountainType.glyph;
            }
        }
    });
}

function spawnGasHazards(tiles, rooms, features) {
    const hazardCount = Math.floor(rooms.length * 0.25);
    for (let i = 0; i < hazardCount; i++) {
        const room = rooms[Math.floor(Math.random() * rooms.length)];
        const x = room.x + Math.floor(Math.random() * room.w);
        const y = room.y + Math.floor(Math.random() * room.h);
        
        if (tiles[y][x] === '.') {
            features.push({
                x, y,
                type: 'gas',
                glyph: '~',
                color: '#9c6',
                toxicity: 1,
                spreadChance: 0.15,
                duration: rollDice(2, 4, 3),
                flammable: true
            });
        }
    }
}

function spawnDungeonFeatures(tiles, rooms, features) {
    // Filter features that can spawn on this level
    const validFeatures = FEATURE_TYPES.filter(f => 
        f.depth <= dungeonLevel && 
        rooms.length >= (f.minRooms || 0)
    );

    // Track which unique features have been spawned
    const spawnedUnique = new Set();

    validFeatures.forEach(featureType => {
        // Skip if unique and already spawned
        if (featureType.unique && spawnedUnique.has(featureType.type)) return;
        
        // Check spawn chance
        if (Math.random() > (featureType.spawnChance || 1.0)) return;

        // Skip corridor-only features (handled in corridor generation)
        if (featureType.requiresCorridor) return;

        // Find available room
        const usedRooms = features.filter(f => f.roomIndex !== undefined).map(f => f.roomIndex);
        const availableRooms = rooms.filter((r, i) => !usedRooms.includes(i) && !r.isVault);
        
        if (availableRooms.length === 0) return;

        const room = availableRooms[Math.floor(Math.random() * availableRooms.length)];
        const roomIndex = rooms.indexOf(room);

        // Calculate spawn position
        let spawnX = room.cx;
        let spawnY = room.cy;
        
        if (featureType.offset) {
            spawnX += featureType.offset.dx || 0;
            spawnY += featureType.offset.dy || 0;
        }

        // Validate position
        if (spawnX < 0 || spawnX >= tiles[0].length || spawnY < 0 || spawnY >= tiles.length) return;
        if (tiles[spawnY][spawnX] !== '.') return;

        // Create feature
        const newFeature = {
            x: spawnX,
            y: spawnY,
            type: featureType.type,
            glyph: featureType.glyph,
            color: featureType.color,
            roomIndex: roomIndex
        };

        // Add type-specific properties
        if (featureType.type === 'shop' && featureType.requiresInventory) {
            newFeature.inventory = generateShopInventory();
            newFeature.shopkeeperAngry = false;
        }
        
        if (featureType.type === 'enchanter') {
            log('You sense powerful magic on this level...', 'info');
        }

        if (featureType.type === 'door') {
            newFeature.open = featureType.open;
            newFeature.locked = featureType.locked;
            newFeature.discovered = featureType.discovered;
        }

        // Add to features and update tiles
        features.push(newFeature);
        tiles[spawnY][spawnX] = featureType.glyph;

        // Mark unique as spawned
        if (featureType.unique) {
            spawnedUnique.add(featureType.type);
        }
    });
}

function generateShopInventory() {
    const inventory = [];
    const itemCount = 5 + Math.floor(Math.random() * 4);

    for (let i = 0; i < itemCount; i++) {
        const validItems = ITEM_TYPES.filter(it =>
            !it.isStairs && 
            it.depth <= dungeonLevel + 1 && 
            it.type !== 'gold'
        );
        const itemType = validItems[Math.floor(Math.random() * validItems.length)];
        
        inventory.push({
            ...itemType,
            name: itemType.baseName || itemType.name,
            identified: true,
            status: Math.random() < 0.1 ? 'Cursed' : (Math.random() < 0.2 ? 'Blessed' : 'Normal'),
            quantity: itemType.stackable ? Math.floor(Math.random() * 5) + 1 : 1
        });
    }
    
    return inventory;
}

function generateTestLevel() {
const testFeatures = [{
type: 'fountain',
dx: -2,
dy: 0,
glyph: '{',
color: '#0af'
},
{
type: 'sink',
dx: 0,
dy: 0,
glyph: '≈',
color: '#888'
},
{
type: 'altar',
dx: 2,
dy: 0,
glyph: '_',
color: '#fff'
}];

const radius = 2;

for (let dy = -radius; dy <= radius; dy++) {
for (let dx = -radius; dx <= radius; dx++) {
const x = player.x + dx;
const y = player.y + dy;

if (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT) {
dungeon.tiles[y][x] = '.';
}
}
}

dungeon.features = dungeon.features.filter(f => {
const inTestArea = Math.abs(f.x - player.x) <= radius &&
Math.abs(f.y - player.y) <= radius;
return !inTestArea;
});

testFeatures.forEach(feature => {
const x = player.x + feature.dx;
const y = player.y + feature.dy;

if (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT) {
dungeon.tiles[y][x] = feature.glyph;

dungeon.features.push({
x: x,
y: y,
type: feature.type,
glyph: feature.glyph,
color: feature.color
});
}
});

log('Test level generated with fountain, sink, and altar.',
'info');
computeFOV(player.x,
player.y,
getVisionRadius());
needsRedraw = true;
}

function generateVault(tiles, rooms) {
let w = tiles[0].length, h = tiles.length;
let rw = Math.floor(Math.random() * 4) + 4;
let rh = Math.floor(Math.random() * 4) + 4;
let rx = Math.floor(Math.random() * (w - rw - 2)) + 1;
let ry = Math.floor(Math.random() * (h - rh - 2)) + 1;
let overlap = rooms.some(r => rx < r.x + r.w + 1 && rx + rw + 1 > r.x && ry < r.y + r.h + 1 && ry + rh + 1 > r.y);
if (!overlap) {
for (let y = ry; y < ry + rh; y++) for (let x = rx; x < rx + rw; x++) tiles[y][x] = '.';
const vaultRoom = {
x: rx,
y: ry,
w: rw,
h: rh,
cx: Math.floor(rx + rw/2),
cy: Math.floor(ry + rh/2),
isVault: true
};
rooms.push(vaultRoom);
log("You feel a sense of hidden treasure on this level.", "info");
}
}

function findWalkable(room = null) {
for (let i = 0; i < 200; i++) {
let x,
y;
if (room) {
x = room.x + Math.floor(Math.random() * room.w);
y = room.y + Math.floor(Math.random() * room.h);
} else {
x = Math.floor(Math.random() * (WIDTH - 2)) + 1;
y = Math.floor(Math.random() * (HEIGHT - 2)) + 1;
}
if (isWalkable(x, y) && !(x === player?.x && y === player?.y) && !monsters.some(m => m.x === x && m.y === y) && !items.some(i => i.x === x && i.y === y)) {
return {
x,
y
};
}
}
return {
x: Math.min(WIDTH - 2, player?.x + 1 || 1),
y: player?.y || 1
};
}

function findWalkableAdjacent(px, py) {
const adjacencies = [];
for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) {
if (dx === 0 && dy === 0) continue;
let x = px + dx; let y = py + dy;
if (isWalkable(x, y) && !monsters.some(m => m.x === x && m.y === y) && !(player.x === x && player.y === y)) adjacencies.push({
x, y
});
}
return adjacencies.length > 0 ? adjacencies[Math.floor(Math.random() * adjacencies.length)]: null;
}

function spawnMonsters(count) {
    const mods = currentDungeonType?.modifiers || { monsterSpawnMult: 1.0 };
    const adjustedCount = Math.floor(count * mods.monsterSpawnMult);
    
    let spawnPool = MONSTER_TYPES.filter(type => type.depth <= dungeonLevel + 1);
    
    // Force certain monster types if specified
    if (mods.forceMonsterTypes && mods.forceMonsterTypes.length > 0) {
        const forcedTypes = MONSTER_TYPES.filter(t => 
            mods.forceMonsterTypes.includes(t.name) && t.depth <= dungeonLevel + 2
        );
        
        // 60% forced types, 40% normal types
        spawnPool = [
            ...forcedTypes,
            ...forcedTypes,
            ...forcedTypes,
            ...spawnPool.filter(t => !mods.forceMonsterTypes.includes(t.name))
        ];
    }
    
const vault = dungeon.rooms.find(r => r.isVault);
if (vault) {
let candidates = MONSTER_TYPES.filter(t => t.depth >= dungeonLevel && t.depth <= dungeonLevel + 2);
let guardianType = candidates[candidates.length - 1] || MONSTER_TYPES[MONSTER_TYPES.length - 1];
let pos = findWalkable(vault);

monsters.push({
...guardianType,
x: pos.x,
y: pos.y,
maxHp: guardianType.hp,
hp: guardianType.hp,
ap: 0,
maxAP: guardianType.maxAP || 100,
state: 'guarding',
guardX: pos.x,
guardY: pos.y,
weapon: null,
exhaustedTurns: 0,
poisonTurns: 0,
confusionTurns: 0,
speedTurns: 0,
strengthTurns: 0,
burnTurns: 0,
paralyzedTurns: 0,
lastKnownPlayerX: null,
lastKnownPlayerY: null,
intrinsics: guardianType.intrinsics ? {
...guardianType.intrinsics
}: {}
});
}

for (let i = 0; i < count; i++) {
if (spawnPool.length === 0) break;
let type = spawnPool[Math.floor(Math.random() * spawnPool.length)];
let room = dungeon.rooms[Math.floor(Math.random() * dungeon.rooms.length)];
if (!room || room.isVault) continue;
let pos = findWalkable(room);

const initialState = (type.behavior === 'ambusher' || Math.random() < 0.3) ? 'sleeping': 'wandering';

monsters.push({
...type,
x: pos.x,
y: pos.y,
maxHp: type.hp,
hp: type.hp,
ap: type.ap || 0,
maxAP: type.maxAP || 100,
state: initialState,
weapon: null,
exhaustedTurns: 0,
poisonTurns: 0,
confusionTurns: 0,
speedTurns: 0,
strengthTurns: 0,
burnTurns: 0,
paralyzedTurns: 0,
lastKnownPlayerX: null,
lastKnownPlayerY: null,
intrinsics: type.intrinsics ? {
...type.intrinsics
}: {}
});
}
}


function handleSpecialBehavior(monster, canSeePlayer, distToPlayer) {
// ERRATIC MOVEMENT
if (monster.behavior === 'erratic' && Math.random() < 0.5) {
const dx = Math.floor(Math.random() * 3) - 1;
const dy = Math.floor(Math.random() * 3) - 1;
let moveX = monster.x + dx;
let moveY = monster.y + dy;
if (isWalkable(moveX, moveY) &&
!monsters.some(m => m.x === moveX && m.y === moveY) &&
!(player.x === moveX && player.y === moveY)) {
monster.x = moveX;
monster.y = moveY;
monster.ap -= monster.apRegen;
}
}

// DIVIDER
if (monster.behavior === 'divider' && monster.hp < monster.maxHp && Math.random() < 0.025) {
const pos = findWalkableAdjacent(monster.x, monster.y);
if (pos) {
log(`${monster.name} divides!`, 'damage');
const newSlime = {
...monster,
x: pos.x,
y: pos.y,
hp: Math.ceil(monster.hp / 2),
maxHp: monster.maxHp,
ap: 0,
intrinsics: monster.intrinsics ? {
...monster.intrinsics
}: {}
};
monster.hp = Math.ceil(monster.hp / 2);
monsters.push(newSlime);
}
}

// EQUIPPER
if (monster.behavior === 'equipper' && !monster.weapon) {
const weaponOnGround = items.find(i =>
i.x === monster.x && i.y === monster.y && i.type === 'weapon' && !i.isStairs
);
if (weaponOnGround) {
monster.weapon = weaponOnGround;
items = items.filter(i => i !== weaponOnGround);
log(`${monster.name} picks up and wields a ${weaponOnGround.name}!`, 'damage');
}
}

// THIEF
if (monster.behavior === 'thief' && distToPlayer < 1.5 && Math.random() < 0.3) {
const stealableItem = player.inventory.find(i => !i.equipped && i.type !== 'gold');
if (stealableItem) {
player.inventory = player.inventory.filter(i => i !== stealableItem);
log(`${monster.name} steals your ${getItemDisplayName(stealableItem)}!`, 'damage');
monster.state = 'fleeing';
monster.ap -= monster.apRegen;
return;
}
}

// TELEPORTER
if (monster.behavior === 'teleporter' && canSeePlayer && distToPlayer < 3 && Math.random() < 0.1) {
if (Math.random() < 0.5) {
teleportPlayer();
log(`${monster.name} teleports you!`, 'damage');
} else {
teleportMonster(monster);
}
monster.ap -= monster.apRegen * 2;
}

// EXPLODER
if (monster.behavior === 'exploder' && distToPlayer < 2 && monster.hp < monster.maxHp * 0.5) {
log(`${monster.name} explodes!`, 'damage');
takeDamage(rollDice(2, 6));
monsters = monsters.filter(m => m !== monster);
return;
}

// POISONER
if (monster.behavior === 'poisoner' && distToPlayer < 1.5 && Math.random() < 0.3) {
player.poisonTurns += 3;
log(`${monster.name}'s bite poisons you!`, 'damage');
}

// DRAINER
if (monster.behavior === 'drainer' && distToPlayer < 1.5 && Math.random() < 0.2) {
const drainAmount = rollDice(1, 4);
player.maxHp = Math.max(10, player.maxHp - drainAmount);
player.hp = Math.min(player.hp, player.maxHp);
log(`${monster.name} drains your life force! (-${drainAmount} max HP)`, 'damage');
updateStats();
}

// CORRODER
if (monster.behavior === 'corroder' && distToPlayer < 1.5 && Math.random() < 0.4) {
if (player.weapon && player.weapon.damage > 1) {
player.weapon.damage = Math.max(1, player.weapon.damage - 1);
log(`${monster.name} corrodes your ${getItemDisplayName(player.weapon)}!`, 'damage');
updateStats();
} else if (player.armor && player.armor.defense > 0) {
player.armor.defense = Math.max(0, player.armor.defense - 1);
log(`${monster.name} corrodes your ${getItemDisplayName(player.armor)}!`, 'damage');
updateStats();
}
}

// PETRIFIER
if (monster.behavior === 'petrifier' && distToPlayer < 1.5 && Math.random() < 0.15) {
log(`${monster.name}'s gaze begins to petrify you!`, 'damage');
player.paralyzedTurns += 2;
takeDamage(rollDice(1, 6));
}

// SPORE
if (monster.behavior === 'spore' && distToPlayer < 3 && Math.random() < 0.05) {
log(`${monster.name} releases toxic spores!`, 'damage');
dungeon.features.push({
x: monster.x,
y: monster.y,
type: 'gas',
glyph: '~',
color: '#9c6',
spreadChance: 0.2,
toxicity: 1,
duration: rollDice(1, 4, 3),
flammable: true
});
if (distToPlayer < 2) {
takeDamage(rollDice(1, 3));
player.poisonTurns += 2;
}
needsRedraw = true;
}

// SWARM
if (monster.behavior === 'swarm') {
const nearbyAnts = monsters.filter(m =>
m.behavior === 'swarm' && m !== monster &&
Math.hypot(m.x - monster.x, m.y - monster.y) < 3
);
monster.swarmBonus = nearbyAnts.length;

if (canSeePlayer && nearbyAnts.length < 4 && Math.random() < 0.02) {
const pos = findWalkableAdjacent(monster.x, monster.y);
if (pos) {
const antType = MONSTER_TYPES.find(t => t.name === 'giant ant');
if (antType) {
monsters.push({
...antType,
x: pos.x,
y: pos.y,
maxHp: antType.hp,
hp: antType.hp,
ap: 0,
maxAP: antType.maxAP || 100,
state: 'chasing',
weapon: null,
exhaustedTurns: 0,
poisonTurns: 0,
confusionTurns: 0,
speedTurns: 0,
strengthTurns: 0,
burnTurns: 0,
paralyzedTurns: 0,
intrinsics: antType.intrinsics ? {
...antType.intrinsics
}: {}
});
log('More ants arrive!', 'damage');
}
}
}
}

// AMBUSHER
if (monster.behavior === 'ambusher' && monster.state === 'sleeping') {
if (!monster.revealed && distToPlayer < 1.5) {
monster.revealed = true;
monster.state = 'chasing';
log(`The ${monster.mimicItem || 'chest'} was a ${monster.name}!`, 'damage');
attack(monster, player);
return;
}
}

// SHAMBLER
if (monster.behavior === 'shambler' && monster.state === 'chasing' && Math.random() < 0.3) {
monster.ap -= monster.apRegen;
return;
}

// PHASER
if (monster.behavior === 'phaser' && Math.random() < 0.1) {
const dx = Math.sign(player.x - monster.x);
const dy = Math.sign(player.y - monster.y);
const newX = monster.x + dx;
const newY = monster.y + dy;

if (newX >= 0 && newX < WIDTH && newY >= 0 && newY < HEIGHT) {
if (!monsters.some(m => m.x === newX && m.y === newY && m !== monster) &&
!(player.x === newX && player.y === newY)) {
monster.x = newX;
monster.y = newY;
monster.ap -= monster.apRegen;
if (dungeon.tiles[newY][newX] === '#') {
log(`${monster.name} phases through the wall!`, 'info');
}
}
}
}

// SUMMONER
if (monster.behavior === 'summoner' && canSeePlayer && distToPlayer < 6 && Math.random() < 0.03) {
const pos = findWalkableAdjacent(monster.x, monster.y);
if (pos) {
const summonPool = MONSTER_TYPES.filter(t =>
t.depth <= dungeonLevel &&
t.depth >= dungeonLevel - 2 &&
t.behavior !== 'summoner'
);

if (summonPool.length > 0) {
const summonType = summonPool[Math.floor(Math.random() * summonPool.length)];
monsters.push({
...summonType,
x: pos.x,
y: pos.y,
maxHp: summonType.hp,
hp: summonType.hp,
ap: 0,
maxAP: summonType.maxAP || 100,
state: 'chasing',
weapon: null,
exhaustedTurns: 0,
poisonTurns: 0,
confusionTurns: 0,
speedTurns: 0,
strengthTurns: 0,
burnTurns: 0,
paralyzedTurns: 0,
intrinsics: summonType.intrinsics ? {
...summonType.intrinsics
}: {}
});
log(`${monster.name} summons a ${summonType.name}!`, 'damage');
monster.ap -= monster.apRegen * 3;
}
}
}

// PEACEFUL (unless provoked)
if (monster.behavior === 'peaceful' && !monster.wasAttacked) {
if (monster.state === 'chasing') {
monster.state = 'wandering';
}
}
}


function handleFleeingBehavior(monster) {
const dx = Math.sign(monster.x - player.x);
const dy = Math.sign(monster.y - player.y);
let moveX = monster.x + dx;
let moveY = monster.y + dy;
if (isWalkable(moveX, moveY) &&
!monsters.some(m => m.x === moveX && m.y === moveY) &&
!(player.x === moveX && player.y === moveY)) {
monster.x = moveX;
monster.y = moveY;
monster.ap -= monster.apRegen;
}
}

function handleChasingBehavior(monster, distToPlayer, canSeePlayer) {
if (monster.behavior === 'ranged' && distToPlayer > 2 && distToPlayer < 8 && canSeePlayer) {
log(`${monster.name} zaps you from afar!`, 'damage');
takeDamage(rollDice(1, 4));
monster.ap -= monster.apRegen;
return;
} else if (distToPlayer < 1.5) {
attack(monster, player);
} else {
let moveX = monster.x;
let moveY = monster.y;
if (Math.abs(player.x - monster.x) > Math.abs(player.y - monster.y)) {
moveX += Math.sign(player.x - monster.x);
} else {
moveY += Math.sign(player.y - monster.y);
}
if (isWalkable(moveX, moveY) &&
!monsters.some(m => m.x === moveX && m.y === moveY) &&
!(player.x === moveX && player.y === moveY)) {
monster.x = moveX;
monster.y = moveY;
monster.ap -= monster.apRegen;
}
}
}

function handleHuntingBehavior(monster) {
if (!monster.lastKnownPlayerX || !monster.lastKnownPlayerY) {
monster.state = 'wandering';
return;
}

const dx = monster.lastKnownPlayerX - monster.x;
const dy = monster.lastKnownPlayerY - monster.y;
const dist = Math.hypot(dx, dy);

if (dist < 1.5) {
monster.state = 'wandering';
monster.lastKnownPlayerX = null;
monster.lastKnownPlayerY = null;
return;
}

let moveX = monster.x;
let moveY = monster.y;
if (Math.abs(dx) > Math.abs(dy)) {
moveX += Math.sign(dx);
} else {
moveY += Math.sign(dy);
}

if (isWalkable(moveX, moveY) &&
!monsters.some(m => m.x === moveX && m.y === moveY) &&
!(player.x === moveX && player.y === moveY)) {
monster.x = moveX;
monster.y = moveY;
monster.ap -= monster.apRegen;
}
}

function handleGuardingBehavior(monster) {
if (!monster.guardX || !monster.guardY) {
monster.guardX = monster.x;
monster.guardY = monster.y;
}

const distToGuardPoint = Math.hypot(monster.x - monster.guardX, monster.y - monster.guardY);
const distToPlayer = Math.hypot(player.x - monster.x, player.y - monster.y);

if (distToPlayer < 5 && lineOfSight(monster.x, monster.y, player.x, player.y)) {
monster.state = 'chasing';
return;
}

if (distToGuardPoint > 3) {
let moveX = monster.x;
let moveY = monster.y;
const dx = monster.guardX - monster.x;
const dy = monster.guardY - monster.y;

if (Math.abs(dx) > Math.abs(dy)) {
moveX += Math.sign(dx);
} else {
moveY += Math.sign(dy);
}

if (isWalkable(moveX, moveY) &&
!monsters.some(m => m.x === moveX && m.y === moveY) &&
!(player.x === moveX && player.y === moveY)) {
monster.x = moveX;
monster.y = moveY;
monster.ap -= monster.apRegen;
}
}
}

function handleWanderingBehavior(monster, distToPlayer) {
if (Math.random() < 0.5) {
const dx = Math.floor(Math.random() * 3) - 1;
const dy = Math.floor(Math.random() * 3) - 1;
let moveX = monster.x + dx;
let moveY = monster.y + dy;
if (isWalkable(moveX, moveY) &&
!monsters.some(m => m.x === moveX && m.y === moveY) &&
!(player.x === moveX && player.y === moveY)) {
monster.x = moveX;
monster.y = moveY;
monster.ap -= monster.apRegen;
}
}
if (distToPlayer > 10 && Math.random() < 0.01) {
log(`${monster.name} dozes off...`, 'info');
monster.state = 'sleeping';
}
}

function generateItemStatus() {
const roll = Math.random();
if (roll < 0.20) return 'Cursed';
if (roll < 0.80) return 'Normal';
return 'Blessed';
}

function spawnItems(count) {
    const mods = currentDungeonType?.modifiers || { itemSpawnMult: 1.0, bonusGold: 1.0 };
    const adjustedCount = Math.floor(count * mods.itemSpawnMult);
    
    // Spawn stairs with random status
    const validItems = ITEM_TYPES.filter(i => i.depth <= dungeonLevel);
    const stairsType = validItems.find(i => i.isStairs);
    const stairsRoom = dungeon.rooms[dungeon.rooms.length - 1] || dungeon.rooms[0];
    const stairsPos = findWalkable(stairsRoom);
    
    // Randomly bless/curse stairs
    const stairsStatus = Math.random() < 0.1 ? 'Blessed' : 
                        (Math.random() < 0.15 ? 'Cursed' : 'Normal');
    
    items.push({
        x: stairsPos.x, 
        y: stairsPos.y, 
        ...stairsType,
        status: stairsStatus
    });
    
    dungeon.tiles[stairsPos.y][stairsPos.x] = '>';
    
    // Adjust gold drops for treasure dungeons
    // (continue with existing item spawn logic, but multiply gold values by mods.bonusGold)
}

function spawnTraps(count) {
traps = [];
for (let i = 0; i < count; i++) {
let type = TRAP_TYPES[Math.floor(Math.random() * TRAP_TYPES.length)];
let room = dungeon.rooms[Math.floor(Math.random() * dungeon.rooms.length)];
if (!room || room.isVault) continue;
let pos = findWalkable(room);
traps.push({
...pos, ...type
});
}
}

function initGame(restart = false, role) {
if (restart) {
createPlayer(role);
dungeonLevel = 1; kills = 0;
document.getElementById('log').innerHTML = '<div class="log-entry">Welcome! Find the stairs (>) to descend deeper...</div>';
randomizeItemNames();
}
dungeon = generateDungeon(WIDTH, HEIGHT);
if (dungeon.rooms.length > 0) {
player.x = dungeon.rooms[0].cx; player.y = dungeon.rooms[0].cy;
} else {
let pos = findWalkable(); player.x = pos.x; player.y = pos.y;
}

pets = [];
let petPos = findWalkableAdjacent(player.x, player.y);

if (!petPos) {
const playerRoom = dungeon.rooms.find(r =>
player.x >= r.x && player.x < r.x + r.w &&
player.y >= r.y && player.y < r.y + r.h
);
petPos = findWalkable(playerRoom || null);
}

pets.push({
...PET_TYPES[0],
x: petPos.x,
y: petPos.y,
maxHp: PET_TYPES[0].hp,
ap: 0,
path: [],
pathTimestamp: 0,
poisonTurns: 0,
confusionTurns: 0,
speedTurns: 0,
strengthTurns: 0,
burnTurns: 0,
paralyzedTurns: 0,
hp: PET_TYPES[0].hp
});

player.lookCursor = {
x: player.x,
y: player.y
};
player.hp = player.maxHp; 
player.ap = player.maxAP;
player.poisonTurns = 0;
player.strengthTurns = 0; player.confusionTurns = 0; player.speedTurns = 0; player.paralyzedTurns = 0;
visible = Array(HEIGHT).fill().map(() => Array(WIDTH).fill(false));
explored = Array(HEIGHT).fill().map(() => Array(WIDTH).fill(false));
items = [];
spawnMonsters(Math.min(30, 10 + dungeonLevel * 2));
spawnItems(8 + dungeonLevel);
spawnTraps(5);
const percentage = 0.25 + Math.min(0.15, dungeonLevel * 0.01);
const envCount = Math.floor(dungeon.rooms.length * percentage);
spawnEnvironmentals(envCount);
// Depth 1: 26% of rooms = ~5
// Depth 10: 35% of rooms = ~7
// Depth 100: 40% of rooms = ~8 (capped at 40%)
turn = 0;
document.getElementById('restart-modal').classList.remove('show');
cancelActionModes(); // disable to preserve look-action context
computeFOV(player.x, player.y, getVisionRadius());
updateStats();
needsRedraw = true;
saveGame(false);
}

function getPlayerDR() {
  let dr = 1;
  if (player.armor) {
    let armorValue = player.armor.defense || 0;

    if (player.armor.enchantment) {
      const enchant = ENCHANTMENT_TYPES[player.armor.enchantment];
      if (enchant.drBonus) {
        armorValue += enchant.drBonus;
      }
    }

    if (player.armor.status === 'Blessed') {
      dr += armorValue + 2;
      if (Math.random() < 0.15) {
        log('Your blessed armor deflects the blow!', 'pickup');
        return 999;
      }
    } else if (player.armor.status === 'Cursed') {
      dr += Math.max(0, armorValue - 2);
    } else {
      dr += armorValue;
    }
    
    if (player.exhaustedTurns > 0) {
      dr = Math.max(0, dr - 2);
    }
  }
  
  if (player.ring && player.ring.equipped && player.ring.effect?.drBonus) {
    dr += player.ring.effect.drBonus;
  }
  
  return dr;
}

function getPlayerDodgeChance() {
let dodge = player.baseDodgeChance;
if (player.speedTurns > 0) dodge += 10;
if (player.sneakTurns > 0) dodge += 15; // Sneak bonus
return Math.min(90, Math.max(0, dodge));
}

function getDodgeChance(target) {
let dodge = target.baseDodgeChance ?? Math.floor((target.defense || 0) / 2);
if (target.armor) dodge += Math.floor((target.armor.defense || 0) / 2);
return Math.min(90, Math.max(0, dodge));
}

function getHungerStatus() {
if (player.hunger > 1500) return 'Satiated';
if (player.hunger > 500) return 'Normal';
if (player.hunger > 200) return 'Hungry';
if (player.hunger > 0) return 'Weak';
return 'Fainting';
}

function getWeaponDisplayName(item) {
if (!item || item.type !== 'weapon') return item.visualName || item.name;

const prefix = item.mod?.getNamePrefix?.() || '';
const bonus = item.mod?.bonus ? ` +${item.mod.bonus}`: '';
return `${prefix ? prefix + ' ': ''}${item.visualName || item.name}${bonus}`;
}

function getAppearanceOrIdentity(item) {
if (item.identified && item.baseName) {
return item.baseName;
}
if (!item.identified && item.visualName) {
return item.visualName;
}
return item.name || 'unknown';
}

function getItemDisplayName(item) {
let name;

const mysteryTypes = ['ring',
'scroll',
'potion',
'amulet'];
if (mysteryTypes.includes(item.type)) {
name = getAppearanceOrIdentity(item);
} else {
name = item.name;
}

if (item.type === 'weapon' && item.identified && item.mod) {
name = getWeaponDisplayName(item);
}

if (item.type === 'wand' && item.identified) {
name += ` (${item.charges})`;
}

if (item.type === 'ammo' && item.count > 1) {
name += ` (${item.count})`;
}

if (item.type !== 'gold' && item.status && item.status !== 'Normal') {
name = `${item.status} ${name}`;
}

if (item.equipped) {
name = `[E] ${name}`;
}

return name;
}

function updateInventoryDisplay() {
const list = document.getElementById('inventory-list');
if (!list) return;
list.innerHTML = '';
player.inventory.forEach((item, index) => {
const button = document.createElement('button');
button.className = 'inventory-btn';
if (currentActionContext && currentActionContext.item === item) button.classList.add('action-mode-selected');
button.textContent = `(${String.fromCharCode(97 + index)}) ${getItemDisplayName(item)}`;
button.dataset.index = index;
button.addEventListener('click', (e) => handleInventoryClick(e, item));
list.appendChild(button);
});
}

function updateStats() {
  
const rageBtn = document.getElementById('rage-btn');
if (rageBtn) {
rageBtn.style.display = player.canRage ? 'block': 'none';
}
document.getElementById('hp').textContent = `${player.hp}/${player.maxHp}`;
document.getElementById('level').textContent = player.level;
document.getElementById('xp').textContent = player.xp;
document.getElementById('depth').textContent = dungeonLevel;
document.getElementById('ap').textContent = `${player.ap}/${player.maxAP}`;
document.getElementById('dr').textContent = getPlayerDR();
document.getElementById('dodge').textContent = `${getPlayerDodgeChance()}%`;
document.getElementById('gold').textContent = player.gold;
document.getElementById('weapon').textContent = player.weapon ? getItemDisplayName(player.weapon): 'Fists';
document.getElementById('armor').textContent = player.armor ? getItemDisplayName(player.armor): 'None';
if (player.accessory?.baseName === 'quiver') {
const q = player.accessory;
const arrowCount = q.arrows || 0;
const boltCount = q.bolts || 0;
let quiverText = `Quiver: ${arrowCount}↑`;
if (boltCount > 0) quiverText += ` ${boltCount}⚡`;

if (player.rangedWeapon?.equipped) {
const weaponEl = document.getElementById('weapon');
weaponEl.textContent += ` | ${quiverText}`;
}
}

let statusText = 'Normal';
if (player.paralyzedTurns > 0) statusText = 'Paralyzed';
else if (player.poisonTurns > 0) statusText = 'Poisoned';
else if (player.confusionTurns > 0) statusText = 'Confused';
else if (player.rageTurns > 0) statusText = 'RAGING';
else if (player.exhaustedTurns > 0) statusText = 'Exhausted';
else if (player.strengthTurns > 0) statusText = 'Strong';
else if (player.speedTurns > 0) statusText = 'Hasted';
if (player.hp <= player.maxHp * 0.2) statusText += ' (Low HP)';
document.getElementById('status').textContent = statusText;
document.getElementById('hunger').textContent = getHungerStatus();
updateInventoryDisplay();
updateActivateButton();
updateStatusGrid();
needsRedraw = true;
}

function updateScore(amount) {
player.score += amount;
}

function identifyItem(item) {
if (!item.identified) {
const trueBaseName = itemVisualToTypeMap[item.visualName] || item.baseName || item.name;
item.identified = true;
item.name = trueBaseName;

[...items,
...player.inventory].forEach(i => {
if (i.visualName === item.visualName) {
i.identified = true;
i.name = trueBaseName;
i.baseName = trueBaseName;
}
});
log(`You have discovered the ${trueBaseName}!`,
'pickup');
updateStats();
}
}

function rechargeWand(wand, chargesAdded) {
if (!wand || wand.type !== 'wand') {
log('That is not a wand.', 'damage');
return false;
}

wand.charges += chargesAdded;
log(`Your ${wand.name} glows with renewed power! (+${chargesAdded} charges)`, 'pickup');
updateStats();
return true;
}

function applyItemEffectToPlayer(item) {
let consumed = false;

let statusMultiplier = 1.0;
if (item.status === 'Blessed') statusMultiplier = 1.5;
if (item.status === 'Cursed') statusMultiplier = 0.5;

if (item.heal) {
const healAmount = Math.floor(item.heal * statusMultiplier);
player.hp = Math.min(player.maxHp, player.hp + healAmount);
log(`You feel ${item.status === 'Blessed' ? 'much ': ''}better.`, 'pickup');
if (item.status === 'Cursed') {
player.confusionTurns += 2;
log('The cursed potion confuses you!', 'damage');
}
consumed = true;
}

if (item.effect) {
const resolvedEffect = typeof item.effect === 'string' ? EFFECT_TYPES[item.effect]: item.effect;

if (resolvedEffect.strength) {
player.strengthTurns += resolvedEffect.strength;
log('You feel stronger!', 'pickup');
consumed = true;
}
if (resolvedEffect.confusion) {
player.confusionTurns += resolvedEffect.confusion;
log('You feel confused!', 'damage');
consumed = true;
}
if (resolvedEffect.speed) {
player.speedTurns += resolvedEffect.speed;
log('You feel swift!', 'pickup');
consumed = true;
}

if (resolvedEffect.damage && resolvedEffect.turns && resolvedEffect.spreadChance !== undefined) {
player.burnTurns = (player.burnTurns || 0) + resolvedEffect.turns;
log('You are engulfed in flames!', 'damage');
if (Math.random() < 0.5) {
dungeon.features.push({
x: player.x,
y: player.y,
type: 'fire',
glyph: '}',
color: '#f80',
spreadChance: resolvedEffect.spreadChance,
damage: resolvedEffect.damage,
duration: rollDice(1, 4, 3)
});
dungeon.tiles[player.y][player.x] = '}';
needsRedraw = true;
}
consumed = true;
}

if (resolvedEffect.identify) {
const unIDedItem = player.inventory.find(i => !i.identified && i !== item);
if (unIDedItem) identifyItem(unIDedItem);
else log('You have no unidentified items.', 'info');
consumed = true;
}
if (resolvedEffect.teleport) {
teleportPlayer();
consumed = true;
}
if (resolvedEffect.magicMap) {
for (let y = 0; y < HEIGHT; y++) for (let x = 0; x < WIDTH; x++) {
if (dungeon.tiles[y][x] !== ' ') explored[y][x] = true;
}
log('The map is revealed!', 'pickup');
needsRedraw = true;
consumed = true;
}
if (resolvedEffect.removeCurse) {
let cursedItem = player.inventory.find(i => i.status === 'Cursed');
if (cursedItem) {
cursedItem.status = 'Normal';
log(`You feel a burden lift. The ${cursedItem.name} is no longer cursed.`, 'pickup');
} else log('You feel a sense of purity for a moment.', 'info');
consumed = true;
}
if (resolvedEffect.nutrition !== undefined) {
const nutritionAmount = Math.floor(resolvedEffect.nutrition * statusMultiplier);
player.hunger = Math.min(player.maxHunger, player.hunger + nutritionAmount);
log(`That was ${item.status === 'Blessed' ? 'delicious': (item.status === 'Cursed' ? 'awful': 'satisfying')}!`, 'pickup');
consumed = true;
}
}

if (consumed) identifyItem(item);
return consumed;
}

function applyItemEffectToMonster(item, monster) {
if (item.effect && item.effect.confusion) {
monster.confusionTurns = (monster.confusionTurns || 0) + 7;
log(`${monster.name} looks confused!`, 'damage');
}
if (item.effect && item.effect.teleport) teleportMonster(monster);
identifyItem(item);
}

function applyThrownEffectToEntity(item, entity) {
if (!item.effect) return;

const resolvedEffect = typeof item.effect === 'string' ? EFFECT_TYPES[item.effect]: item.effect;

if (item.heal) {
const healAmount = Math.floor(item.heal * (item.status === 'Blessed' ? 1.5: item.status === 'Cursed' ? 0.5: 1));
entity.hp = Math.min(entity.maxHp, entity.hp + healAmount);
log(`Your ${entity.name} feels better!`, 'pickup');
if (item.status === 'Cursed') {
entity.confusionTurns += 2;
log(`The cursed splash confuses your ${entity.name}!`, 'damage');
}
return;
}

if (resolvedEffect.strength) {
entity.strengthTurns += resolvedEffect.strength;
log(`Your ${entity.name} feels stronger!`, 'pickup');
return;
}
if (resolvedEffect.confusion) {
entity.confusionTurns += resolvedEffect.confusion;
log(`Your ${entity.name} looks confused!`, 'damage');
return;
}
if (resolvedEffect.speed) {
entity.speedTurns += resolvedEffect.speed;
log(`Your ${entity.name} feels swift!`, 'pickup');
return;
}
if (resolvedEffect.burning || (resolvedEffect.damage && resolvedEffect.turns)) {
entity.burnTurns = (entity.burnTurns || 0) + (resolvedEffect.turns || 3);
entity.hp -= (resolvedEffect.damage || 2);
log(`Your ${entity.name} is splashed with burning liquid!`, 'damage');
if (entity.hp <= 0) handleEntityDeath(player, entity);
return;
}
}

function useFeature() {
const feature = dungeon.features.find(f =>
f.x === player.x &&
f.y === player.y &&
(f.type === 'fountain' || f.type === 'sink' || f.type === 'altar')
);

if (!feature) {
log('There is nothing to use here.', 'info');
return false;
}

switch (feature.type) {
case 'fountain':
return useFountain();
case 'sink':
return useSink();
case 'altar':
log('Use the Pray action at altars.', 'info');
return false;
default:
log('You cannot use that.', 'info');
return false;
}
}

function useFountain() {
if (!safeSpendAP(50, 'drink from fountain', true)) return;

const fountain = dungeon.features.find(f =>
f.x === player.x &&
f.y === player.y &&
f.type === 'fountain'
);

const roll = Math.random();

if (roll < 0.15) {
log('The water is refreshing!', 'pickup');
player.hp = Math.min(player.maxHp, player.hp + 5);
} else if (roll < 0.30) {
log('You feel more energetic!', 'pickup');
player.ap = player.maxAP;
} else if (roll < 0.40) {
log('The water tastes strange... you feel confused!', 'damage');
player.confusionTurns += 5;
} else if (roll < 0.50) {
log('The fountain grants you strength!', 'pickup');
player.strengthTurns += 10;
} else if (roll < 0.55) {
log('The fountain dries up!', 'damage');
dungeon.features = dungeon.features.filter(f => f !== fountain);
dungeon.tiles[fountain.y][fountain.x] = '.';
needsRedraw = true;
} else if (roll < 0.60) {
log('A troll appears!', 'damage');
const pos = findWalkableAdjacent(player.x, player.y);
if (pos) {
const demonType = MONSTER_TYPES.find(t => t.name === 'troll') || MONSTER_TYPES[3];
monsters.push({
...pos, ...demonType, maxHp: demonType.hp, ap: 0, state: 'chasing', weapon: null
});
}
} else {
log('The water tastes ordinary.', 'info');
}

processTurn();
return true;
}

function useSink() {
if (!safeSpendAP(30, 'use sink', true)) return false;

const roll = Math.random();

if (roll < 0.20) {
const rings = ITEM_TYPES.filter(i => i.type === 'ring');

if (rings.length > 0) {
const base = rings[Math.floor(Math.random() * rings.length)];
const ring = {
...base,
x: player.x,
y: player.y,
identified: false,
count: base.count || 1
};

items.push(ring);
log(`You find ${getItemDisplayName(ring)} in the drain!`, 'pickup');
} else {
log('The sink gurgles, but nothing valuable appears.', 'info');
}

} else if (roll < 0.35) {
log('The pipes rumble ominously...', 'damage');
takeDamage(rollDice(1, 3));

} else if (roll < 0.50) {
log('You wash your face. You feel refreshed!', 'pickup');
player.confusionTurns = 0;
player.poisonTurns = Math.max(0, player.poisonTurns - 3);

} else {
log('Nothing interesting happens.', 'info');
}

processTurn();
return true;
}



function castSpell(spellKey) {
  const spell = SPELL_TYPES[spellKey];
  if (!spell) {
    log('Unknown spell!', 'damage');
    return false;
  }

  if (player.ap < spell.cost) {
    log(`Not enough AP to cast ${spell.name}! (Need ${spell.cost}, have ${player.ap})`, 'damage');
    return false;
  }

  player.ap -= spell.cost;

  switch (spellKey) {
    case 'magicMissile': return castMagicMissile(spell);
    case 'fireball': return castFireball(spell);
    case 'slow': return castSlow(spell);
    case 'identify': return castIdentify(spell);
    case 'whirlwind': return castWhirlwind(spell);
    case 'warcry': return castWarCry(spell);
    case 'backstab': return castBackstab(spell);
    case 'poisonWeapon': return castPoisonWeapon(spell);
    case 'multishot': return castMultishot(spell);
    case 'piercingShot': return castPiercingShot(spell);
  }

  return false;
}

function castMagicMissile(spell) {
  const nearestMonster = monsters.find(m => {
    const dist = Math.hypot(m.x - player.x, m.y - player.y);
    return dist <= spell.range && visible[m.y][m.x];
  });

  if (!nearestMonster) {
    log('No target in range!', 'damage');
    player.ap += spell.cost;
    return false;
  }

  const damage = rollDice(spell.damage[0], spell.damage[1]);
  takeMonsterDamage(nearestMonster, damage, 'magic', player);
  log(`Your magic missiles strike ${nearestMonster.name} for ${damage} damage!`, 'damage');

  if (nearestMonster.hp <= 0) {
    handleEntityDeath(player, nearestMonster);
  }

  processTurn();
  return true;
}

function castFireball(spell) {
  log('Select fireball target with cursor, then activate.', 'info');
  player.isLooking = true;
  player.lookCursor = { x: player.x, y: player.y };
  currentActionContext = {
    action: 'cast-fireball',
    spell: spell
  };
  return true;
}

function executeFireball(spell, targetX, targetY) {
  const dist = Math.hypot(targetX - player.x, targetY - player.y);
  if (dist > spell.range) {
    log('Target out of range!', 'damage');
    player.ap += spell.cost;
    return false;
  }

  log('FWOOSH! A fireball explodes!', 'damage');

  for (let dy = -spell.radius; dy <= spell.radius; dy++) {
    for (let dx = -spell.radius; dx <= spell.radius; dx++) {
      const x = targetX + dx;
      const y = targetY + dy;
      
      if (Math.hypot(dx, dy) > spell.radius) continue;

      const damage = rollDice(spell.damage[0], spell.damage[1]);

      monsters.forEach(m => {
        if (m.x === x && m.y === y) {
          takeMonsterDamage(m, damage, 'fire', player);
          log(`${m.name} is burned for ${damage} damage!`, 'damage');
          if (m.hp <= 0) handleEntityDeath(player, m);
        }
      });

      if (player.x === x && player.y === y) {
        takeDamage(damage, 'fire');
        log('You are caught in your own fireball!', 'damage');
      }
    }
  }

  processTurn();
  return true;
}

function castSlow(spell) {
  const nearestMonster = monsters.find(m => {
    const dist = Math.hypot(m.x - player.x, m.y - player.y);
    return dist <= spell.range && visible[m.y][m.x];
  });

  if (!nearestMonster) {
    log('No target in range!', 'damage');
    player.ap += spell.cost;
    return false;
  }

  nearestMonster.slowedTurns = spell.duration;
  log(`${nearestMonster.name} is slowed!`, 'pickup');
  processTurn();
  return true;
}

function castIdentify(spell) {
  let identifiedCount = 0;
  player.inventory.forEach(item => {
    if (!item.identified) {
      identifyItem(item);
      identifiedCount++;
    }
  });
  
  if (identifiedCount === 0) {
    log('All items already identified!', 'info');
    player.ap += spell.cost;
    return false;
  }
  
  log(`Identified ${identifiedCount} items!`, 'pickup');
  processTurn();
  return true;
}

function castWhirlwind(spell) {
  let hitCount = 0;
  
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (dx === 0 && dy === 0) continue;
      
      const targetX = player.x + dx;
      const targetY = player.y + dy;
      
      const monster = monsters.find(m => m.x === targetX && m.y === targetY);
      if (monster) {
        const damage = calculateDamage(player, monster);
        takeMonsterDamage(monster, damage, 'physical', player);
        hitCount++;
        
        if (monster.hp <= 0) {
          handleEntityDeath(player, monster);
        }
      }
    }
  }

  if (hitCount > 0) {
    log(`Your whirlwind strikes ${hitCount} enemies!`, 'damage');
  } else {
    log('Your whirlwind hits nothing!', 'info');
    player.ap += spell.cost;
    return false;
  }

  processTurn();
  return true;
}

function castWarCry(spell) {
  let frightenedCount = 0;
  
  monsters.forEach(m => {
    const dist = Math.hypot(m.x - player.x, m.y - player.y);
    if (dist <= spell.radius && visible[m.y][m.x]) {
      m.state = 'fleeing';
      frightenedCount++;
    }
  });

  if (frightenedCount === 0) {
    log('No enemies nearby to frighten!', 'info');
    player.ap += spell.cost;
    return false;
  }

  log(`Your war cry frightens ${frightenedCount} enemies!`, 'pickup');
  processTurn();
  return true;
}

function castBackstab(spell) {
  if (player.sneakTurns <= 0) {
    log('You must be sneaking to backstab!', 'damage');
    player.ap += spell.cost;
    return false;
  }

  const nearestMonster = monsters.find(m => 
    Math.hypot(m.x - player.x, m.y - player.y) < 1.5
  );

  if (!nearestMonster) {
    log('No adjacent target!', 'damage');
    player.ap += spell.cost;
    return false;
  }

  const baseDamage = calculateDamage(player, nearestMonster);
  const backstabDamage = Math.floor(baseDamage * spell.damageMultiplier);
  
  takeMonsterDamage(nearestMonster, backstabDamage, 'physical', player);
  log(`BACKSTAB! You deal ${backstabDamage} damage to ${nearestMonster.name}!`, 'damage');
  
  player.sneakTurns = 0;
  
  if (nearestMonster.hp <= 0) {
    handleEntityDeath(player, nearestMonster);
  }

  processTurn();
  return true;
}

function castPoisonWeapon(spell) {
  if (!player.weapon) {
    log('You need a weapon equipped!', 'damage');
    player.ap += spell.cost;
    return false;
  }

  player.poisonedWeaponTurns = spell.duration;
  log('Your weapon drips with poison!', 'pickup');
  processTurn();
  return true;
}

function castMultishot(spell) {
  if (!player.rangedWeapon || !player.rangedWeapon.equipped) {
    log('You need a ranged weapon equipped!', 'damage');
    player.ap += spell.cost;
    return false;
  }

  const ammoType = player.rangedWeapon.ammoType || 'arrows';
  const ammoResult = getAvailableAmmo(ammoType);
  
  if (!ammoResult || ammoResult.item.count < spell.arrows) {
    log(`You need ${spell.arrows} arrows!`, 'damage');
    player.ap += spell.cost;
    return false;
  }

  const targets = monsters
    .filter(m => visible[m.y][m.x] && Math.hypot(m.x - player.x, m.y - player.y) <= 8)
    .slice(0, spell.arrows);

  if (targets.length === 0) {
    log('No targets in range!', 'damage');
    player.ap += spell.cost;
    return false;
  }

  targets.forEach(target => {
    const damage = getRangedDamage(player.rangedWeapon);
    takeMonsterDamage(target, damage, 'piercing', player);
    log(`Arrow strikes ${target.name} for ${damage} damage!`, 'damage');
    
    if (target.hp <= 0) {
      handleEntityDeath(player, target);
    }
  });

  consumeAmmo(player, Math.min(spell.arrows, targets.length));
  
  log(`Multishot hits ${targets.length} targets!`, 'pickup');
  processTurn();
  return true;
}

function castPiercingShot(spell) {
  if (!player.rangedWeapon || !player.rangedWeapon.equipped) {
    log('You need a ranged weapon equipped!', 'damage');
    player.ap += spell.cost;
    return false;
  }

  log('Select piercing shot direction with cursor, then activate.', 'info');
  player.isLooking = true;
  player.lookCursor = { x: player.x, y: player.y };
  currentActionContext = {
    action: 'cast-piercing-shot',
    spell: spell
  };
  return true;
}

function executePiercingShot(spell, dx, dy) {
  if (!player.rangedWeapon) {
    player.ap += spell.cost;
    return false;
  }

  const ammoType = player.rangedWeapon.ammoType || 'arrows';
  if (!consumeAmmo(player, 1)) {
    log(`Out of ${ammoType}!`, 'damage');
    player.ap += spell.cost;
    return false;
  }

  const path = traceLine(player.x, player.y, dx, dy, 12);
  let hitCount = 0;

  for (const {x, y} of path) {
    const monster = monsters.find(m => m.x === x && m.y === y);
    if (monster) {
      const damage = getRangedDamage(player.rangedWeapon);
      takeMonsterDamage(monster, damage, 'piercing', player);
      log(`Piercing arrow hits ${monster.name} for ${damage}!`, 'damage');
      hitCount++;
      
      if (monster.hp <= 0) {
        handleEntityDeath(player, monster);
      }
    }
  }

  if (hitCount === 0) {
    log('Your arrow flies harmlessly.', 'info');
  } else {
    log(`Piercing shot hits ${hitCount} enemies!`, 'pickup');
  }
  
  processTurn();
  return true;
}

function showEnchantmentModal(item) {
  let modal = document.getElementById('enchant-modal');
  if (modal) modal.remove();

  modal = document.createElement('div');
  modal.id = 'enchant-modal';
  modal.className = 'modal show';

  const validEnchantments = Object.entries(ENCHANTMENT_TYPES)
    .filter(([key, ench]) => ench.type === item.type);

  const currentLevel = item.upgradeLevel || 0;
  const canUpgrade = currentLevel < MAX_UPGRADE_LEVEL;
  const nextLevel = currentLevel + 1;
  const upgradeCost = canUpgrade ? getUpgradeCost(currentLevel) : 0;
  const nextMultiplier = canUpgrade ? getUpgradeMultiplier(nextLevel) : 0;

  modal.innerHTML = `
    <div class="modal-content" style="max-width: 500px;">
      <h2 style="color: #0f0;">⚡ Enhance Equipment</h2>
      
      <div style="background: #001100; padding: 10px; margin: 10px 0; border: 1px solid #0f0; border-radius: 4px;">
        <div style="font-size: 14px; font-weight: bold;">${getItemDisplayName(item)}</div>
        <div style="font-size: 11px; color: #888;">
          ${item.type === 'weapon' ? `Damage: ${item.damage}` : `DR: ${item.defense}`}
          ${item.upgradeLevel ? ` | Upgrade: +${item.upgradeLevel}` : ''}
        </div>
        ${item.enchantment ? `<div style="color: #0af; font-size: 11px;">Enchantment: ${ENCHANTMENT_TYPES[item.enchantment].name}</div>` : ''}
      </div>

      <div style="margin: 15px 0;">
        <h3 style="color: #ff0; font-size: 14px; margin-bottom: 8px;">💎 Upgrade (+${nextLevel})</h3>
        ${canUpgrade ? `
          <button class="modal-btn" id="upgrade-item" style="width: 100%; margin-bottom: 5px;">
            Upgrade for ${upgradeCost} gold<br>
            <span style="font-size: 11px;">×${nextMultiplier.toFixed(1)} effectiveness (+${Math.floor((nextMultiplier - 1) * 100)}%)</span>
          </button>
        ` : `<div style="color: #888; text-align: center; padding: 10px;">Max upgrade level reached! (+${MAX_UPGRADE_LEVEL})</div>`}
      </div>

      <div style="margin: 15px 0;">
        <h3 style="color: #0af; font-size: 14px; margin-bottom: 8px;">✨ Enchantments</h3>
        ${item.enchantment ? `
          <div style="color: #f80; font-size: 11px; margin-bottom: 10px; text-align: center;">
            Already enchanted. New enchantment will replace current.
          </div>
        ` : ''}
        <div id="enchantment-list" style="display: flex; flex-direction: column; gap: 5px;">
          ${validEnchantments.map(([key, ench]) => `
            <button class="modal-btn enchant-btn" data-enchant="${key}" style="text-align: left; padding: 8px;">
              <div style="display: flex; justify-content: space-between;">
                <span><strong>${ench.name}</strong> - ${ench.description}</span>
                <span style="color: #ff0;">${ench.cost}g</span>
              </div>
            </button>
          `).join('')}
        </div>
      </div>

      <button class="modal-btn" id="close-enchant">Cancel</button>
    </div>
  `;

  document.body.appendChild(modal);

  const upgradeBtn = document.getElementById('upgrade-item');
  if (upgradeBtn) {
    upgradeBtn.addEventListener('click', () => {
      if (player.gold >= upgradeCost) {
        player.gold -= upgradeCost;
        
        const oldMultiplier = getUpgradeMultiplier(currentLevel);
        item.upgradeLevel = nextLevel;
        
        if (item.type === 'weapon') {
          item.damage = Math.floor(item.damage * nextMultiplier / oldMultiplier);
        } else if (item.type === 'armor') {
          item.defense = Math.floor(item.defense * nextMultiplier / oldMultiplier);
        }
        
        log(`${getItemDisplayName(item)} upgraded to +${item.upgradeLevel}!`, 'pickup');
        updateStats();
        modal.remove();
        showEnchantmentModal(item);
      } else {
        log('Not enough gold!', 'damage');
      }
    });
  }

  document.querySelectorAll('.enchant-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const enchantKey = btn.dataset.enchant;
      const enchant = ENCHANTMENT_TYPES[enchantKey];
      
      if (player.gold >= enchant.cost) {
        player.gold -= enchant.cost;
        item.enchantment = enchantKey;
        
        log(`${getItemDisplayName(item)} enchanted with ${enchant.name}!`, 'pickup');
        updateStats();
        modal.remove();
      } else {
        log('Not enough gold!', 'damage');
      }
    });
  });

  document.getElementById('close-enchant').addEventListener('click', () => {
    modal.remove();
  });
}

function useItem(item, isStarting = false) {
// ✅ FIX 4: Cancel any active action modes
if (!isStarting) {
cancelActionModes();
}

if (!isStarting && player.ap < AP_COSTS.USE_ITEM) {
log('Not enough AP to use item!', 'damage');
return false;
}

if (item.baseName === 'torch' && item.type === 'tool') {
if (item.isLit) {
item.isLit = false;
item.equipped = false;
log('You extinguish and put away the torch.', 'info');
computeFOV(player.x, player.y, getVisionRadius());
needsRedraw = true;
} else {
if (item.turnsRemaining > 0) {
const currentTool = player.inventory.find(i => i.type === 'tool' && i.equipped && i !== item);
if (currentTool) {
currentTool.equipped = false;
if (currentTool.baseName === 'torch' && currentTool.isLit) {
currentTool.isLit = false;
log('Your other torch goes out as you switch.', 'info');
needsRedraw = true;
}
}
item.isLit = true;
item.equipped = true;
log(`You light and ready the torch. (${item.turnsRemaining} turns remaining)`, 'pickup');
computeFOV(player.x, player.y, getVisionRadius());
} else {
log('The torch is burned out.', 'damage');
needsRedraw = true;
return false;
}
}
if (!isStarting) {
player.ap -= AP_COSTS.USE_ITEM;
processTurn();
}
return true;
}

if (['weapon', 'ranged_weapon', 'armor', 'accessory', 'tool', 'ring', 'amulet'].includes(item.type)) {
if (item.equipped) {
if (item.status === 'Cursed') {
log(`The ${getItemDisplayName(item)} is cursed and cannot be removed!`, 'damage');
return false;
}

if (item.type === 'weapon') player.weapon = null;
if (item.type === 'ranged_weapon') player.rangedWeapon = null;
if (item.type === 'armor') player.armor = null;
if (item.type === 'accessory') {
if (item.baseName === 'quiver') {
const arrows = Number.isFinite(item.arrows) ? item.arrows: 0;
const bolts = Number.isFinite(item.bolts) ? item.bolts: 0;

const arrowsType = ITEM_TYPES.find(t => t.baseName === 'arrows');
const boltsType = ITEM_TYPES.find(t => t.baseName === 'bolts');

if (arrows > 0 && arrowsType) {
addItemToInventory({
...arrowsType, count: arrows, identified: true
});
}
if (bolts > 0 && boltsType) {
addItemToInventory({
...boltsType, count: bolts, identified: true
});
}

item.arrows = 0;
item.bolts = 0;
player.quiver.capacity = 0;

if (arrows > 0 || bolts > 0) {
log(`You unequip the quiver and return ${arrows} arrows${bolts ? ` and ${bolts} bolts`: ''} to your pack.`, 'info');
}
}
player.accessory = null;
}
if (item.type === 'ring') player.ring = null;
if (item.type === 'amulet') player.amulet = null;

removeEquipmentEffectFromPlayer(item);
item.equipped = false;
log(`You unequipped the ${getItemDisplayName(item)}.`, 'pickup');
} else {
if (item.type === 'weapon') {
if (player.weapon) player.weapon.equipped = false;
player.weapon = item;
}
if (item.type === 'ranged_weapon') {
if (player.rangedWeapon) player.rangedWeapon.equipped = false;
player.rangedWeapon = item;
}
if (item.type === 'armor') {
if (player.armor) player.armor.equipped = false;
player.armor = item;
}
if (item.type === 'accessory') {
if (player.accessory) player.accessory.equipped = false;
player.accessory = item;
if (item.baseName === 'quiver') player.quiver = item;
if (item.baseName === 'quiver' && item.quiverCapacity) {
player.quiver.capacity = item.quiverCapacity;
if (typeof item.arrows !== 'number') item.arrows = 0;
if (typeof item.bolts !== 'number') item.bolts = 0;
autoRefillQuiver();
}
}
if (item.type === 'ring') {
if (player.ring) player.ring.equipped = false;
player.ring = item;
}
if (item.type === 'amulet') {
if (player.amulet) player.amulet.equipped = false;
player.amulet = item;
}

item.equipped = true;
log(`You equipped the ${getItemDisplayName(item)}.`, 'pickup');
applyEquipmentEffectToPlayer(item);
}

if (!isStarting) {
player.ap -= AP_COSTS.USE_ITEM;
processTurn();
}
updateStats();
return true;
}

if (['potion', 'scroll', 'food'].includes(item.type)) {
const consumed = applyItemEffectToPlayer(item);
if (consumed) {
if (!isStarting) player.ap -= AP_COSTS.USE_ITEM;
const index = player.inventory.indexOf(item);
if (index > -1) player.inventory.splice(index, 1);
if (!isStarting) processTurn();
return true;
}
}

return false;
}

function applyEquipmentEffectToPlayer(item) {
if (!item || !item.effect) return;

const resolvedEffect = typeof item.effect === 'string'
? EFFECT_TYPES[item.effect]: item.effect;

if (resolvedEffect.telepathy) {
player.intrinsics.telepathy = true;
player.telepathy = true;
let multiplier = 1.0;
if (item.status === 'Blessed') multiplier = 1.5;
if (item.status === 'Cursed') multiplier = 0.5;
player.telepathyRadius = Math.floor(
(resolvedEffect.telepathyRadius || EFFECT_TYPES.telepathy.radius) * multiplier
);
log(`You sense monsters within ${player.telepathyRadius} tiles!`, 'info');
}

if (resolvedEffect.defense) {
player.defense = (player.defense || 0) + resolvedEffect.defense;
}

if (resolvedEffect.strengthBonus) {
player.strength = (player.strength || 0) + resolvedEffect.strengthBonus;
}
}

function removeEquipmentEffectFromPlayer(item) {
if (!item || !item.effect) return;

const resolvedEffect = typeof item.effect === 'string'
? EFFECT_TYPES[item.effect]: item.effect;

if (resolvedEffect.telepathy) {
player.intrinsics.telepathy = false;
player.telepathy = false;
player.telepathyRadius = 0;
log('Your monster sense fades.', 'info');
}

if (resolvedEffect.defense) {
player.defense = (player.defense || 0) - resolvedEffect.defense;
}

if (resolvedEffect.strengthBonus) {
player.strength = (player.strength || 0) - resolvedEffect.strengthBonus;
}
}

function dropItem(item) {
const index = player.inventory.indexOf(item);
if (index === -1) return;
if (item.equipped && item.status === 'Cursed') {
log(`You can't drop the cursed ${getItemDisplayName(item)}!`, 'damage');
return;
}
if (item.equipped) {
if (item.type === 'weapon') player.weapon = null;
if (item.type === 'armor') player.armor = null;
item.equipped = false;
}
player.inventory.splice(index, 1);
items.push({
x: player.x, y: player.y, ...item
});
log(`You dropped the ${getItemDisplayName(item)}.`, 'pickup');
updateStats();
needsRedraw = true;
}

function safeSpendAP(arg1, arg2, arg3, arg4) {
let entity,
cost,
actionName,
allowDebt;

if (typeof arg1 === 'object' && arg1 !== null && arg1.ap !== undefined) {
entity = arg1;
cost = arg2;
actionName = arg3 || 'Action';
allowDebt = arg4 !== undefined ? arg4: true;
} else {
entity = player;
cost = arg1;
actionName = arg2 || 'Action';
allowDebt = arg3 !== undefined ? arg3: true;
}

let effectiveRegenRate = entity.apRegen || 100;

if (entity.exhaustedTurns && entity.exhaustedTurns > 0) {
effectiveRegenRate = Math.floor(effectiveRegenRate * 0.5);
}

if (entity.ap >= cost) {
entity.ap -= cost;
return true;
}

if (cost <= effectiveRegenRate && !allowDebt) {
if (entity === player) {
log(`Insufficient AP for ${actionName}. Requires ${cost} AP.`, 'damage');
}
return false;
}

let remainingCost = cost - entity.ap;
let turnsOfWait = Math.ceil(remainingCost / effectiveRegenRate);

entity.ap -= cost;

if (typeof entity.paralyzedTurns !== 'number') {
entity.paralyzedTurns = 0;
}

entity.paralyzedTurns += turnsOfWait;
entity.paralyzedTurns = Math.min(entity.paralyzedTurns, 3);

if (turnsOfWait > 0 && entity === player) {
log(`You used a great deal of effort to ${actionName}. You are stunned for ${turnsOfWait} turn(s).`, 'damage');
}

return true;
}

function regenerateAP() {
  if (player.ap < player.maxAP) {
    let regenAmount = player.apRegen || 100;

    if (player.ring && player.ring.equipped && player.ring.effect?.apRegenBonus) {
      regenAmount += player.ring.effect.apRegenBonus;
    }

    if (player.exhaustedTurns > 0) {
      regenAmount = Math.floor(regenAmount * 0.5);
    }

    player.ap = Math.min(player.ap + regenAmount, player.maxAP);
  }

  monsters.forEach(m => {
    const maxAP = m.maxAP || (m.apRegen * 2) || 200;
    if (typeof m.ap !== 'number') m.ap = 0;

    let regenAmount = m.apRegen || 100;

    if (m.slowedTurns && m.slowedTurns > 0) {
      regenAmount = Math.floor(regenAmount * 0.5);
    }

    if (m.exhaustedTurns && m.exhaustedTurns > 0) {
      regenAmount = Math.floor(regenAmount * 0.5);
    }

    m.ap = Math.min(m.ap + regenAmount, maxAP);
  });

  pets.forEach(p => {
    const maxAP = p.maxAP || (p.apRegen * 2) || 200;
    if (typeof p.ap !== 'number') p.ap = 0;

    let regenAmount = p.apRegen || 100;

    if (p.exhaustedTurns && p.exhaustedTurns > 0) {
      regenAmount = Math.floor(regenAmount * 0.5);
    }

    p.ap = Math.min(p.ap + regenAmount, maxAP);
  });

  traps.forEach(t => {
    if (t.apRegen != null) {
      const maxAP = t.maxAP || 100;
      if (typeof t.ap !== 'number') t.ap = 0;
      t.ap = Math.min(t.ap + t.apRegen, maxAP);
    }
  });
}

function applyPlayerStatusEffects() {
  // HP regeneration
  if (player.hpRegenCooldown > 0) {
    player.hpRegenCooldown--;
  }

  if (player.hpRegenCooldown <= 0 && player.hp < player.maxHp && player.hunger > 500) {
    let regenAmount = 1;
    
    if (player.ring && player.ring.equipped && player.ring.effect?.regenBonus) {
      regenAmount += player.ring.effect.regenBonus;
    }
    
    if (player.armor && player.armor.enchantment === 'regeneration') {
      regenAmount += ENCHANTMENT_TYPES.regeneration.regenBonus;
    }
    
    player.hp += regenAmount;
    player.hpRegenCooldown = 20;
  }

  // Hunger
  player.hunger -= 1;
  if (player.hunger <= 0) {
    log('You are starving!', 'damage');
    takeDamage(1);
  }

  // Poison
  if (player.poisonTurns > 0) {
    takeDamage(1);
    player.poisonTurns--;
    if (player.poisonTurns === 0) log('The poison wears off.', 'pickup');
  }

  // Confusion
  if (player.confusionTurns > 0) {
    player.confusionTurns--;
    if (player.confusionTurns === 0) log('You feel less confused.', 'pickup');
  }

  // Strength
  if (player.strengthTurns > 0) {
    player.strengthTurns--;
    if (player.strengthTurns === 0) log('You feel weaker.', 'pickup');
  }

  // Speed
  if (player.speedTurns > 0) {
    player.speedTurns--;
    if (player.speedTurns === 0) log('You feel normal speed again.', 'pickup');
  }

  // Sneak
  if (player.sneakTurns > 0) {
    player.sneakTurns--;
    if (player.sneakTurns === 0) log('You step back into the light.', 'pickup');
  }

  // Poisoned Weapon (Rogue ability)
  if (player.poisonedWeaponTurns > 0) {
    player.poisonedWeaponTurns--;
    if (player.poisonedWeaponTurns === 0) log('Your weapon is no longer poisoned.', 'info');
  }

  // Burning
  if (player.burnTurns > 0) {
    takeDamage(2);
    player.burnTurns--;
    log('The flames sear your flesh!', 'damage');
    if (player.burnTurns === 0) log('The fire dies down.', 'pickup');
  }

  // Fire tile damage
  const fireFeature = dungeon.features.find(f =>
    f.type === 'fire' && f.x === player.x && f.y === player.y
  );
  if (fireFeature) {
    const fireDamage = fireFeature.damage || 2;
    takeDamage(fireDamage);
    log('You are burning!', 'damage');
  }

  // Rage countdown
  if (player.rageTurns > 0) {
    player.rageTurns--;
    if (player.rageTurns === 0) {
      log('Your rage subsides. You feel exhausted.', 'damage');
      player.exhaustedTurns = 15;
    }
  }

  // Exhaustion countdown
  if (player.exhaustedTurns > 0) {
    player.exhaustedTurns--;
    if (player.exhaustedTurns === 0) {
      log('Your exhaustion subsides. You feel normal.', 'pickup');
    }
  }

  // Torch burning
  player.inventory.forEach(item => {
    if (item.baseName === 'torch' && item.isLit && item.turnsRemaining > 0) {
      item.turnsRemaining--;
      if (item.turnsRemaining === 0) {
        item.isLit = false;
        log('Your torch burns out completely.', 'damage');
        computeFOV(player.x, player.y, getVisionRadius());
      } else if (item.turnsRemaining === 20) {
        log('Your torch is burning low!', 'info');
      }
    }
  });
}

// This handles monster and pet status effects
function applyMonsterStatusEffects() {
  // Process monsters
  for (let i = monsters.length - 1; i >= 0; i--) {
    const m = monsters[i];
    if (!m) continue;

    // Confusion
    if (m.confusionTurns > 0) m.confusionTurns--;
    
    // Slowed (from Wizard spell)
    if (m.slowedTurns > 0) {
      m.slowedTurns--;
      if (m.slowedTurns === 0) {
        log(`${m.name} is no longer slowed.`, 'info');
      }
    }

    // Burning
    if (m.burnTurns > 0) {
      m.hp -= 2;
      m.burnTurns--;
      log(`${m.name} burns!`, 'damage');
      if (m.burnTurns === 0) log(`${m.name}'s flames extinguish.`, 'pickup');
      if (m.hp <= 0) {
        handleEntityDeath(player, m);
        continue;
      }
    }

    // Fire tile damage
    const monsterFireFeature = dungeon.features.find(f =>
      f.type === 'fire' && f.x === m.x && f.y === m.y
    );
    if (monsterFireFeature) {
      m.hp -= monsterFireFeature.damage || 2;
      if (m.hp <= 0) {
        handleEntityDeath(player, m);
        continue;
      }
    }
  }

  // Process pets
  for (let i = pets.length - 1; i >= 0; i--) {
    const pet = pets[i];
    if (!pet) continue;

    if (pet.poisonTurns > 0) {
      pet.hp -= 1;
      pet.poisonTurns--;
      log(`Your ${pet.name} is poisoned!`, 'damage');
      if (pet.poisonTurns === 0) log(`The poison wears off your ${pet.name}.`, 'pickup');
      if (pet.hp <= 0) {
        handleEntityDeath(player, pet);
        continue;
      }
    }

    if (pet.confusionTurns > 0) {
      pet.confusionTurns--;
      if (pet.confusionTurns === 0) log(`Your ${pet.name} feels less confused.`, 'pickup');
    }

    if (pet.speedTurns > 0) {
      pet.speedTurns--;
      if (pet.speedTurns === 0) log(`Your ${pet.name} feels normal speed again.`, 'pickup');
    }

    if (pet.strengthTurns > 0) {
      pet.strengthTurns--;
      if (pet.strengthTurns === 0) log(`Your ${pet.name} feels weaker.`, 'pickup');
    }

    if (pet.burnTurns > 0) {
      pet.hp -= 2;
      pet.burnTurns--;
      log(`Your ${pet.name} burns!`, 'damage');
      if (pet.burnTurns === 0) log(`Your ${pet.name}'s flames extinguish.`, 'pickup');
      if (pet.hp <= 0) {
        handleEntityDeath(player, pet);
        continue;
      }
    }

    const petFireFeature = dungeon.features.find(f =>
      f.type === 'fire' && f.x === pet.x && f.y === pet.y
    );
    if (petFireFeature) {
      pet.hp -= petFireFeature.damage || 2;
      if (pet.hp <= 0) {
        handleEntityDeath(player, pet);
        continue;
      }
    }
  }
}

function calculateDamage(attacker, target) {
  let damage = 1;
  let weapon = attacker.weapon;

  if (weapon) {
    damage = rollDice(1, weapon.damage);

    if (weapon.enchantment) {
      const enchant = ENCHANTMENT_TYPES[weapon.enchantment];
      if (enchant.damageBonus) {
        damage += enchant.damageBonus;
      }
    }

    if (attacker === player) {
      if (weapon.status === 'Blessed') {
        damage += rollDice(1, 3);
        if (Math.random() < 0.1) {
          damage *= 2;
          log('Your blessed weapon delivers a crushing blow!', 'pickup');
        }
      } else if (weapon.status === 'Cursed') {
        damage = Math.max(1, damage - 2);
        if (Math.random() < 0.15) {
          takeDamage(2);
          log('Your cursed weapon backfires!', 'damage');
        }
      }

      if (player.poisonedWeaponTurns > 0 && target) {
        target.poisonTurns = (target.poisonTurns || 0) + 3;
        log(`${target.name} is poisoned!`, 'pickup');
      }
    }

    if (target.resists === weapon.damageType) {
      damage = Math.max(1, Math.floor(damage / 2));
      if (attacker === player) {
        log(`${target.name} resists the ${weapon.damageType} damage!`, 'info');
      }
    }
  } else {
    damage = rollDice(1, attacker.damage || 2);
  }

  if (attacker === player) {
    if (player.rageTurns > 0) {
      damage += rollDice(1, 6);
    }
    if (player.exhaustedTurns > 0) {
      damage = Math.max(1, damage - 3);
    }
    if (player.ring && player.ring.equipped && player.ring.effect?.damageBonus) {
      damage += player.ring.effect.damageBonus;
    }
    if (player.strengthTurns > 0) {
      damage += 2;
    }

    if (weapon && weapon.enchantment === 'vampiric') {
      const heal = Math.floor(damage * ENCHANTMENT_TYPES.vampiric.lifesteal);
      if (heal > 0) {
        player.hp = Math.min(player.maxHp, player.hp + heal);
        log(`You drain ${heal} HP!`, 'pickup');
      }
    }
  }

  if (attacker !== player) {
    if (attacker.swarmBonus && attacker.swarmBonus > 0) {
      damage += attacker.swarmBonus;
    }
    if (attacker.strengthTurns && attacker.strengthTurns > 0) {
      damage += 2;
    }
    if (attacker.exhaustedTurns && attacker.exhaustedTurns > 0) {damage = Math.max(1, damage - 2);
    }
  }

  return Math.max(1, damage);
}

function attack(attacker, target) {
if (attacker.ap < AP_COSTS.ATTACK) {
if (attacker === player) log('Not enough AP for attack!', 'damage');
safeSpendAP(AP_COSTS.attack, 'ATTACK', true);
return;
}
attacker.ap -= AP_COSTS.ATTACK;

const hitRoll = Math.random() * 100;
const effectiveHitChance = (attacker.hitChance || 70) - getDodgeChance(target);

if (hitRoll < effectiveHitChance) {
let damage = calculateDamage(attacker, target);

let damageType = 'physical';
if (attacker.weapon?.mod?.element) {
damageType = attacker.weapon.mod.element;
}

if (target === player) {
takeDamage(damage, damageType);
log(`${attacker.name} hits you for ${damage} damage!`, 'damage');
} else {
takeMonsterDamage(target, damage, damageType, attacker);
log(`${attacker.name} hits ${target.name} for ${damage} damage!`, 'damage');
}

if (attacker.weapon?.mod?.element) {
attacker.weapon.mod.onHit(attacker, target);
}

if (target.hp <= 0) {
handleEntityDeath(attacker, target);
} else {
if (target === player && attacker.name === 'slime' && Math.random() < 0.25) {
if (player.armor) {
player.armor.defense = Math.max(0, player.armor.defense - 1);
log('Your armor corrodes!', 'damage');
updateStats();
}
}
}
} else {
log(`${attacker.name} misses ${target.name}.`, 'info');
}
if (attacker === player) {
processTurn();
}
}

function handleEntityDeath(attacker, target) {
if (target === player) {
log('You have died!', 'death');
const causeOfDeath = 'Killed by a ' + (attacker.name || 'unknown force');
saveDeadRun(player.name, player.score, player.level, player.role, causeOfDeath);
showRestartModal();
return;
}

log(`${target.name} is defeated!`, 'death');

if (attacker === player) {
gainXp(target.xp || 1);
kills++;
}

if (Math.random() < 0.8) {
const goldValue = rollDice(1, Math.max(2, Math.floor((target.xp || 2) / 2)), target.xp || 1);
items.push({
x: target.x,
y: target.y,
glyph: '$',
name: 'gold',
color: '#ff0',
value: goldValue,
identified: true,
type: 'gold',
baseName: 'gold'
});
}

if (target.name === 'slime' && Math.random() < 0.5) {
const moldType = ITEM_TYPES.find(i => i.baseName === 'slime mold');
if (moldType) {
items.push({
x: target.x,
y: target.y,
...moldType,
name: moldType.baseName,
identified: true
});
}
}

if (target.weapon) {
items.push({
...target.weapon,
x: target.x,
y: target.y
});
}

if (monsters.includes(target)) {
monsters = monsters.filter(m => m !== target);
}
if (pets.includes(target)) {
pets = pets.filter(p => p !== target);
}

needsRedraw = true;
}

function takeDamage(damage, type = 'physical') {
let effectiveDamage = Math.max(0, damage);

const intrinsicMap = {
fire: 'fireResist',
cold: 'coldResist',
poison: 'poisonResist',
shock: 'shockResist'
};

if (player.intrinsics && intrinsicMap[type]) {
const key = intrinsicMap[type];
if (player.intrinsics[key]) {
switch (type) {
case 'poison':
log('You shrug off the poison!', 'info');
effectiveDamage = 0;
break;
default:
const msg = {
fire: 'You resist the flames!',
cold: 'You resist the chill!',
shock: 'You resist the jolt!'
}[type] || 'You resist the attack!';
log(msg, 'info');
effectiveDamage = Math.floor(effectiveDamage / 2);
break;
}
}
}

if (type === 'physical') {
const dr = getPlayerDR();
effectiveDamage = Math.max(effectiveDamage === 0 ? 0: 1, effectiveDamage - dr);
}

if (effectiveDamage <= 0) {
return;
}

player.hp -= effectiveDamage;
updateStats();

if (player.hp <= 0) {
const canRevive =
player.amulet &&
player.amulet.equipped &&
player.amulet.effect?.revive &&
!player.hasUsedRevive;

if (canRevive) {
player.hp = Math.floor(player.maxHp / 2);
player.hasUsedRevive = true;
log('Your amulet glows brightly and saves your life!', 'pickup');
log('The amulet crumbles to dust.', 'damage');
player.amulet.equipped = false;
player.amulet = null;
player.inventory = player.inventory.filter(i => i.type !== 'amulet' || !i.effect?.revive);
updateStats();
return;
}

player.hp = 0;
log('You have died!', 'death');
showRestartModal();
}
}

function takeMonsterDamage(monster, damage, type = 'physical', attacker = null) {
let effectiveDamage = Math.max(0, damage);

const intrinsicMap = {
fire: 'fireResist',
cold: 'coldResist',
poison: 'poisonResist',
shock: 'shockResist'
};

if (monster.intrinsics && intrinsicMap[type]) {
const key = intrinsicMap[type];
if (monster.intrinsics[key]) {
switch (type) {
case 'poison':
if (attacker === player) log(`${monster.name} is immune to poison!`, 'info');
effectiveDamage = 0;
break;
default:
if (attacker === player) log(`${monster.name} resists ${type} damage!`, 'info');
effectiveDamage = Math.floor(effectiveDamage / 2);
break;
}
}
}

if (type === 'physical') {
let monsterDR = monster.defense || 0;
if (monster.armor) {
monsterDR += monster.armor.defense || 0;
}
effectiveDamage = Math.max(effectiveDamage === 0 ? 0: 1, effectiveDamage - monsterDR);
}

if (effectiveDamage <= 0) {
return;
}

monster.hp -= effectiveDamage;
}

function exitLookMode() {
player.isLooking = false;

// Clear action context completely
currentActionContext = null;
player.actionMode = null;

// Reset cursor
player.lookCursor.x = player.x;
player.lookCursor.y = player.y;

// Clear targets
target = null;
targetName = null;
targetHP = null;

// Remove visual indicators
const lookBtn = document.getElementById('look-btn');
if (lookBtn) lookBtn.classList.remove('action-mode');

updateActivateButton();

needsRedraw = true;

log('Look mode OFF.', 'info');
}

function cancelActionModes() {
// Clear look mode
player.isLooking = false;

// Clear ALL action contexts
currentActionContext = null;
player.actionMode = null;

// ✅ NO cursor reset - it's reset when entering look mode anyway

// Clear target references
target = null;
targetName = null;
targetHP = null;

// Remove visual mode indicators from ACTION MODE buttons only
const modeButtons = ['look-btn',
'throw-mode-btn',
'activate-btn'];

modeButtons.forEach(id => {
const btn = document.getElementById(id);
if (btn) {
btn.classList.remove('action-mode');
btn.style.background = '#002200';
btn.style.borderColor = '#0f0';
}
});

// Clear all inventory item selections
document.querySelectorAll('.inventory-btn').forEach(btn => {
btn.classList.remove('action-mode-selected');
});

// Reset activate button text
updateActivateButton();

needsRedraw = true;

log('Action mode cancelled.',
'info');
}

function hasLineOfSight(ax, ay, bx, by) {
let x = ax,
y = ay;
const dx = Math.sign(bx - ax),
dy = Math.sign(by - ay);
while (x !== bx || y !== by) {
x += dx; y += dy;
if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT) return false;
if (dungeon.tiles[y][x] === '#') return false;
}
return true;
}

function pickCardinalDirection(ax, ay, bx, by) {
const dx = bx - ax,
dy = by - ay;
if (Math.abs(dx) >= Math.abs(dy)) return {
dx: Math.sign(dx),
dy: 0
};
return {
dx: 0,
dy: Math.sign(dy)};
}

const actionHandlers = {
disarm: (dx, dy) => {
const targetX = player.x + dx;
const targetY = player.y + dy;
const trap = traps.find(t => t.x === targetX && t.y === targetY && !t.hidden);

if (!trap) {
log('There is no trap there.', 'info');
return;
}

if (!safeSpendAP(150, 'disarm trap', true)) return;

const baseChance = 40;
const roleBonus = player.disarmBonus || 0;
const depthPenalty = dungeonLevel * 10;
const successChance = Math.max(10, baseChance + roleBonus - depthPenalty);

if (Math.random() * 100 < successChance) {
log(`You successfully disarm the ${trap.name}!`, 'pickup');
traps = traps.filter(t => t !== trap);
gainXp(5);
} else {
log(`You fail to disarm the ${trap.name}!`, 'damage');
if (Math.random() < 0.5) {
log('The trap triggers!', 'damage');
if (trap.damage) takeDamage(trap.damage);
if (trap.teleport) teleportPlayer();
if (trap.poison) player.poisonTurns += trap.poison;
}
}
processTurn();
},

apply: (dx, dy) => {
  if (!currentActionContext?.item) {
    log('No tool selected to apply!', 'damage');
    return;
  }

  const tool = currentActionContext.item;

  if (tool.baseName === 'pick-axe') {
    if (!safeSpendAP(AP_COSTS.APPLY, 'use pick-axe', true)) return;

    const targetX = player.x + dx;
    const targetY = player.y + dy;

    if (targetX < 0 || targetX >= WIDTH || targetY < 0 || targetY >= HEIGHT) {
      log('You cannot dig there.', 'info');
      processTurn();
      return;
    }

    const targetTile = dungeon.tiles[targetY][targetX];
    
    // Check for environmental objects first
    const targetEnv = environmentals.find(e => e.x === targetX && e.y === targetY);
    if (targetEnv && targetEnv.breakable) {
      const damage = calculateDamage(player, {defense: 0});
      targetEnv.hp -= damage;
      log(`You strike the ${targetEnv.name} with your pick-axe for ${damage} damage! (${targetEnv.hp}/${targetEnv.maxHp} HP)`, 'damage');
      
      if (targetEnv.hp <= 0) {
        destroyEnvironmental(targetEnv);
      }
      
      processTurn();
      return;
    }

    if (targetTile === '#') {
      dungeon.tiles[targetY][targetX] = '.';
      log('You dig through the wall!', 'pickup');

      if (Math.random() < 0.15) {
        const roll = Math.random();
        if (roll < 0.5) {
          const goldValue = rollDice(2, 10, dungeonLevel * 5);
          items.push({
            x: targetX, y: targetY, glyph: '$', name: 'gold',
            color: '#ff0', value: goldValue, identified: true,
            type: 'gold', baseName: 'gold'
          });
          log(`You found ${goldValue} gold in the rubble!`, 'pickup');
        } else if (roll < 0.8) {
          const validItems = ITEM_TYPES.filter(i => !i.isStairs && i.depth <= dungeonLevel);
          const itemType = validItems[Math.floor(Math.random() * validItems.length)];
          const newItem = {
            ...itemType,
            x: targetX,
            y: targetY,
            name: itemType.identified ? (itemType.baseName || itemType.name):
            (itemType.visualName || itemType.baseName || itemType.name),
            identified: itemType.identified || false,
            status: generateItemStatus()
          };
          items.push(newItem);
          log(`You uncover a ${newItem.name}!`, 'pickup');
        } else {
          const spawnType = MONSTER_TYPES.find(t => t.name === 'kobold') || MONSTER_TYPES[0];
          monsters.push({
            x: targetX, y: targetY, ...spawnType,
            maxHp: spawnType.hp, ap: 0, state: 'chasing', weapon: null
          });
          log('Your digging has disturbed a creature!', 'damage');
        }
      }

      computeFOV(player.x, player.y, getVisionRadius());
      needsRedraw = true;
    } else if (targetTile === '+') {
      const door = dungeon.features.find(f => f.x === targetX && f.y === targetY && f.type === 'door');
      if (door) {
        door.open = true;
        door.locked = false;
        dungeon.tiles[targetY][targetX] = '\'';
        log('You smash the door open with your pick-axe!', 'pickup');
        needsRedraw = true;
      }
    } else {
      log('There is nothing to dig here.', 'info');
    }

    processTurn();
  } else {
    log(`You don't know how to apply the ${tool.name}.`, 'info');
  }
},

kick: (dx, dy) => {
if (!safeSpendAP(AP_COSTS.KICK, 'kick', true)) return;

const targetX = player.x + dx;
const targetY = player.y + dy;

const monster = monsters.find(m => m.x === targetX && m.y === targetY);
const door = dungeon.features.find(f => f.x === targetX && f.y === targetY && f.type === 'door');

if (monster) {
const damage = rollDice(1, 2);
monster.hp -= damage;
log(`You kick the ${monster.name} for ${damage} damage!`, 'damage');
if (monster.hp <= 0) {
handleEntityDeath(player, monster);
}
} else if (door && !door.open) {
if (door.locked && Math.random() < 0.25) {
door.open = true;
door.locked = false;
dungeon.tiles[targetY][targetX] = '\'';
log('You kick the door open!', 'pickup');
needsRedraw = true;
} else if (!door.locked) {
door.open = true;
dungeon.tiles[targetY][targetX] = '\'';
log('You kick the door open!', 'pickup');
needsRedraw = true;
} else {
log('CRUNCH! The door splinters but holds.', 'info');
}
} else {
log('You kick at the empty air.', 'info');
}

processTurn();
},

throw: (dx, dy) => {
if (!currentActionContext?.item) {
log('No item selected to throw!', 'damage');
return;
}
const item = currentActionContext.item;
if (!safeSpendAP(AP_COSTS.THROW, 'throw', true)) return;

let tx = player.x;
let ty = player.y;
let hitMonster = null;
let lastValidX = tx;
let lastValidY = ty;

while (true) {
tx += dx;
ty += dy;
if (tx < 0 || tx >= WIDTH || ty < 0 || ty >= HEIGHT) break;

const tile = dungeon.tiles[ty][tx];
if (tile === '#' || tile === ' ') break;
lastValidX = tx;
lastValidY = ty;

hitMonster = monsters.find(m => m.x === tx && m.y === ty);
if (hitMonster) break;
}

if (hitMonster) {
const base = item.damage || 2;
const damage = rollDice(1, Math.max(2, base));
takeMonsterDamage(hitMonster, damage, 'physical', player);
log(`You throw ${getItemDisplayName(item)} and hit ${hitMonster.name} for ${damage} damage!`, 'damage');
if (hitMonster.hp <= 0) handleEntityDeath(player, hitMonster);
else applyItemEffectToMonster(item, hitMonster);
} else if (item.type === 'potion') {
const landingEntity = [...monsters,
...pets].find(e => e.x === lastValidX && e.y === lastValidY);
if (landingEntity) {
log(`The ${getItemDisplayName(item)} splashes on ${landingEntity.name}!`, 'info');
} else if (lastValidX === player.x && lastValidY === player.y) {
log(`The ${getItemDisplayName(item)} splashes at your feet!`, 'info');
} else {
log(`The ${getItemDisplayName(item)} splashes on the floor.`, 'info');
}
} else {
log(`You throw ${getItemDisplayName(item)}, but it lands on the ground.`, 'info');
}

applyThrownItemEffects(item, lastValidX, lastValidY);

if (item === player.weapon) player.weapon = null;
if (item === player.armor) player.armor = null;

if (item.stackable && item.count > 1) {
item.count--;
} else {
player.inventory = player.inventory.filter(i => i !== item);

if (item.type === 'potion' || item.type === 'scroll') {
log(`The ${getItemDisplayName(item)} shatters!`, 'damage');
} else if (item.stackable) {
if (Math.random() < 0.5) {
log(`The ${getItemDisplayName(item)} breaks.`, 'damage');
} else {
item.x = lastValidX;
item.y = lastValidY;
items.push(item);
}
} else {
item.x = lastValidX;
item.y = lastValidY;
items.push(item);
}
}

updateStats();
processTurn();
},

zap: (dx, dy) => {
if (!currentActionContext?.item || currentActionContext.item.type !== 'wand') {
log('No wand selected to zap!', 'damage');
return;
}

const wand = currentActionContext.item;

if (wand.charges <= 0) {
log(`Your ${getItemDisplayName(wand)} crumbles to dust.`, 'damage');
const idx = player.inventory.indexOf(wand);
if (idx > -1) player.inventory.splice(idx, 1);
processTurn();
return;
}

if (!safeSpendAP(AP_COSTS.ZAP, 'zap', true)) return;
wand.charges--;

const beamPath = traceLine(player.x, player.y, dx, dy, 12);
let hitMonster = null;

for (const {
x, y
} of beamPath) {
hitMonster = monsters.find(m => m.x === x && m.y === y);
if (hitMonster) break;
}

if (hitMonster) {
switch (wand.effect) {
case 'strike': {
const damage = rollDice(2, 6);
takeMonsterDamage(hitMonster, damage, 'shock', player);
log(`Your ${getItemDisplayName(wand)} strikes ${hitMonster.name} for ${damage} damage!`, 'damage');
if (hitMonster.hp <= 0) handleEntityDeath(player, hitMonster);
break;
}
case 'teleport': {
teleportMonster(hitMonster);
log(`${hitMonster.name} vanishes!`, 'pickup');
break;
}
default:
log(`Nothing happens...`, 'info');
break;
}
} else {
log('The beam fizzles out harmlessly.', 'info');
}

identifyItem(wand);
updateStats();
processTurn();
},

shoot: (dx, dy) => {
if (!player.rangedWeapon || !player.rangedWeapon.equipped) {
log('You have no ranged weapon equipped!', 'damage');
return;
}

const bow = player.rangedWeapon;
const ammoType = bow.ammoType || 'arrows';
let ammoSource = null;
const quiverKey = ammoType;

if (player.quiver[quiverKey] > 0) {
ammoSource = 'quiver';
} else {
const ammoItem = player.inventory.find(i =>
i.type === 'ammo' &&
(i.baseName === ammoType || i.name === ammoType) &&
(i.count || 1) > 0
);

if (!ammoItem) {
log(`You have no ${ammoType}!`, 'damage');
return;
}
ammoSource = ammoItem;
}

if (!safeSpendAP(AP_COSTS.SHOOT, 'shoot', false)) return;

if (ammoSource === 'quiver') {
player.quiver[quiverKey]--;
log(`(Quiver: ${player.quiver[quiverKey]}/${player.quiver.capacity} ${ammoType} remaining)`, 'info');
} else {
ammoSource.count = (ammoSource.count || 1) - 1;
if (ammoSource.count <= 0) {
player.inventory = player.inventory.filter(i => i !== ammoSource);
}
}

const arrowPath = traceLine(player.x, player.y, dx, dy, bow.range || 8);
let hitMonster = null;
let finalX = player.x;
let finalY = player.y;

for (const {
x, y
} of arrowPath) {
finalX = x;
finalY = y;

hitMonster = monsters.find(m => m.x === x && m.y === y);
if (hitMonster) break;
}

if (hitMonster) {
const damage = rollDice(1, bow.damage);
takeMonsterDamage(hitMonster, damage, 'piercing', player);
log(`Your arrow strikes ${hitMonster.name} for ${damage} damage!`, 'damage');

if (hitMonster.hp <= 0) {
handleEntityDeath(player, hitMonster);
}

if (Math.random() < 0.3) {
items.push({
glyph: '{',
baseName: ammoType,
name: ammoType,
color: '#CD853F',
type: 'ammo',
stackable: true,
identified: true,
count: 1,
x: hitMonster.x,
y: hitMonster.y
});
}
} else {
log('Your arrow misses and is lost.', 'info');
}

updateStats();
autoRefillQuiver();
processTurn();
}
};

function applyThrownItemEffects(item, x, y) {
if (!item.effect) return;

const resolvedEffect = typeof item.effect === 'string' ? EFFECT_TYPES[item.effect]: item.effect;
if (!resolvedEffect) return;

if (resolvedEffect.damage && resolvedEffect.turns && resolvedEffect.spreadChance !== undefined) {
dungeon.features.push({
x: x,
y: y,
type: 'fire',
glyph: '}',
color: '#f80',
spreadChance: resolvedEffect.spreadChance,
damage: resolvedEffect.damage,
duration: rollDice(1, 3, 2)
});
dungeon.tiles[y][x] = '}';
log('The potion shatters in a burst of flames!', 'damage');

if (player.x === x && player.y === y) {
takeDamage(resolvedEffect.damage);
player.burnTurns = (player.burnTurns || 0) + resolvedEffect.turns;
log('You are caught in the flames!', 'damage');
}

const hitMonster = monsters.find(m => m.x === x && m.y === y);
if (hitMonster) {
hitMonster.hp -= resolvedEffect.damage;
hitMonster.burnTurns = (hitMonster.burnTurns || 0) + resolvedEffect.turns;
log(`${hitMonster.name} is set ablaze!`, 'damage');
if (hitMonster.hp <= 0) handleEntityDeath(player, hitMonster);
}

needsRedraw = true;
identifyItem(item);
}

if (resolvedEffect.confusion) {
const hitMonster = monsters.find(m => m.x === x && m.y === y);
if (hitMonster) {
hitMonster.confusionTurns = (hitMonster.confusionTurns || 0) + resolvedEffect.confusion;
log(`${hitMonster.name} looks confused!`, 'damage');
identifyItem(item);
}

const hitPet = pets.find(p => p.x === x && p.y === y);
if (hitPet) {
applyThrownEffectToEntity(item, hitPet);
}
}

const hitPet = pets.find(p => p.x === x && p.y === y);
if (hitPet && item.effect && !resolvedEffect.confusion) {
applyThrownEffectToEntity(item, hitPet);
}
}

function executeActionWithDirection(dx, dy) {
if (!currentActionContext) return;

const action = currentActionContext.action;
const handler = actionHandlers[action];

if (handler) {
handler(dx, dy);
cancelActionModes(); // ← Always clean up after execution
} else {
log(`Unknown action: ${action}`, 'damage');
cancelActionModes();
}
}

function handleInventoryClick(event, item) {
if (currentActionContext) {
currentActionContext.item = item;
log(`Selected ${getItemDisplayName(item)} to ${currentActionContext.action}. Choose a direction.`, 'info');
updateStats();
} else {
if (itemAction === 'use') useItem(item);
else dropItem(item);
}
}

function waitAction() {
if (player.paralyzedTurns > 0) {
log('You are paralyzed!', 'damage');
processTurn();
return;
} else {
log('You wait a moment.', 'info');
processTurn();
}
}
function doSearch() {
if (!safeSpendAP(AP_COSTS.SEARCH, 'search', true)) return;

let foundSomething = false;

for (let dy = -1; dy <= 1; dy++) for (let dx = -1; dx <= 1; dx++) {
const tx = player.x + dx;
const ty = player.y + dy;

const trap = traps.find(t => t.x === tx && t.y === ty && t.hidden);
if (trap && Math.random() < 0.60) {
trap.hidden = false;
log(`You found a hidden ${trap.name}!`, 'pickup');
needsRedraw = true;
foundSomething = true;
}

const secretDoor = dungeon.features.find(f => f.x === tx && f.y === ty && f.type === 'door' && f.locked && !f.discovered);
if (secretDoor && Math.random() < 0.50) {
secretDoor.discovered = true;
log('You found a secret door!', 'pickup');
needsRedraw = true;
foundSomething = true;
}

const hiddenItem = items.find(i => i.x === tx && i.y === ty && i.hidden);
if (hiddenItem && Math.random() < 0.70) {
hiddenItem.hidden = false;
log(`You found a hidden ${hiddenItem.name}!`, 'pickup');
needsRedraw = true;
foundSomething = true;
}

if (!foundSomething && dungeon.tiles[ty][tx] === '.' && Math.random() < 0.01) {
const validItems = ITEM_TYPES.filter(i => !i.isStairs && i.depth <= dungeonLevel);
const itemType = validItems[Math.floor(Math.random() * validItems.length)];

const newItem = {
...itemType,
x: tx,
y: ty,
name: itemType.identified ? (itemType.baseName || itemType.name): (itemType.visualName || itemType.baseName || itemType.name),
identified: itemType.identified || false,
status: generateItemStatus()
};

if (newItem.name === 'gold') newItem.value = rollDice(1, Math.floor(10 * dungeonLevel), 5);
if (newItem.type === 'wand') newItem.charges = rollDice(1, 4, 1);

items.push(newItem);
log(`You discover a ${newItem.name} tucked away!`, 'pickup');
needsRedraw = true;
foundSomething = true;
}
}

if (!foundSomething) log('You search the immediate area, finding nothing.', 'info');
processTurn();
}

let currentShop = null;
let shopMode = 'buy';

function openShop(shop) {
if (shop.shopkeeperAngry) {
log('The shopkeeper refuses to deal with you!', 'damage');
return;
}

currentShop = shop;
shopMode = 'buy';

document.getElementById('shop-depth').textContent = dungeonLevel;
document.getElementById('shop-player-gold').textContent = player.gold;
document.getElementById('shop-modal').classList.add('show');
updateShopDisplay();
}

function updateShopDisplay() {
const itemList = document.getElementById('shop-item-list');
const buyTab = document.getElementById('shop-buy-tab');
const sellTab = document.getElementById('shop-sell-tab');
const stealTab = document.getElementById('shop-steal-tab');
const statusDiv = document.getElementById('shop-status');

// Reset tab styles
[buyTab,
sellTab,
stealTab].forEach(btn => {
btn.style.background = '#002200';
btn.style.borderColor = '#0f0';
});

// Highlight active tab
if (shopMode === 'buy') {
buyTab.style.background = '#004400';
buyTab.style.borderColor = '#0ff';
} else if (shopMode === 'sell') {
sellTab.style.background = '#004400';
sellTab.style.borderColor = '#0ff';
} else if (shopMode === 'steal') {
stealTab.style.background = '#004400';
stealTab.style.borderColor = '#0ff';
}

// ✅ FIX 3: Remove old delegated listener if it exists
if (itemList._shopClickHandler) {
itemList.removeEventListener('click', itemList._shopClickHandler);
delete itemList._shopClickHandler;
}

// Clear item list
itemList.innerHTML = '';

// === STEAL TAB ===
if (shopMode === 'steal') {
if (!player.role || player.role !== 'Rogue') {
itemList.innerHTML = '<div style="color: #f00; text-align: center; padding: 20px;">Only Rogues can steal!</div>';
statusDiv.textContent = 'You lack the necessary skills';
return;
}

if (currentShop.inventory.length === 0) {
itemList.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">Nothing left to steal</div>';
statusDiv.textContent = 'Shop is empty';
return;
}

const baseChance = 40;
const levelBonus = player.level * 5;
const skillBonus = player.disarmBonus || 0;
const angryPenalty = currentShop.shopkeeperAngry ? 10: 0;
const successChance = Math.min(75, baseChance + levelBonus + skillBonus - angryPenalty);

currentShop.inventory.forEach((item, index) => {
const itemDiv = document.createElement('div');
itemDiv.dataset.itemIndex = index;
itemDiv.dataset.shopMode = 'steal';
itemDiv.style.cssText = `
padding: 8px;
margin-bottom: 6px;
background: #220000;
border: 2px solid #f00;
border-radius: 4px;
cursor: pointer;
transition: all 0.2s;
`;

const itemName = getItemDisplayName(item);
const price = calculatePrice(item, dungeonLevel);

itemDiv.innerHTML = `
<div style="display: flex; justify-content: space-between; align-items: center;">
<div style="flex: 1;">
<div style="font-size: 15px;">${itemName}</div>
<div style="font-size: 10px; color: #888; margin-top: 2px;">Worth ${price}g</div>
</div>
<div style="text-align: right;">
<div style="font-size: 12px; color: ${successChance >= 60 ? '#ff0': '#f00'};">
${successChance}% chance
</div>
<div style="font-size: 10px; color: #f00;">Attempt steal</div>
</div>
</div>
`;

itemList.appendChild(itemDiv);
});

statusDiv.textContent = `Steal chance: ${successChance}% (Level ${player.level} Rogue)`;
}
// === BUY TAB ===
else if (shopMode === 'buy') {
if (currentShop.inventory.length === 0) {
itemList.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">Shop is empty</div>';
statusDiv.textContent = 'Nothing left to buy';
return;
}

currentShop.inventory.forEach((item, index) => {
const price = calculatePrice(item, dungeonLevel);
const canAfford = player.gold >= price;

const itemDiv = document.createElement('div');
itemDiv.dataset.itemIndex = index;
itemDiv.dataset.shopMode = 'buy';
itemDiv.style.cssText = `
padding: 8px;
margin-bottom: 6px;
background: ${canAfford ? '#002200': '#220000'};
border: 2px solid ${canAfford ? '#0f0': '#500'};
border-radius: 4px;
cursor: ${canAfford ? 'pointer': 'not-allowed'};
opacity: ${canAfford ? '1': '0.6'};
transition: all 0.2s;
`;

const itemName = getItemDisplayName(item);
const statusBadge = item.status !== 'Normal'
? `<span style="color: ${item.status === 'Blessed' ? '#0ff': '#f00'};">[${item.status}]</span> `: '';

itemDiv.innerHTML = `
<div style="display: flex; justify-content: space-between; align-items: center;">
<div style="flex: 1;">
<div style="font-size: 13px;">${statusBadge}${itemName}</div>
<div style="font-size: 10px; color: #888; margin-top: 2px;">${item.type}</div>
</div>
<div style="text-align: right;">
<div style="font-size: 14px; font-weight: bold; color: #ff0;">${price}g</div>
${canAfford
? '<div style="font-size: 10px; color: #0f0;">Click to buy</div>': '<div style="font-size: 10px; color: #f00;">Too expensive</div>'}
</div>
</div>
`;

itemList.appendChild(itemDiv);
});

statusDiv.textContent = `${currentShop.inventory.length} items available`;
}
// === SELL TAB ===
else if (shopMode === 'sell') {
const sellableItems = player.inventory.filter(i =>
i.type !== 'ammo' || !hasQuiverEquipped()
);

if (sellableItems.length === 0) {
itemList.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">Nothing to sell</div>';
statusDiv.textContent = 'Your inventory is empty';
return;
}

sellableItems.forEach((item, index) => {
const sellPrice = calculateSellPrice(item, dungeonLevel);
const canSell = sellPrice > 0;

const itemDiv = document.createElement('div');
itemDiv.dataset.itemIndex = player.inventory.indexOf(item); // Use global inventory index
itemDiv.dataset.shopMode = 'sell';
itemDiv.style.cssText = `
padding: 8px;
margin-bottom: 6px;
background: ${canSell ? '#002200': '#220000'};
border: 2px solid ${canSell ? '#0f0': '#500'};
border-radius: 4px;
cursor: ${canSell ? 'pointer': 'not-allowed'};
opacity: ${canSell ? '1': '0.6'};
transition: all 0.2s;
`;

const itemName = getItemDisplayName(item);
const equippedBadge = item.equipped ? '<span style="color: #0af;">[E]</span> ': '';

itemDiv.innerHTML = `
<div style="display: flex; justify-content: space-between; align-items: center;">
<div style="flex: 1;">
<div style="font-size: 13px;">${equippedBadge}${itemName}</div>
<div style="font-size: 10px; color: #888; margin-top: 2px;">${item.type}</div>
</div>
<div style="text-align: right;">
${canSell
? `<div style="font-size: 14px; font-weight: bold; color: #0f0;">+${sellPrice}g</div>
<div style="font-size: 10px; color: #0f0;">Click to sell</div>`: `<div style="font-size: 11px; color: #f00;">Refused</div>`
}
</div>
</div>
`;

itemList.appendChild(itemDiv);
});

statusDiv.textContent = `${sellableItems.length} items in your inventory`;
}

// ✅ FIX 3: Single delegated click handler for all items
itemList._shopClickHandler = (e) => {
const itemDiv = e.target.closest('[data-item-index]');
if (!itemDiv) return;

const index = parseInt(itemDiv.dataset.itemIndex);
const mode = itemDiv.dataset.shopMode;

if (mode === 'buy') {
const item = currentShop.inventory[index];
const price = calculatePrice(item, dungeonLevel);
if (player.gold >= price) {
buyItem(item, price, index);
}
} else if (mode === 'sell') {
const item = player.inventory[index];
const price = calculateSellPrice(item, dungeonLevel);
if (price > 0) {
sellItem(item, price);
}
} else if (mode === 'steal') {
const item = currentShop.inventory[index];
const baseChance = 40;
const levelBonus = player.level * 5;
const skillBonus = player.disarmBonus || 0;
const angryPenalty = currentShop.shopkeeperAngry ? 10: 0;
const successChance = Math.min(75, baseChance + levelBonus + skillBonus - angryPenalty);
attemptSteal(item, successChance, index);
}
};

itemList.addEventListener('click', itemList._shopClickHandler);
}

function openEnchanterShop() {
  const modal = document.getElementById('enchant-shop-modal');
  document.getElementById('enchant-gold').textContent = player.gold;
  
  const equipList = document.getElementById('enchant-equipment-list');
  equipList.innerHTML = '';
  
  const enchantableItems = player.inventory.filter(i => 
    (i.type === 'weapon' || i.type === 'armor') && i.equipped
  );
  
  if (enchantableItems.length === 0) {
    equipList.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">No equipped items to enhance.</div>';
  } else {
    enchantableItems.forEach(item => {
      const itemDiv = document.createElement('button');
      itemDiv.className = 'modal-btn';
      itemDiv.style.cssText = `
        text-align: left;
        padding: 10px;
        background: #002200;
        cursor: pointer;
      `;
      
      itemDiv.innerHTML = `
        <div style="font-weight: bold;">${getItemDisplayName(item)}</div>
        <div style="font-size: 11px; color: #888; margin-top: 2px;">
          ${item.type === 'weapon' ? `Damage: ${item.damage}` : `DR: ${item.defense}`}
          ${item.upgradeLevel ? ` | +${item.upgradeLevel}` : ''}
          ${item.enchantment ? ` | ${ENCHANTMENT_TYPES[item.enchantment].name}` : ''}
        </div>
      `;
      
      itemDiv.addEventListener('click', () => {
        modal.classList.remove('show');
        showEnchantmentModal(item);
      });
      
      equipList.appendChild(itemDiv);
    });
  }
  
  modal.classList.add('show');
}

document.getElementById('close-enchant-shop').addEventListener('click', () => {
  document.getElementById('enchant-shop-modal').classList.remove('show');
});

function calculatePrice(item, depth) {
const priceRatio = item.basePrice !== undefined ? item.basePrice: 1.0;

let shopPrice = Math.floor(10 * priceRatio);

if (item.status === 'Blessed') shopPrice = Math.floor(shopPrice * 1.5);
if (item.status === 'Cursed') shopPrice = Math.floor(shopPrice * 0.3);

shopPrice += depth * 5;

if (item.stackable && item.quantity > 1) {
shopPrice *= item.quantity;
}

return Math.max(1, shopPrice);
}

function addItemToInventory(item) {
if (item.type === 'ammo') {
    const existingAmmo = player.inventory.find(i => i.baseName === item.baseName && i.type === 'ammo');
    if (existingAmmo) {
        existingAmmo.count = (existingAmmo.count || 1) + (item.count || 1);
        log(`You picked up ${item.count || 1} ${getItemDisplayName(item)} (total: ${existingAmmo.count}).`, 'pickup');
        items = items.filter(i => i !== item);
        autoRefillQuiver();
    } else if (player.inventory.length < player.inventoryMaxItems) {
        player.inventory.push(item);
        log(`You picked up ${item.count || 1} ${getItemDisplayName(item)}.`, 'pickup');
        items = items.filter(i => i !== item);
        autoRefillQuiver();
    } else {
        log(`Inventory full. You can't pick up the ${getItemDisplayName(item)}.`, 'damage');
    }
}

if (player.inventory.length < player.inventoryMaxItems) {
player.inventory.push(item);
} else {
log('Your inventory is full!', 'damage');
}
}

function autoRefillQuiver() {
    const quiver = player.accessory && player.accessory.baseName === 'quiver'
        ? player.accessory : null;
    if (!quiver) return;

    const capacity = quiver.quiverCapacity || 0;
    if (capacity === 0) return;

    if (typeof quiver.arrows !== 'number') quiver.arrows = 0;
    if (typeof quiver.bolts !== 'number') quiver.bolts = 0;

    // ✅ FIX: Check TOTAL capacity, not per-type
    const currentTotal = quiver.arrows + quiver.bolts;
    const availableSpace = capacity - currentTotal;

    if (availableSpace <= 0) {
        return; // Quiver is full
    }

    // Try to refill arrows first
    if (quiver.arrows < capacity) {
        const arrowStack = player.inventory.find(i => i.baseName === 'arrows' && i.count > 0);
        if (arrowStack) {
            const toTransfer = Math.min(availableSpace, arrowStack.count);
            quiver.arrows += toTransfer;
            arrowStack.count -= toTransfer;
            if (arrowStack.count <= 0) {
                player.inventory = player.inventory.filter(i => i !== arrowStack);
            }
            log(`Quiver refilled: +${toTransfer} arrows (${quiver.arrows + quiver.bolts}/${capacity})`, 'pickup');
        }
    }

    // Recalculate available space after arrows
    const newTotal = quiver.arrows + quiver.bolts;
    const newAvailableSpace = capacity - newTotal;

    // Try to refill bolts with remaining space
    if (newAvailableSpace > 0 && quiver.bolts < capacity) {
        const boltStack = player.inventory.find(i => i.baseName === 'bolts' && i.count > 0);
        if (boltStack) {
            const toTransfer = Math.min(newAvailableSpace, boltStack.count);
            quiver.bolts += toTransfer;
            boltStack.count -= toTransfer;
            if (boltStack.count <= 0) {
                player.inventory = player.inventory.filter(i => i !== boltStack);
            }
            log(`Quiver refilled: +${toTransfer} bolts (${quiver.arrows + quiver.bolts}/${capacity})`, 'pickup');
        }
    }
    
    updateStats();
}

function calculateSellPrice(item, shopDepth) {
const buyPrice = calculatePrice(item, shopDepth);
let sellPrice = Math.floor(buyPrice * 0.4);

if (item.status === 'Cursed') {
if (Math.random() < 0.5) return 0;
sellPrice = Math.floor(buyPrice * 0.1);
}

if (!item.identified) {
sellPrice = Math.floor(sellPrice * 0.5);
}

return Math.max(1, sellPrice);
}

function getItemDescription(item) {
const descriptions = {
'weapon': `Melee weapon, ${item.damage} damage`,
'ranged_weapon': `Ranged weapon, ${item.damage} damage, range ${item.range}`,
'armor': `Armor, +${item.defense} DR`,
'potion': 'Consumable potion',
'scroll': 'Single-use scroll',
'food': `Food, +${item.nutrition} nutrition`,
'wand': `Wand with ${item.charges} charges`,
'tool': 'Utility tool',
'accessory': 'Worn accessory'
};
return descriptions[item.type] || 'Mysterious item';
}

function buyItem(item, price, index) {
if (player.gold < price) {
log('You cannot afford that!', 'damage');
return;
}

if (player.inventory.length >= player.inventoryMaxItems && !item.stackable) {
log('Your inventory is full!', 'damage');
return;
}

player.gold -= price;
currentShop.inventory.splice(index, 1);

addItemToInventory({
...item
});
log(`You bought ${getItemDisplayName(item)} for ${price} gold.`, 'pickup');
document.getElementById('shop-player-gold').textContent = player.gold;
updateStats();
updateShopDisplay();
}

function sellItem(item, price) {
if (item.equipped && item.status === 'Cursed') {
log('You cannot remove the cursed item!', 'damage');
return;
}

player.gold += price;

if (item.equipped) {
if (item.type === 'weapon') player.weapon = null;
if (item.type === 'armor') player.armor = null;
if (item.type === 'ranged_weapon') player.rangedWeapon = null;
if (item.type === 'accessory') player.accessory = null;
item.equipped = false;
}

currentShop.inventory.push({
...item, identified: true
});
player.inventory = player.inventory.filter(i => i !== item);

log(`You sold ${getItemDisplayName(item)} for ${price} gold.`, 'pickup');
document.getElementById('shop-player-gold').textContent = player.gold;
updateStats();
updateShopDisplay();
}

function spawnGuardsAtPlayer() {
const count = 2 + Math.floor(Math.random() * 2);

for (let i = 0; i < count; i++) {
const guardType = MONSTER_TYPES.find(t => t.name === 'orc') || MONSTER_TYPES[4];
const pos = findWalkableAdjacent(player.x, player.y);
if (!pos) continue;

monsters.push({
...pos,
...guardType,
name: 'angry guard',
maxHp: guardType.hp + 5 + dungeonLevel,
hp: guardType.hp + 5 + dungeonLevel,
damage: (guardType.damage || 3) + Math.floor(dungeonLevel / 2),
ap: 0,
state: 'chasing',
weapon: null
});
}
}

function attemptSteal(item, successChance, index) {
// Use the successChance parameter that was calculated in updateShopDisplay
// This ensures consistency between displayed and actual chances

if (Math.random() * 100 < successChance) {
// Success: steal the item
currentShop.inventory.splice(index, 1);
addItemToInventory({
...item,
identified: true
});
log(`You successfully stole ${getItemDisplayName(item)}!`, 'pickup');
updateStats();
updateShopDisplay();

// Don't immediately close shop or process turn on success
// Let player continue stealing or leave voluntarily

} else {
// Failure: anger shopkeeper and spawn guards
currentShop.shopkeeperAngry = true;
log('The shopkeeper catches you! Guards attack!', 'damage');
document.getElementById('shop-modal').classList.remove('show');
spawnGuardsAtPlayer();
processTurn();
}
}

function getAvailableAmmo(ammoType) {
let ammo = player.inventory.find(i =>
i.type === 'ammo' &&
(i.ammoType === ammoType || i.baseName === ammoType || i.name === ammoType) &&
(i.count || 0) > 0
);
if (ammo) return {
item: ammo,
source: 'inventory'
};

const quiver = player.inventory.find(i => i.baseName === 'quiver' && i.equipped);
if (quiver) {
if (ammoType === 'arrows' && quiver.arrows > 0) {
return {
item: {
baseName: 'arrows',
type: 'ammo',
count: quiver.arrows
},
source: 'quiver'
};
}
if (ammoType === 'bolts' && quiver.bolts > 0) {
return {
item: {
baseName: 'bolts',
type: 'ammo',
count: quiver.bolts
},
source: 'quiver'
};
}
}

return null;
}

function hasQuiverEquipped() {
return player.accessory &&
player.accessory.baseName === 'quiver' &&
player.accessory.equipped;
}


function isStairsAt(x, y) {
const tileIsStairs = dungeon.tiles?.[y]?.[x] === '>';
const itemIsStairs = items.some(i => i.x === x && i.y === y && i.isStairs);

if (tileIsStairs || itemIsStairs) {
return true;
}
return false;
}

function movePlayer(dx, dy) {
// Look / aim mode
if (player.isLooking) {
moveLookCursor(dx, dy);
updateActivateButton();
return;
}

// Paralyzed
if (player.paralyzedTurns > 0) {
log('You are paralyzed!', 'damage');
processTurn();
return;
}

// Not enough AP
if (player.ap < AP_COSTS.MOVE) {
log('Not enough AP to move!', 'damage');
return;
}

// Calculate new position
let newX = player.x + dx;
let newY = player.y + dy;

// Confusion
if (player.confusionTurns > 0) {
newX = player.x + Math.floor(Math.random() * 3) - 1;
newY = player.y + Math.floor(Math.random() * 3) - 1;
}

// Out of bounds
if (newX < 0 || newX >= WIDTH || newY < 0 || newY >= HEIGHT) return;

const targetTile = dungeon.tiles[newY][newX];
const door = dungeon.features.find(f => f.x === newX && f.y === newY && f.type === 'door');

// Wall
if (targetTile === '#') {
log('You bump into the wall.', 'info');
return;
}

// Door handling
if (door && !door.open) {
if (door.locked) {
const key = player.inventory.find(i => i.type === 'key');
if (key) {
door.locked = false;
log('You unlock the door.', 'pickup');
player.inventory.splice(player.inventory.indexOf(key), 1);
} else {
log('The door is locked! You try to bash it down.', 'damage');
if (!safeSpendAP(AP_COSTS.BASH_DOOR, 'bash door', true)) return;
if (Math.random() < 0.3) {
door.open = true;
dungeon.tiles[newY][newX] = '\'';
log('The door breaks open!', 'pickup');
} else log('The door holds firm.', 'info');
processTurn();
return;
}
} else {
if (!safeSpendAP(AP_COSTS.OPEN_DOOR, 'open door', true)) return;
door.open = true;
dungeon.tiles[newY][newX] = '\'';
log('You open the door.', 'info');
}
return;
}

// Environmental objects - only block if they're barriers/hazards
const environmental = getEnvironmentalAt(newX, newY);
if (environmental) {
  // Containers are walkable - just interact if closed
  if (environmental.type === 'container') {
    if (!environmental.isOpen) {
      // Try to open it
      handleEnvironmentalInteraction(environmental, 'open');
      return;
    }
    // If already open, walk through it (fall through to normal movement)
  } 
  // Hazards damage but don't block
  else if (environmental.type === 'hazard') {
    if (environmental.bumpDamage) {
      takeDamage(environmental.bumpDamage);
      log(environmental.damageMessage || `You are hurt by the ${environmental.name}!`, 'damage');
    }
    // Continue movement anyway
  }
  // Barriers and explosives block movement
  else if (environmental.type === 'barrier' || environmental.type === 'explosive') {
    if (environmental.pushable) {
      tryPushEnvironmental(environmental);
      return;
    } else {
      log(`You bump into the ${environmental.name}.`, 'info');
      return;
    }
  }
}

// Monster
const monster = monsters.find(m => m.x === newX && m.y === newY);
if (monster) {
attack(player, monster);
processTurn();
return;
}

// Environmental object (attack if breakable)
const environmentalObj = getEnvironmentalAt(newX, newY);
if (environmentalObj && environmental.breakable) {
  attackEnvironmental(environmentalObj);
  return;
}

// Movement (allow AP debt)
safeSpendAP(AP_COSTS.MOVE, 'move', true); // allowDebt = true

// Apply movement
player.x = newX;
player.y = newY;
player.lookCursor = {
x: newX,
y: newY
};

// Traps
checkTrap(player.x, player.y);

// Items
const itemsHere = items.filter(i => i.x === player.x && i.y === player.y);
if (itemsHere.length > 0) {
log(`You see here: ${itemsHere.map(getItemDisplayName).join(', ')}.`, 'info');
}

itemsHere.slice().forEach(item => {
if (item.isStairs) return;
if (item.type === 'gold') {
player.gold += item.value;
updateScore(item.value);
log(`You picked up ${item.value} gold.`, 'pickup');
items = items.filter(i => i !== item);
} else if (item.type === 'ammo') {
const existingAmmo = player.inventory.find(i => i.baseName === item.baseName && i.type === 'ammo');
if (existingAmmo) {
existingAmmo.count = (existingAmmo.count || 1) + (item.count || 1);
log(`You picked up ${item.count || 1} ${getItemDisplayName(item)} (total: ${existingAmmo.count}).`, 'pickup');
items = items.filter(i => i !== item);
} else if (player.inventory.length < player.inventoryMaxItems) {
player.inventory.push(item);
log(`You picked up ${item.count || 1} ${getItemDisplayName(item)}.`, 'pickup');
items = items.filter(i => i !== item);
} else {
log(`Inventory full. You can't pick up the ${getItemDisplayName(item)}.`, 'damage');
}
} else if (player.inventory.length < player.inventoryMaxItems) {
player.inventory.push(item);
log(`You picked up a ${getItemDisplayName(item)}.`, 'pickup');
items = items.filter(i => i !== item);
} else {
log(`Inventory full. You can't pick up the ${getItemDisplayName(item)}.`, 'damage');
}
});

// Shop
const shopFeature = dungeon.features.find(f => f.type === 'shop' && f.x === player.x && f.y === player.y);
if (shopFeature) {
openShop(shopFeature);
return;
}

// Enchanter: open the enchanter interface when the player steps on it
const enchanterFeature = dungeon.features.find(fe =>
  fe.type === 'enchanter' && fe.x === player.x && fe.y === player.y
);
if (enchanterFeature) {
  openEnchanterShop();
  return;
}
  
// Finish turn
processTurn();
updateActivateButton();
}

function moveLookCursor(dx, dy) {
player.lookCursor.x = Math.max(0, Math.min(WIDTH - 1, player.lookCursor.x + dx));
player.lookCursor.y = Math.max(0, Math.min(HEIGHT - 1, player.lookCursor.y + dy));

const mapX = player.lookCursor.x;
const mapY = player.lookCursor.y;

target = null;
targetName = 'the floor';
targetHP = '';

if (explored[mapY][mapX]) {
const monster = monsters.find(m => m.x === mapX && m.y === mapY && visible[mapY][mapX]);
const item = items.find(i => i.x === mapX && i.y === mapY && visible[mapY][mapX] && !i.hidden);
const pet = pets.find(p => p.x === mapX && p.y === mapY && visible[mapY][mapX]);

if (monster) {
target = monster;
targetName = `the ${monster.name}`;
targetHP = ` (HP: ${monster.hp}/${monster.maxHp})`;
} else if (pet) {
target = pet;
targetName = `your ${pet.name}`;
targetHP = ` (HP: ${pet.hp}/${pet.maxHp})`;
} else if (item) {
target = item;
targetName = `a ${getItemDisplayName(item)}`;
} else {
const feature = dungeon.features.find(f => f.x === mapX && f.y === mapY);
if (feature) {
target = feature;
targetName = `a ${feature.type}`;
} else {
const tile = dungeon.tiles[mapY][mapX];
if (tile === '#') targetName = 'a wall';
else if (tile === '.') targetName = 'the floor';
else if (tile === '>') targetName = 'stairs down';
else if (tile === '\'') targetName = 'an open door';
else if (tile === '+') targetName = 'a closed door';
else targetName = 'unremarkable terrain';
}
}
} else {
targetName = 'unexplored darkness';
}

// --- store current look target for use by look-shoot/throw/zap ---
currentActionContext = currentActionContext || {};
currentActionContext.target = target || null;

log(`You see ${targetName}${targetHP}.`, 'info');
needsRedraw = true;
}

function kick() {
log('Kick in which direction?', 'info');
currentActionContext = {
action: 'kick'
};
}

function pray() {
if (!safeSpendAP(AP_COSTS.PRAY, 'pray', true)) return;

const feature = dungeon.features.find(f => f.x === player.x && f.y === player.y && f.type === 'altar');

if (feature) {
log('You pray at the altar...', 'pickup');

if (player.canRechargeWands) {
const wands = player.inventory.filter(i => i.type === 'wand');
const depletedWand = wands.find(i => i.charges === 0);
const partialWand = wands.find(i => i.charges > 0 && i.charges < 5);

if (depletedWand || partialWand) {
const targetWand = depletedWand || partialWand;
const apCost = 200;

if (player.ap >= apCost) {
player.ap -= apCost;
const chargesAdded = rollDice(1, 3, 1);
rechargeWand(targetWand, chargesAdded);
processTurn();
return;
} else {
log(`You need ${apCost} AP to recharge. (Current: ${player.ap})`, 'damage');
processTurn();
return;
}
}
}
const roll = Math.random();
if (roll < 0.3) {
log('A divine light heals your wounds.', 'pickup');
player.hp = player.maxHp;
updateStats();
} else if (roll < 0.6) {
log('Your plea is answered with a gift!', 'pickup');
spawnItems(1);
const newItem = items[items.length - 1];
newItem.x = player.x;
newItem.y = player.y;
log(`${newItem.name} appears.`, 'pickup');
} else if (roll < 0.9) {
    log('The gods are angered! A monster appears.', 'damage');
    const roomForSpawn = dungeon.rooms[Math.floor(Math.random() * dungeon.rooms.length)];
    const pos = findWalkableAdjacent(player.x, player.y) || findWalkable(roomForSpawn);
    
    // Actually spawn the monster
    if (pos) {
        const spawnPool = MONSTER_TYPES.filter(t => t.depth <= dungeonLevel + 1);
        const monsterType = spawnPool[Math.floor(Math.random() * spawnPool.length)] || MONSTER_TYPES[0];
        
        monsters.push({
            ...monsterType,
            x: pos.x,
            y: pos.y,
            maxHp: monsterType.hp,
            hp: monsterType.hp,
            ap: monsterType.ap || 0,
            maxAP: monsterType.maxAP || 100,
            state: 'chasing', // Angry at player for angering gods
            weapon: null,
            exhaustedTurns: 0,
            poisonTurns: 0,
            confusionTurns: 0,
            speedTurns: 0,
            strengthTurns: 0,
            burnTurns: 0,
            paralyzedTurns: 0,
            lastKnownPlayerX: null,
            lastKnownPlayerY: null,
            intrinsics: monsterType.intrinsics ? {...monsterType.intrinsics} : {}
        });
        
        log(`A ${monsterType.name} appears from the divine wrath!`, 'damage');
        needsRedraw = true;
    }
} else {
log('Your prayer goes unanswered.', 'info');
}
} else {
log('You pray, but nothing happens here.', 'info');
}

processTurn();
}

function engrave() {
    if (!safeSpendAP(AP_COSTS.ENGRAVE, 'engrave', true)) return;
    
    const existingEngraving = dungeon.engravings.find(e => e.x === player.x && e.y === player.y);
    if (existingEngraving) {
        log('You add to the engraving on the floor.', 'info');
    } else {
        dungeon.engravings.push({ x: player.x, y: player.y, text: 'Elbereth' });
        dungeon.tiles[player.y][player.x] = 'E';
        log('You engrave "Elbereth" in the dust.', 'pickup');
    }
    processTurn();
}

function descendStairs() {
dungeonLevel++;
log(`You descend to depth ${dungeonLevel}.`, 'pickup');
initGame(false);
}

function checkTrap(x, y) {
const trap = traps.find(t => t.x === x && t.y === y);
if (trap) {
if (trap.hidden) {
log('You found a trap!', 'damage');
trap.hidden = false;
needsRedraw = true;
}
if (trap.damage) {
log(`You were hurt by a ${trap.name}!`, 'damage');
takeDamage(trap.damage);
} else if (trap.teleport) {
log('You are suddenly teleported!', 'damage');
teleportPlayer();
} else if (trap.poison) {
log('You feel a stinging pain... you are poisoned!', 'damage');
player.poisonTurns += trap.poison;
}
return true;
}
return false;
}

function teleportPlayer() {
let attempts = 0;
let newPos;

do {
newPos = findWalkable();
attempts++;
} while (attempts < 50 && newPos.x === player.x && newPos.y === player.y);

const sameLocation = (newPos.x === player.x && newPos.y === player.y);

player.x = newPos.x;
player.y = newPos.y;
player.lookCursor = {
x: newPos.x,
y: newPos.y
};

if (sameLocation) {
log('You vanish in a flash... and reappear in the same spot!', 'info');
} else {
log('You are suddenly teleported elsewhere!', 'info');
}

computeFOV(player.x, player.y, getVisionRadius());
updateStats();
needsRedraw = true;
}

function teleportMonster(monster) {
let attempts = 0;
let newPos;

do {
newPos = findWalkable();
attempts++;
} while (attempts < 50 && newPos.x === monster.x && newPos.y === monster.y);

const sameLocation = (newPos.x === monster.x && newPos.y === monster.y);

monster.x = newPos.x;
monster.y = newPos.y;

monster.lastKnownPlayerX = null;
monster.lastKnownPlayerY = null;
monster.state = 'wandering';

if (sameLocation) {
log(`${monster.name} vanishes in a puff of smoke... and reappears!`, 'pickup');
} else {
log(`${monster.name} vanishes in a puff of smoke!`, 'pickup');
}

needsRedraw = true;
}

function lineOfSight(x1, y1, x2, y2) {
let dx = Math.abs(x2 - x1); let dy = -Math.abs(y2 - y1);
let sx = x1 < x2 ? 1: -1; let sy = y1 < y2 ? 1: -1;
let err = dx + dy;
while (true) {
if (x1 === x2 && y1 === y2) return true;
if (dungeon.tiles[y1][x1] === '#' || dungeon.tiles[y1][x1] === '+') return false;
let e2 = 2 * err;
if (e2 >= dy) {
err += dy; x1 += sx;
}
if (e2 <= dx) {
err += dx; y1 += sy;
}
}
}

function throwProjectile(source, item, dx, dy, options = {}) {
const projectilePath = traceLine(source.x, source.y, dx, dy, 12);

for (const {
x, y
} of projectilePath) {
if (x === player.x && y === player.y) {
const base = item.damage || 2;
const damage = rollDice(1, Math.max(2, base));
takeDamage(damage);
log(`${source.name || 'Something'} hits you with a ${getItemDisplayName(item)} for ${damage} damage!`, 'damage');
return;
}

const hitPet = pets.find(p => p.x === x && p.y === y);
if (hitPet) {
const base = item.damage || 2;
const damage = rollDice(1, Math.max(2, base));
hitPet.hp -= damage;
log(`${source.name || 'Something'} hits your ${hitPet.name} with a ${getItemDisplayName(item)} for ${damage} damage!`, 'damage');
if (hitPet.hp <= 0) handleEntityDeath(source, hitPet);
return;
}

const hitMonster = monsters.find(m => m.x === x && m.y === y);
if (hitMonster) {
const base = item.damage || 2;
const damage = rollDice(1, Math.max(2, base));
takeMonsterDamage(hitMonster, damage, 'physical', player);
log(`${source.name || 'Something'} hits ${hitMonster.name} with a ${getItemDisplayName(item)} for ${damage} damage!`, 'damage');
if (hitMonster.hp <= 0) handleEntityDeath(source, hitMonster);
return;
}
}

if (options.allowDrop !== false && projectilePath.length > 0) {
const finalPos = projectilePath[projectilePath.length - 1];
items.push({
...item, x: finalPos.x, y: finalPos.y
});
}
}

function processTrapCadence(trap) {
if (trap.apRegen == null) return;

if ((trap.ap || 0) < AP_COSTS.THROW) return;

let ammo = null;
let maxRange = 0;
if (trap.hasBoulder) {
ammo = {
...ENEMY_ITEMS.boulder
};
maxRange = 8;
} else if (trap.hasDart) {
ammo = {
...ENEMY_ITEMS.dart
};
maxRange = 12;
}
if (!ammo) return;

const distance = Math.hypot(player.x - trap.x, player.y - trap.y);
if (distance > maxRange) return;

if (!hasLineOfSight(trap.x, trap.y, player.x, player.y)) return;

const {
dx,
dy
} = pickCardinalDirection(trap.x, trap.y, player.x, player.y);

if (!(trap, AP_COSTS.THROW, 'trap fire')) return;

throwProjectile(trap, ammo, dx, dy, {
allowDrop: false
});
}

function findPath(startX, startY, goalX, goalY) {
if (!isWalkable(goalX, goalY)) return null;

const directions = [{
dx: 0,
dy: -1
},
{
dx: 1,
dy: -1
},
{
dx: 1,
dy: 0
},
{
dx: 1,
dy: 1
},
{
dx: 0,
dy: 1
},
{
dx: -1,
dy: 1
},
{
dx: -1,
dy: 0
},
{
dx: -1,
dy: -1
}];

function manhattan(x1, y1, x2, y2) {
return Math.abs(x1 - x2) + Math.abs(y1 - y2);
}

const openSet = [];
const openKeys = new Set();
const closedSet = new Set();
const gScore = new Map();

const startKey = `${startX}_${startY}`;
gScore.set(startKey, 0);
const startNode = {
x: startX,
y: startY,
g: 0,
h: manhattan(startX, startY, goalX, goalY),
f: 0,
parent: null
};
openSet.push(startNode);
openKeys.add(startKey);

let iterCount = 0;
const maxIters = 5000;

while (openSet.length > 0) {
iterCount++;
if (iterCount > maxIters) return null;

openSet.sort((a, b) => a.f - b.f);
const current = openSet.shift();
const currentKey = `${current.x}_${current.y}`;
openKeys.delete(currentKey);

if (current.x === goalX && current.y === goalY) {
const path = [];
let node = current;
while (node) {
path.unshift({
x: node.x, y: node.y
});
node = node.parent;
}
return path;
}

closedSet.add(currentKey);

for (const dir of directions) {
const nx = current.x + dir.dx;
const ny = current.y + dir.dy;
if (nx < 0 || nx >= WIDTH || ny < 0 || ny >= HEIGHT) continue;
if (dungeon.tiles[ny][nx] === '#') continue;
if (!isWalkable(nx, ny)) continue;

const neighborKey = `${nx}_${ny}`;
const tentativeG = current.g + (dir.dx !== 0 && dir.dy !== 0 ? 1.4: 1);
const currentG = gScore.get(neighborKey) || Infinity;

if (closedSet.has(neighborKey) && tentativeG >= currentG) continue;

if (tentativeG < currentG) {
gScore.set(neighborKey, tentativeG);
const fScoreNew = tentativeG + manhattan(nx, ny, goalX, goalY);
const neighbor = {
x: nx,
y: ny,
g: tentativeG,
h: manhattan(nx, ny, goalX, goalY),
f: fScoreNew,
parent: current
};

if (!openKeys.has(neighborKey)) {
openSet.push(neighbor);
openKeys.add(neighborKey);
} else {
openSet.push(neighbor);
}
}
}
}
return null;
}

function petAction(pet) {
if (pet.ap < pet.apRegen) return;

const distToPlayer = Math.hypot(player.x - pet.x, player.y - pet.y);
const nearbyMonster = monsters.find(m => Math.hypot(m.x - pet.x, m.y - pet.y) < 1.5);

if (nearbyMonster) {
attack(pet, nearbyMonster);
return;
}

if (distToPlayer <= 2) return;

let nextX = pet.x;
let nextY = pet.y;
let usePath = true;
let moved = false;

const goalX = player.x;
const goalY = player.y;

const now = turn;
if (!pet.path || pet.path.length === 0 || now - (pet.pathTimestamp || 0) > 3) {
pet.path = findPath(pet.x, pet.y, goalX, goalY) || [];
pet.pathTimestamp = now;
}

if (pet.path.length > 1) {
const nextStep = pet.path[1];
nextX = nextStep.x;
nextY = nextStep.y;
} else {
usePath = false;
}

if (!usePath) {
nextX = pet.x + Math.sign(player.x - pet.x);
nextY = pet.y + Math.sign(player.y - pet.y);
}

if (isWalkable(nextX, nextY) && !monsters.some(m => m.x === nextX && m.y === nextY) && !pets.some(p0 => p0.x === nextX && p0.y === nextY && p0 !== pet) && !(player.x === nextX && player.y === nextY)) {
pet.x = nextX;
pet.y = nextY;
moved = true;
if (usePath && pet.path.length > 1) {
pet.path.shift();
}
}

if (moved) {
pet.ap -= AP_COSTS.MOVE;
}
}

function monsterAction(monster) {
if (monster.ap < AP_COSTS.ATTACK) return;

const distToPlayer = Math.hypot(player.x - monster.x, player.y - monster.y);
let detectionRange = 8;
if (player.sneakTurns > 0) detectionRange = 3;

const canSeePlayer = distToPlayer < detectionRange && lineOfSight(monster.x, monster.y, player.x, player.y);

// SLEEPING STATE
if (monster.state === 'sleeping') {
const wakeChance = player.sneakTurns > 0 ? 0.001: 0.01;
const wakeDistance = player.sneakTurns > 0 ? 1: 2;

if (canSeePlayer || distToPlayer < wakeDistance || Math.random() < wakeChance) {
log(`${monster.name} wakes up!`, 'info');
monster.state = 'wandering';
} else {
return;
}
}

// CONFUSION (overrides normal behavior)
if (monster.confusionTurns > 0) {
const dx = Math.floor(Math.random() * 3) - 1;
const dy = Math.floor(Math.random() * 3) - 1;
let moveX = monster.x + dx;
let moveY = monster.y + dy;
if (isWalkable(moveX, moveY) &&
!monsters.some(m => m.x === moveX && m.y === moveY) &&
!(player.x === moveX && player.y === moveY)) {
monster.x = moveX;
monster.y = moveY;
monster.ap -= monster.apRegen;
}
return;
}

// ELBERETH CHECK
const playerEngraving = dungeon.engravings.find(e => e.x === player.x && e.y === player.y);
if (playerEngraving && playerEngraving.text === 'Elbereth' && canSeePlayer) {
if (Math.random() < 0.85) {
log(`${monster.name} refuses to approach the engraving!`, 'info');
monster.ap -= monster.apRegen;
return;
}
}

// DETERMINE STATE TRANSITIONS
const fleeHealth = monster.behavior === 'coward' ? monster.maxHp * 0.75: monster.maxHp * 0.25;

if (canSeePlayer) {
if (monster.hp < fleeHealth) {
monster.state = 'fleeing';
} else if (monster.behavior !== 'peaceful' || monster.wasAttacked) {
monster.state = 'chasing';
monster.lastKnownPlayerX = player.x;
monster.lastKnownPlayerY = player.y;
}
} else if (monster.state === 'chasing' || monster.state === 'fleeing') {
if (player.sneakTurns > 0 && Math.random() < 0.5) {
monster.state = 'wandering';
if (Math.random() < 0.1) {
log(`${monster.name} loses track of you!`, 'pickup');
}
} else if (monster.lastKnownPlayerX && monster.lastKnownPlayerY) {
monster.state = 'hunting';
} else {
monster.state = 'wandering';
}
}

// SPECIAL BEHAVIORS
handleSpecialBehavior(monster, canSeePlayer, distToPlayer);

// STATE-BASED ACTIONS
switch (monster.state) {
case 'fleeing':
handleFleeingBehavior(monster);
break;
case 'chasing':
handleChasingBehavior(monster, distToPlayer, canSeePlayer);
break;
case 'hunting':
handleHuntingBehavior(monster);
break;
case 'guarding':
handleGuardingBehavior(monster);
break;
case 'wandering':
default:
handleWanderingBehavior(monster, distToPlayer);
break;
}
}

function processFireSpread() {
const existingFires = dungeon.features.filter(f => f.type === 'fire');
if (existingFires.length === 0) return;

const newFires = [];
const firesToBurnOut = [];
let changed = false;

for (const fire of existingFires) {
fire.duration = (fire.duration || 5) - 1;
if (fire.duration <= 0) {
firesToBurnOut.push(fire);
continue;
}

for (let dy = -1; dy <= 1; dy++) {
for (let dx = -1; dx <= 1; dx++) {
if (dx === 0 && dy === 0) continue;

const nx = fire.x + dx;
const ny = fire.y + dy;

if (nx < 0 || nx >= WIDTH || ny < 0 || ny >= HEIGHT) continue;

if (Math.random() < (fire.spreadChance || 0.1)) {
const targetTile = dungeon.tiles[ny][nx];
const isFlammable = ['.',
'\'',
'+',
'E'].includes(targetTile);
const isOccupiedByFire = dungeon.features.some(f => f.x === nx && f.y === ny && f.type === 'fire');
const hasFireResistantEntity = (
(player.x === nx && player.y === ny && player.intrinsics?.fireResist) ||
monsters.some(m => m.x === nx && m.y === ny && m.intrinsics?.fireResist) ||
pets.some(p => p.x === nx && p.y === ny && p.intrinsics?.fireResist)
);

if (isFlammable && !isOccupiedByFire && !hasFireResistantEntity) {
newFires.push({
x: nx,
y: ny,
type: 'fire',
glyph: '}',
color: '#f80',
damage: fire.damage || 2,
spreadChance: fire.spreadChance || 0.1,
duration: rollDice(1, 3, 2)
});
}
}
}
}
}

if (firesToBurnOut.length > 0) {
dungeon.features = dungeon.features.filter(f => !firesToBurnOut.includes(f));
firesToBurnOut.forEach(f => {
dungeon.tiles[f.y][f.x] = '.';
});
changed = true;
}

if (newFires.length > 0) {
const uniqueNewFires = newFires.filter((fire, index, self) =>
index === self.findIndex(f => f.x === fire.x && f.y === fire.y)
);

dungeon.features.push(...uniqueNewFires);
uniqueNewFires.forEach(f => {
dungeon.tiles[f.y][f.x] = '}';
});
changed = true;
}

if (changed) {
needsRedraw = true;
}
}

function processTurn() {
if (!player || !dungeon || !dungeon.tiles) return;

turn++;

if (player.paralyzedTurns > 0) {
player.paralyzedTurns--;
if (player.paralyzedTurns === 0) {
log('You can move again!', 'pickup');
player.ap = player.maxAP;
}
}

applyPlayerStatusEffects();
regenerateAP();

if (player.autoRange && player.paralyzedTurns === 0) {
tryAutoRangedAttack();
}

processFireSpread();
processGasSpread(); 

const monstersToProcess = [...monsters];
monstersToProcess.forEach(m => {
if (monsters.includes(m)) {
monsterAction(m);
}
});

const petsToProcess = [...pets];
petsToProcess.forEach(p => {
if (pets.includes(p)) {
petAction(p);
}
});

traps.forEach(t => processTrapCadence(t));

applyMonsterStatusEffects();

computeFOV(player.x,
player.y,
getVisionRadius());
updateStats();
updateStatusGrid();
autosave();

if (player.hp <= 0) {
showRestartModal();
}

needsRedraw = true;
}

function highlightEspTile(viewX, viewY, monster) {
const x = viewX * TILE_SIZE;
const y = viewY * TILE_SIZE;

ctx.save();

const c = getTelepathyColor(monster);

ctx.lineWidth = 2;
ctx.strokeStyle = c;
ctx.shadowColor = c;
ctx.shadowBlur = 6;

ctx.strokeRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);

ctx.restore();
}

function gameLoop() {
requestAnimationFrame(gameLoop);
if (!needsRedraw) return;

let focusX = player.isLooking ? player.lookCursor.x: player.x;
let focusY = player.isLooking ? player.lookCursor.y: player.y;
const {
offsetX,
offsetY
} = getCameraOffset(focusX, focusY);

ctx.fillStyle = '#002000';
ctx.fillRect(0, 0, canvas.width, canvas.height);
ctx.textAlign = 'start';
ctx.textBaseline = 'bottom';

for (let viewY = 0; viewY < getViewHeight(); viewY++) {
for (let viewX = 0; viewX < getViewWidth(); viewX++) {
let mapX = offsetX + viewX;
let mapY = offsetY + viewY;
if (mapX >= WIDTH || mapY >= HEIGHT) continue;

const isVisible = visible[mapY][mapX];
const isExplored = explored[mapY][mapX];
const isEsp = espVisible[mapY][mapX];

const monster = monsters.find(m => m.x === mapX && m.y === mapY);
const pet = pets.find(p => p.x === mapX && p.y === mapY);
const item = items.find(i => i.x === mapX && i.y === mapY && !i.hidden);
const trap = traps.find(t => t.x === mapX && t.y === mapY && !t.hidden);
const shop = dungeon.features.find(f => f.x === mapX && f.y === mapY && f.type === 'shop');



if (isExplored || isVisible) {
let tileChar = dungeon.tiles[mapY][mapX];
let tileColor = isVisible ? '#0f0': '#050';
if (tileChar === '{') tileColor = isVisible ? '#0af': '#035';
if (tileChar === '≈') tileColor = isVisible ? '#888': '#333';
if (tileChar === '+') tileColor = isVisible ? '#f80': '#530';
if (tileChar === '\'') tileColor = isVisible ? '#c60': '#420';
if (tileChar === '_') tileColor = isVisible ? '#fff': '#444';
if (tileChar === 'E') {
const engrave = dungeon.engravings.find(e => e.x === mapX && e.y === mapY);
tileChar = tileChar = 'E';
tileColor = isVisible ? '#ff0': '#550';
}
ctx.fillStyle = tileColor;
ctx.fillText(tileChar, viewX * TILE_SIZE, (viewY + 1) * TILE_SIZE);

if (shop && !shop.shopkeeperAngry) {
ctx.fillStyle = isVisible ? shop.color: '#550';
ctx.fillText(shop.glyph, viewX * TILE_SIZE, (viewY + 1) * TILE_SIZE);
}

if (monster && isVisible) {
// Red background for hostile monsters
// --- Monster HP bar (draw when monster is damaged) ---
if (typeof monster.hp !== 'undefined') {
  const maxHp = monster.maxHp || monster.hp || 1;
  if (monster.hp < maxHp) {
    const hpPercent = Math.max(0, Math.min(1, monster.hp / maxHp));

    // bar dimensions (small bar at top of tile)
    const barHeight = Math.max(2, Math.floor(TILE_SIZE * 0.12)); // ~2-3px depending on TILE_SIZE
    const barWidth = Math.max(2, Math.floor(TILE_SIZE * hpPercent));
    const barX = viewX * TILE_SIZE + 1;
    const barY = viewY * TILE_SIZE + 1; // top padding inside the tile

    // colored fill based on percent
    ctx.fillStyle = hpPercent > 0.5 ? '#0f0' : (hpPercent > 0.25 ? '#ff0' : '#f00');
    ctx.fillRect(barX, barY, barWidth, barHeight);

    // subtle background / border so full bar size is visible
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 1;
    ctx.strokeRect(viewX * TILE_SIZE + 1, barY - 0.25, TILE_SIZE - 2, barHeight + 0.5);
  }
}
// --- end HP bar snippet ---
if (monster.state === 'chasing') {
ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
ctx.fillRect(viewX * TILE_SIZE, viewY * TILE_SIZE, TILE_SIZE, TILE_SIZE);
}

ctx.save();
// Glow in monster's own color
ctx.shadowColor = monster.color;
ctx.shadowBlur = 6;
ctx.fillStyle = monster.color;
ctx.fillText(monster.glyph, viewX * TILE_SIZE, (viewY + 1) * TILE_SIZE);
ctx.restore();
}

if (pet) {
ctx.fillStyle = pet.color || '#ccc';
ctx.fillText(pet.glyph || 'd', viewX * TILE_SIZE, (viewY + 1) * TILE_SIZE);
}

if (isVisible && item) {
ctx.fillStyle = item.color;
ctx.fillText(item.glyph, viewX * TILE_SIZE, (viewY + 1) * TILE_SIZE);
}

if (isVisible && trap) {
ctx.fillStyle = trap.color;
ctx.fillText(trap.glyph, viewX * TILE_SIZE, (viewY + 1) * TILE_SIZE);
}
}

if (isVisible) {
  const environmental = environmentals.find(e => e.x === mapX && e.y === mapY);
  if (environmental) {
    ctx.fillStyle = environmental.color;
    ctx.fillText(environmental.glyph, viewX * TILE_SIZE, (viewY + 1) * TILE_SIZE);
    
    // HP bar for damaged environmentals
    if (environmental.hp < environmental.maxHp && environmental.breakable) {
      const hpPercent = environmental.hp / environmental.maxHp;
      ctx.fillStyle = hpPercent > 0.5 ? '#0f0' : (hpPercent > 0.25 ? '#ff0' : '#f00');
      ctx.fillRect(
        viewX * TILE_SIZE, 
        viewY * TILE_SIZE, 
        TILE_SIZE * hpPercent, 
        2
      );
    }
  }
}

if (monster && isEsp && !isVisible) {
highlightEspTile(viewX, viewY, monster);
}
}
}


if (
player.x >= offsetX && player.x < offsetX + getViewWidth() &&
player.y >= offsetY && player.y < offsetY + getViewHeight()
) {
ctx.fillStyle = player.color;
ctx.fillText(
player.glyph,
(player.x - offsetX) * TILE_SIZE,
(player.y - offsetY + 1) * TILE_SIZE
);
}

if (
player.isLooking &&
player.lookCursor.x >= offsetX && player.lookCursor.x < offsetX + getViewWidth() &&
player.lookCursor.y >= offsetY && player.lookCursor.y < offsetY + getViewHeight()
) {
const viewX = player.lookCursor.x - offsetX;
const viewY = player.lookCursor.y - offsetY;
ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
ctx.fillRect(viewX * TILE_SIZE, viewY * TILE_SIZE, TILE_SIZE, TILE_SIZE);
}

ctx.fillStyle = 'rgba(0,0,0,0.7)';
ctx.fillRect(canvas.width - 82, 2, 80, 62);
ctx.strokeStyle = '#0f0';
ctx.lineWidth = 1;
ctx.strokeRect(canvas.width - 82, 2, 80, 62);

for (let y = 0; y < HEIGHT; y++) {
for (let x = 0; x < WIDTH; x++) {
if (!explored[y][x]) continue;
ctx.fillStyle = visible[y][x] ? '#0f0': '#050';
ctx.fillRect(canvas.width - 81 + x, 3 + y, 1, 1);
}
}

ctx.fillStyle = '#ff0';
ctx.fillRect(canvas.width - 81 + player.x, 3 + player.y, 1, 1);

const stairsItem = items.find(i => i.isStairs);
if (stairsItem && explored[stairsItem.y][stairsItem.x]) {
ctx.fillStyle = '#fff';
ctx.fillRect(canvas.width - 81 + stairsItem.x, 3 + stairsItem.y, 1, 1);
}

needsRedraw = true;
updateDebugOverlay();
}

function updateDebugOverlay() {
const el = document.getElementById('debug-overlay');
if (!el || el.style.display === 'none') return;
el.innerHTML = [
`Turn: ${turn}`,
`Depth: ${dungeonLevel}`,
`Monsters: ${monsters.length}`,
`Items: ${items.length}`,
`Traps: ${traps.length}`,
`Player: (${player.x},${player.y}) HP ${player.hp}/${player.maxHp} AP ${player.ap}/${player.maxAP}`
].join('<br/>');
}

let DEV_MODE = false;
let fingerCountTimeout = null;

function toggleDevMode(forceState) {
DEV_MODE = (typeof forceState === 'boolean') ? forceState: !DEV_MODE;
DEV_MODE ? showDevOverlay(): hideDevOverlay();
}

document.addEventListener('keydown', (e) => {
if (e.ctrlKey && e.key.toLowerCase() === 'd') {
e.preventDefault();
toggleDevMode();
}
});

document.addEventListener('dblclick', (e) => {
if (e.clientX < 100 && e.clientY < 100) {
toggleDevMode();
}
});

document.addEventListener('touchstart', (e) => {
if (e.touches.length >= 3) {
clearTimeout(fingerCountTimeout);
fingerCountTimeout = setTimeout(toggleDevMode, 50);
}
}, {
passive: true
});

function showDevOverlay() {
  let overlay = document.getElementById('dev-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'dev-overlay';
    Object.assign(overlay.style, {
      position: 'fixed',
      bottom: '10px',
      left: '50%',
      transform: 'translateX(-50%)',
      background: 'rgba(0,0,0,0.95)',
      color: '#0f0',
      padding: '12px',
      borderRadius: '8px',
      border: '2px solid #0f0',
      zIndex: '9999',
      display: 'flex',
      flexDirection: 'column',
      gap: '8px',
      maxHeight: '80vh',
      overflowY: 'auto',
      minWidth: '300px',
      maxWidth: '90vw'
    });

    overlay.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #0f0; padding-bottom: 8px; margin-bottom: 8px;">
        <h3 style="margin: 0; color: #0f0;">🛠️ Dev Menu</h3>
        <button data-dev="close" style="background: #400; border: 1px solid #f00; color: #f00; padding: 4px 8px; border-radius: 4px; cursor: pointer;">✕ Close</button>
      </div>

    
<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
        <!-- SPAWNING -->
        <button data-dev="spawn-monster">🧟 Spawn Monster</button>
        <button data-dev="spawn-stairs">🪜 Spawn Stairs</button>
        <button data-dev="spawn-environmental">📦 Spawn Environmental</button>
        <button data-dev="spawn-chest">💎 Spawn Chest</button>
        <button data-dev="spawn-trap">🪤 Spawn Trap</button>
        <button data-dev="spawn-shop">🏪 Spawn Shop</button>
        <button data-dev="spawn-enchanter">✦ Spawn Enchanter</button>
        <button data-dev="spawn-hidden-item">👁️ Hidden Item</button>
        
        <!-- PLAYER POWER -->
        <button data-dev="level-up">⭐ Level Up</button>
        <button data-dev="give-gold">💰 +100000 Gold</button>
        <button data-dev="heal-full">❤️ Full Heal</button>
        <button data-dev="restore-ap">⚡ Restore AP</button>
        
        <!-- ITEMS -->
        <button data-dev="give-potion">🧪 Give Potions</button>
        <button data-dev="give-pickaxe">⛏️ Give Pick-axe</button>
        <button data-dev="give-torch">🔦 Give Torch</button>
        <button data-dev="give-key">🔑 Give Key</button>
        <button data-dev="give-amulet-esp">🔮 Give ESP Amulet</button>
        <button data-dev="identify-all">🔍 Identify All</button>
        
        <!-- ENCHANTING/SPELLS -->
        <button data-dev="learn-all-spells">📖 Learn All Spells</button>
        <button data-dev="max-upgrade-weapon">⚔️ Max Upgrade Weapon</button>
        <button data-dev="enchant-weapon">✨ Enchant Weapon</button>
        <button data-dev="enchant-armor">🛡️ Enchant Armor</button>
        
        <!-- UTILITY -->
        <button data-dev="generate-test-level">🧪 Test Level</button>
        <button data-dev="teleport-player">🌀 Teleport Player</button>
        <button data-dev="kill-all-monsters">☠️ Kill All Monsters</button>
      </div>
    `;

    styleDevButtons(overlay);
    overlay.addEventListener('click', handleDevAction);
    document.body.appendChild(overlay);
  }
  overlay.style.display = 'flex';
}

function hideDevOverlay() {
const overlay = document.getElementById('dev-overlay');
if (overlay) overlay.style.display = 'none';
}

function styleDevButtons(overlay) {
overlay.querySelectorAll('button').forEach(btn => {
if (!btn.style.cssText.includes('background')) {
Object.assign(btn.style, {
fontSize: '13px',
padding: '8px 10px',
borderRadius: '4px',
border: '2px solid #0f0',
background: '#002200',
color: '#0f0',
cursor: 'pointer',
transition: 'all 0.2s',
fontFamily: "'Courier New', monospace",
whiteSpace: 'nowrap'
});
}
});
}

function handleDevAction(e) {
const action = e.target?.getAttribute('data-dev');
if (!action) return;

if (action === 'close') {
toggleDevMode(false);
return;
}

switch (action) {
case 'spawn-monster':
showMonsterSpawnModal();
break;

case 'level-up': {
const oldLevel = player.level;
player.level++;
const hpGain = player.role === 'Barbarian' ? rollDice(1, 8, 2):
(player.role === 'Wizard' ? rollDice(1, 4, 1): rollDice(1, 6, 1));
player.maxHp += hpGain;
player.hp = player.maxHp;
player.maxAP += 10;
player.ap = player.maxAP;
player.apRegen +=5;
player.hitChance += 1;
log(`Dev: Leveled up ${oldLevel} → ${player.level}! +${hpGain} max HP.`, 'pickup');
updateStats();
break;
}

case 'spawn-stairs': {
const pos = findWalkableAdjacent(player.x, player.y) || {
x: player.x + 1,
y: player.y
};

// Remove any existing stairs item at this position
items = items.filter(i => !(i.x === pos.x && i.y === pos.y && i.isStairs));

// Add new stairs
const stairsType = ITEM_TYPES.find(i => i.isStairs);
items.push({
...stairsType, x: pos.x, y: pos.y
});
dungeon.tiles[pos.y][pos.x] = '>';

log(`Dev: Spawned stairs at (${pos.x}, ${pos.y}).`, 'pickup');
computeFOV(player.x, player.y, getVisionRadius());
needsRedraw = true;
break;
}

case 'give-gold': {
player.gold += 100000;
log('Dev: Added 100000 gold.', 'pickup');
updateStats();
break;
}

case 'give-potion': {
const desiredPotions = ['potion of healing',
'potion of burning',
'potion of speed',
'potion of strength'];
desiredPotions.forEach(baseName => {
const pot = ITEM_TYPES.find(i => i.baseName === baseName);
if (pot) {
const item = {
...pot,
name: pot.baseName || pot.name,
identified: true,
status: 'Normal'
};
player.inventory.push(item);
}
});
log('Dev: Added healing, burning, speed, and strength potions.',
'pickup');
updateStats();
break;
}

case 'give-torch': {
const torchType = ITEM_TYPES.find(i => i.baseName === 'torch');
if (torchType) {
const torch = {
...torchType,
name: torchType.name,
identified: true,
turnsRemaining: 200,
isLit: false
};
player.inventory.push(torch);
log('Dev: Added torch to inventory.', 'pickup');
updateStats();
}
break;
}

case 'give-key': {
    const keyType = ITEM_TYPES.find(i => i.baseName === 'skeleton key');
    if (keyType) {
        const key = {
            ...keyType,
            name: keyType.name,
            identified: true
        };
        player.inventory.push(key);
        log('Dev: Added skeleton key to inventory.', 'pickup');
        updateStats();
    }
    break;
}

case 'spawn-environmental': {
      showEnvironmentalSpawnModal();
      break;
    }

    case 'spawn-chest': {
      const pos = findWalkableAdjacent(player.x, player.y) || { x: player.x + 1, y: player.y };
      const chestType = ENVIRONMENTAL_TYPES.find(t => t.name === 'wooden chest');
      
      if (chestType) {
        environmentals.push({
          ...chestType,
          x: pos.x,
          y: pos.y,
          hp: chestType.hp,
          maxHp: chestType.maxHp,
          isOpen: false,
          discovered: false
        });
        log(`Dev: Spawned wooden chest at (${pos.x}, ${pos.y}).`, 'pickup');
        computeFOV(player.x, player.y, getVisionRadius());
        needsRedraw = true;
      }
      break;
    }


case 'give-pickaxe': {
const pickaxeType = ITEM_TYPES.find(i => i.baseName === 'pick-axe');
if (pickaxeType) {
const pickaxe = {
...pickaxeType,
name: pickaxeType.baseName,
identified: true
};
player.inventory.push(pickaxe);
log('Dev: Added pick-axe to inventory.', 'pickup');
updateStats();
}
break;
}

case 'give-amulet-esp': {
const espAmulet = ITEM_TYPES.find(i => i.baseName === 'amulet of ESP');
if (espAmulet) {
const amuletToGive = {
...espAmulet,
name: espAmulet.baseName,
identified: true
};
player.inventory.push(amuletToGive);
log('Dev: Added Amulet of ESP to inventory.', 'pickup');
}
updateStats();
break;
}

case 'spawn-hidden-item': {
const pos = findWalkableAdjacent(player.x, player.y) || {
x: player.x + 1,
y: player.y
};
const itemType = ITEM_TYPES.find(i => i.baseName === 'dagger');
items.push({
...itemType, x: pos.x, y: pos.y, name: itemType.baseName, identified: true, hidden: true
});
log('Dev: Spawned hidden dagger nearby.', 'info');
needsRedraw = true;
break;
}

case 'spawn-trap': {
const pos = findWalkableAdjacent(player.x, player.y) || {
x: player.x + 1,
y: player.y
};
const trapType = TRAP_TYPES[Math.floor(Math.random() * TRAP_TYPES.length)];
const newTrap = {
...trapType,
x: pos.x,
y: pos.y,
hidden: false
};
if (newTrap.apRegen != null) {
newTrap.ap = 0;
newTrap.maxAP = newTrap.maxAP || 100;
}
traps.push(newTrap);
log(`Dev: Spawned ${newTrap.name} at (${pos.x}, ${pos.y}).`, 'info');
computeFOV(player.x, player.y, getVisionRadius());
needsRedraw = true;
break;
}

case 'spawn-shop': {
const pos = findWalkableAdjacent(player.x, player.y) || {
x: player.x + 1,
y: player.y
};
const shopInventory = [];
const itemCount = 8;

for (let i = 0; i < itemCount; i++) {
const validItems = ITEM_TYPES.filter(it =>
!it.isStairs && it.depth <= dungeonLevel + 2 && it.type !== 'gold'
);
const itemType = validItems[Math.floor(Math.random() * validItems.length)];
shopInventory.push({
...itemType,
name: itemType.baseName || itemType.name,
identified: true,
status: Math.random() < 0.1 ? 'Cursed': (Math.random() < 0.2 ? 'Blessed': 'Normal'),
quantity: itemType.stackable ? Math.floor(Math.random() * 5) + 1: 1
});
}

const shopFeature = {
x: pos.x,
y: pos.y,
type: 'shop',
glyph: '€',
color: '#ff0',
inventory: shopInventory,
shopkeeperAngry: false
};

dungeon.features.push(shopFeature);
dungeon.tiles[pos.y][pos.x] = '€';

log(`Dev: Spawned shop at (${pos.x}, ${pos.y}). Walk onto it to open.`, 'pickup');
computeFOV(player.x, player.y, getVisionRadius());
needsRedraw = true;
break;
}

case 'generate-test-level': {
generateTestLevel();
log('Dev: Test level generated.', 'info');
needsRedraw = true;
break;
}

case 'heal-full': {
player.hp = player.maxHp;
player.ap = player.maxAP;
player.poisonTurns = 0;
player.confusionTurns = 0;
player.paralyzedTurns = 0;
player.exhaustedTurns = 0;
log('Dev: Fully healed and restored.', 'pickup');
updateStats();
break;
}

case 'identify-all': {
player.inventory.forEach(i => {
if (!i.identified) identifyItem(i);
});
items.forEach(i => {
if (!i.identified) identifyItem(i);
});
log('Dev: All items identified.',
'pickup');
updateStats();
break;
}

case 'teleport-player': {
teleportPlayer();
log('Dev: Player teleported.',
'info');
break;
}

case 'kill-all-monsters': {
const count = monsters.length;
monsters.length = 0;
log(`Dev: Killed all ${count} monsters.`,
'damage');
needsRedraw = true;
break;
}

case 'spawn-enchanter': {
      const pos = findWalkableAdjacent(player.x, player.y) || {
        x: player.x + 1,
        y: player.y
      };

      const enchanterFeature = {
        x: pos.x,
        y: pos.y,
        type: 'enchanter',
        glyph: '✦',
        color: '#0af'
      };

      dungeon.features.push(enchanterFeature);
      dungeon.tiles[pos.y][pos.x] = '✦';

      log(`Dev: Spawned enchanter at (${pos.x}, ${pos.y}). Walk onto it to open.`, 'pickup');
      computeFOV(player.x, player.y, getVisionRadius());
      needsRedraw = true;
      break;
    }

    case 'learn-all-spells': {
      if (!player.spells) player.spells = [];
      
      const allSpells = Object.keys(SPELL_TYPES).filter(key => 
        SPELL_TYPES[key].class === player.role
      );
      
      allSpells.forEach(spellKey => {
        if (!player.spells.includes(spellKey)) {
          player.spells.push(spellKey);
        }
      });
      
      log(`Dev: Learned ${allSpells.length} spells for ${player.role}.`, 'pickup');
      break;
    }

    case 'max-upgrade-weapon': {
      if (!player.weapon) {
        log('Dev: No weapon equipped!', 'damage');
        break;
      }
      
      const oldMultiplier = getUpgradeMultiplier(player.weapon.upgradeLevel || 0);
      player.weapon.upgradeLevel = MAX_UPGRADE_LEVEL;
      const newMultiplier = getUpgradeMultiplier(MAX_UPGRADE_LEVEL);
      player.weapon.damage = Math.floor(player.weapon.damage * newMultiplier / oldMultiplier);
      
      log(`Dev: Upgraded ${getItemDisplayName(player.weapon)} to +${MAX_UPGRADE_LEVEL}!`, 'pickup');
      updateStats();
      break;
    }

    case 'enchant-weapon': {
      if (!player.weapon) {
        log('Dev: No weapon equipped!', 'damage');
        break;
      }
      
      const weaponEnchants = Object.keys(ENCHANTMENT_TYPES).filter(key => 
        ENCHANTMENT_TYPES[key].type === 'weapon'
      );
      
      const randomEnchant = weaponEnchants[Math.floor(Math.random() * weaponEnchants.length)];
      player.weapon.enchantment = randomEnchant;
      
      log(`Dev: Enchanted weapon with ${ENCHANTMENT_TYPES[randomEnchant].name}!`, 'pickup');
      updateStats();
      break;
    }

    case 'enchant-armor': {
      if (!player.armor) {
        log('Dev: No armor equipped!', 'damage');
        break;
      }
      
      const armorEnchants = Object.keys(ENCHANTMENT_TYPES).filter(key => 
        ENCHANTMENT_TYPES[key].type === 'armor'
      );
      
      const randomEnchant = armorEnchants[Math.floor(Math.random() * armorEnchants.length)];
      player.armor.enchantment = randomEnchant;
      
      log(`Dev: Enchanted armor with ${ENCHANTMENT_TYPES[randomEnchant].name}!`, 'pickup');
      updateStats();
      break;
    }

    case 'restore-ap': {
      player.ap = player.maxAP;
      log('Dev: AP fully restored.', 'pickup');
      updateStats();
      break;
    }
}
}

function showMonsterSpawnModal() {
// Remove existing modal if present
let modal = document.getElementById('monster-spawn-modal');
if (modal) modal.remove();

modal = document.createElement('div');
modal.id = 'monster-spawn-modal';
modal.className = 'modal show';
modal.style.cssText = `
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.9);
display: flex;
align-items: center;
justify-content: center;
z-index: 10000;
`;

const content = document.createElement('div');
content.className = 'modal-content';
content.style.cssText = `
background: #000100;
border: 3px solid #0f0;
padding: 20px;
border-radius: 8px;
max-width: 90%;
max-height: 80vh;
overflow-y: auto;
width: 400px;
`;

content.innerHTML = `
<h2 style="color: #0f0; margin: 0 0 15px 0; text-align: center;">🧟 Spawn Monster</h2>
<div id="monster-list" style="display: flex; flex-direction: column; gap: 8px;"></div>
<button id="close-monster-modal" class="modal-btn" style="margin-top: 15px; width: 100%;">Cancel</button>
`;

modal.appendChild(content);
document.body.appendChild(modal);

const monsterList = document.getElementById('monster-list');

MONSTER_TYPES.forEach((type, index) => {
const btn = document.createElement('button');
btn.className = 'modal-btn';
btn.style.cssText = `
display: flex;
justify-content: space-between;
align-items: center;
padding: 10px;
text-align: left;
background: #002200;
border: 2px solid #0f0;
color: #0f0;
font-family: 'Courier New', monospace;
cursor: pointer;
border-radius: 4px;
transition: all 0.2s;
`;

// Build behavior tags
let behaviorTag = '';
if (type.behavior === 'erratic') behaviorTag = ' <span style="color: #ff0;">[Erratic]</span>';
else if (type.behavior === 'equipper') behaviorTag = ' <span style="color: #0af;">[Equipper]</span>';
else if (type.behavior === 'coward') behaviorTag = ' <span style="color: #f80;">[Coward]</span>';
else if (type.behavior === 'divider') behaviorTag = ' <span style="color: #0f0;">[Divider]</span>';
else if (type.behavior === 'ranged') behaviorTag = ' <span style="color: #a0f;">[Ranged]</span>';

// Build resistance tags
let resistTag = '';
if (type.resists) resistTag = ` <span style="color: #888;">[Resists: ${type.resists}]</span>`;
if (type.intrinsics) {
const intrinsicList = [];
if (type.intrinsics.fireResist) intrinsicList.push('Fire');
if (type.intrinsics.coldResist) intrinsicList.push('Cold');
if (type.intrinsics.shockResist) intrinsicList.push('Shock');
if (type.intrinsics.poisonResist) intrinsicList.push('Poison');
if (intrinsicList.length > 0) {
resistTag = ` <span style="color: #888;">[Resists: ${intrinsicList.join(', ')}]</span>`;
}
}

btn.innerHTML = `
<div style="flex: 1;">
<div>
<span style="color: ${type.color}; font-weight: bold; font-size: 16px;">${type.glyph}</span>
<span style="margin-left: 8px; font-weight: bold;">${type.name}</span>${behaviorTag}
</div>
<div style="font-size: 11px; color: #888; margin-top: 4px;">
HP: ${type.hp} | DMG: ${type.damage} | XP: ${type.xp} | Depth: ${type.depth}+ | Hit: ${type.hitChance}%${resistTag}
</div>
</div>
`;

btn.addEventListener('mouseenter', () => {
btn.style.background = '#003300';
btn.style.borderColor = '#0ff';
});

btn.addEventListener('mouseleave', () => {
btn.style.background = '#002200';
btn.style.borderColor = '#0f0';
});

btn.addEventListener('click', () => {
const pos = findWalkableAdjacent(player.x, player.y) || findWalkable();

// Create fully-formed monster with all properties
const newMonster = {
...type,
x: pos.x,
y: pos.y,
maxHp: type.hp,
hp: type.hp,
ap: type.ap || 0,
maxAP: type.maxAP || 100,
state: 'wandering',
weapon: null,
path: [],
pathTimestamp: 0,
exhaustedTurns: type.exhaustedTurns || 0,
poisonTurns: 0,
confusionTurns: 0,
speedTurns: 0,
strengthTurns: 0,
burnTurns: 0,
paralyzedTurns: 0
};

// Ensure intrinsics are copied
if (type.intrinsics) {
newMonster.intrinsics = {
...type.intrinsics
};
}

monsters.push(newMonster);
log(`Dev: Spawned ${type.name} at (${pos.x}, ${pos.y}).`, 'pickup');
computeFOV(player.x, player.y, getVisionRadius());
needsRedraw = true;
modal.remove();
});

monsterList.appendChild(btn);
});

document.getElementById('close-monster-modal').addEventListener('click', () => {
modal.remove();
});

// Close on background click
modal.addEventListener('click', (e) => {
if (e.target === modal) modal.remove();
});
}

function showEnvironmentalSpawnModal() {
  // Remove existing modal if present
  let modal = document.getElementById('environmental-spawn-modal');
  if (modal) modal.remove();

  modal = document.createElement('div');
  modal.id = 'environmental-spawn-modal';
  modal.className = 'modal show';
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
  `;

  const content = document.createElement('div');
  content.className = 'modal-content';
  content.style.cssText = `
    background: #000100;
    border: 3px solid #0f0;
    padding: 20px;
    border-radius: 8px;
    max-width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    width: 400px;
  `;

  content.innerHTML = `
    <h2 style="color: #0f0; margin: 0 0 15px 0; text-align: center;">📦 Spawn Environmental</h2>
    <div id="environmental-list" style="display: flex; flex-direction: column; gap: 8px;"></div>
    <button id="close-environmental-modal" class="modal-btn" style="margin-top: 15px; width: 100%;">Cancel</button>
  `;

  modal.appendChild(content);
  document.body.appendChild(modal);

  const envList = document.getElementById('environmental-list');

  ENVIRONMENTAL_TYPES.forEach((type, index) => {
    const btn = document.createElement('button');
    btn.className = 'modal-btn';
    btn.style.cssText = `
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      text-align: left;
      background: #002200;
      border: 2px solid #0f0;
      color: #0f0;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
    `;

    // Build type tags
    let typeTag = '';
    if (type.type === 'container') typeTag = ' <span style="color: #0af;">[Container]</span>';
    else if (type.type === 'hazard') typeTag = ' <span style="color: #f00;">[Hazard]</span>';
    else if (type.type === 'barrier') typeTag = ' <span style="color: #888;">[Barrier]</span>';
    else if (type.type === 'explosive') typeTag = ' <span style="color: #ff0;">[Explosive]</span>';

    // Build property tags
    let propTags = [];
    if (type.locked) propTags.push('<span style="color: #f80;">Locked</span>');
    if (type.pushable) propTags.push('<span style="color: #0f0;">Pushable</span>');
    if (type.breakable) propTags.push('<span style="color: #f00;">Breakable</span>');
    if (type.bumpDamage) propTags.push(`<span style="color: #f00;">Dmg: ${type.bumpDamage}</span>`);
    
    const propString = propTags.length > 0 ? ` | ${propTags.join(' ')}` : '';

    btn.innerHTML = `
      <div style="flex: 1;">
        <div>
          <span style="color: ${type.color}; font-weight: bold; font-size: 16px;">${type.glyph}</span>
          <span style="margin-left: 8px; font-weight: bold;">${type.name}</span>${typeTag}
        </div>
        <div style="font-size: 11px; color: #888; margin-top: 4px;">
          HP: ${type.hp} | Depth: ${type.depth}+${propString}
        </div>
      </div>
    `;

    btn.addEventListener('mouseenter', () => {
      btn.style.background = '#003300';
      btn.style.borderColor = '#0ff';
    });

    btn.addEventListener('mouseleave', () => {
      btn.style.background = '#002200';
      btn.style.borderColor = '#0f0';
    });

    btn.addEventListener('click', () => {
      const pos = findWalkableAdjacent(player.x, player.y) || findWalkable();

      environmentals.push({
        ...type,
        x: pos.x,
        y: pos.y,
        hp: type.hp,
        maxHp: type.maxHp,
        isOpen: false,
        discovered: false
      });

      log(`Dev: Spawned ${type.name} at (${pos.x}, ${pos.y}).`, 'pickup');
      computeFOV(player.x, player.y, getVisionRadius());
      needsRedraw = true;
      modal.remove();
    });

    envList.appendChild(btn);
  });

  document.getElementById('close-environmental-modal').addEventListener('click', () => {
    modal.remove();
  });

  // Close on background click
  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });
}

function showCharSelect() {
document.getElementById('char-select-modal').classList.add('show');
}

function cycleZoom() {
zoomLevel++;
if (zoomLevel > 3) zoomLevel = 1;

const config = ZOOM_CONFIGS[zoomLevel];
TILE_SIZE = config.tileSize;

canvas.width = config.viewWidth * TILE_SIZE;
canvas.height = config.viewHeight * TILE_SIZE;
ctx.font = `${Math.floor(TILE_SIZE * 0.9)}px monospace`;

const btn = document.getElementById('zoom-toggle-btn');
if (btn) btn.textContent = `🔍 Zoom: ${zoomLevel}x`;

needsRedraw = true;
}

function showRestartModal() {
document.getElementById('final-level').textContent = player.level;
document.getElementById('final-gold').textContent = player.gold;
document.getElementById('final-kills').textContent = kills;
document.getElementById('final-turns').textContent = turn;
document.getElementById('restart-modal').classList.add('show');
saveGame(true);
}

function showDeadRuns() {
document.getElementById('dead-runs-modal').classList.add('show');
updateDeadRunsDisplay();
document.getElementById('char-select-modal').classList.remove('show');
}

function saveDeadRun(characterName, finalScore, finalLevel, role, causeOfDeath) {
const newRun = {
name: characterName,
score: finalScore,
level: finalLevel,
role: player.role,
cause: causeOfDeath
};

const existingRuns = JSON.parse(localStorage.getItem('DeadRuns') || '[]');
existingRuns.push(newRun);
localStorage.setItem('DeadRuns', JSON.stringify(existingRuns));
}

function resizeCanvas() {
const container = document.getElementById('game-container');
const containerWidth = container.clientWidth;
const containerHeight = container.clientHeight;

// Maintain original aspect ratio
const widthRatio = containerWidth / getViewWidth();
const heightRatio = containerHeight / getViewHeight();
const scale = Math.floor(Math.min(widthRatio, heightRatio));

// Ensure minimum tile size
TILE_SIZE = Math.max(16, scale);

// Calculate view size in pixels
canvas.width = getViewWidth() * TILE_SIZE;
canvas.height = getViewHeight() * TILE_SIZE;

// Update font size
ctx.font = `${Math.floor(TILE_SIZE * 0.9)}px monospace`;

// Mark for redraw
needsRedraw = true;
}

function updateDeadRunsDisplay() {
const deadRunsList = document.getElementById('dead-runs-list');
const runsData = JSON.parse(localStorage.getItem('DeadRuns') || '[]');

deadRunsList.innerHTML = '';

if (runsData.length === 0) {
deadRunsList.innerHTML = '<p style="color:#f00;">No dead runs recorded yet. Start a game!</p>';
return;
}

runsData.forEach((run) => {
const runElement = document.createElement('div');
runElement.className = 'dead-run-entry';
runElement.style.borderBottom = '1px dashed #0f0';
runElement.style.padding = '5px 0';

runElement.innerHTML = `
<span style="color:#fff;">${run.name}</span>, Level <span style="color:#ff0;">${run.level}, ${run.role}</span><br>
Score: ${run.score}<br>
Cause: ${run.cause}
`;
deadRunsList.appendChild(runElement);
});
}

document.getElementById('view-dead-runs-btn').addEventListener('click', () => {
document.getElementById('char-select-modal').classList.remove('show');
showDeadRuns();
});

document.getElementById('close-dead-runs-btn').addEventListener('click', () => {
document.getElementById('dead-runs-modal').classList.remove('show');
showCharSelect();
});

document.getElementById('clear-dead-runs-btn').addEventListener('click', () => {
if (confirm('Delete all dead runs?')) {
localStorage.removeItem('DeadRuns');
showDeadRuns();
}
});

document.querySelectorAll('.control-btn').forEach(button => {
  button.addEventListener('click', () => {
    let dx = 0, dy = 0;
    const dir = button.getAttribute('data-dir');
    switch (dir) {
      case 'n': dy = -1; break;
      case 's': dy = 1; break;
      case 'e': dx = 1; break;
      case 'w': dx = -1; break;
      case 'nw': dx = -1; dy = -1; break;
      case 'ne': dx = 1; dy = -1; break;
      case 'sw': dx = -1; dy = 1; break;
      case 'se': dx = 1; dy = 1; break;
      case 'wait': waitAction(); return;
    }
    
    // Check if we have an active action context that needs a direction
    if (currentActionContext && ['apply', 'kick', 'disarm', 'throw', 'zap', 'shoot'].includes(currentActionContext.action)) {
      executeActionWithDirection(dx, dy);
      return;
    }
    
    // Otherwise, normal movement
    movePlayer(dx, dy);
  });
});

document.getElementById('quick-actions').addEventListener('click', (e) => {
const action = e.target.dataset.action;
if (!action) return;

switch (action) {
case 'look-throw':
const throwableItem = player.inventory.find(i =>
i.type === 'potion' || i.type === 'weapon' || i.type === 'scroll'
);
if (!throwableItem) {
log('You have nothing to throw!', 'damage');
return;
}
currentActionContext = {
action: 'look-throw',
item: throwableItem
};
player.isLooking = true;
player.lookCursor = {
x: player.x,
y: player.y
};
document.getElementById('look-btn').classList.add('action-mode');
log(`Look-Throw: Aiming ${getItemDisplayName(throwableItem)}. Move cursor with directions, then Activate to throw.`, 'info');
updateStats();
needsRedraw = true;
break;
case 'look-shoot':
if (!player.rangedWeapon || !player.rangedWeapon.equipped) {
log('You need to equip a bow first!', 'damage');
return;
}

const ammoType = player.rangedWeapon.ammoType || 'arrows';
const ammoResult = getAvailableAmmo(ammoType);

if (!ammoResult) {
log(`You have no ${ammoType}!`, 'damage');
return;
}

currentActionContext = {
action: 'look-shoot',
ammo: ammoResult
};
player.isLooking = true;
player.lookCursor = {
x: player.x,
y: player.y
};
document.getElementById('look-btn').classList.add('action-mode');
log(`Look-Shoot: Aiming ${getItemDisplayName(player.rangedWeapon)}. Move cursor with directions, then Activate to shoot.`, 'info');
updateStats();
needsRedraw = true;
break;
case 'look-zap': {
const wand = player.inventory.find(i => i.type === 'wand');
if (!wand) {
log('You have no wand to zap!', 'damage');
return;
}
currentActionContext = {
action: 'look-zap',
item: wand
};
player.isLooking = true;
player.lookCursor = {
x: player.x,
y: player.y
};
document.getElementById('look-btn').classList.add('action-mode');
log(`Zapping ${getItemDisplayName(wand)}. Move cursor with direction keys, then click Activate to zap.`, 'info');
updateStats();
needsRedraw = true;
break;
}
case 'apply': {
  const tool = player.inventory.find(i => i.type === 'tool' && i.equipped);
  if (!tool) {
    log('You must equip a tool first (use it from inventory).', 'damage');
    return;
  }
  
  // Set up the action context
  currentActionContext = {
    action: 'apply',
    item: tool
  };
  
  log(`Apply your ${getItemDisplayName(tool)} in which direction?`, 'info');
  updateStats();
  break;
}
case 'use-feature':
cancelActionModes(); // disable to preserve look-action context
useFeature();
break;
}
});

document.getElementById('look-btn').addEventListener('click', (e) => {
e.stopPropagation();
e.preventDefault();

const btn = document.getElementById('look-btn');

// Simple toggle - if it's on, turn it off. If it's off, turn it on.
if (player.isLooking) {
// Turn OFF
player.isLooking = false;
btn.classList.remove('action-mode');

// Clear everything
currentActionContext = null;
player.lookCursor = {
x: player.x,
y: player.y
};
target = null;
targetName = null;
targetHP = null;

log('Look mode OFF.', 'info');

} else {
// Turn ON
player.isLooking = true;
btn.classList.add('action-mode');

player.lookCursor = {
x: player.x,
y: player.y
};

log('Look mode ON. Use direction keys to move the cursor.', 'info');
}

updateActivateButton();
needsRedraw = true;
});

document.getElementById('actions-btn').addEventListener('click', () => {
cancelActionModes(); // disable to preserve look-action context
document.getElementById('actions-modal').classList.add('show');
});

document.getElementById('actions-modal').addEventListener('click', (e) => {
  const action = e.target.dataset.action;
  if (action) {
    document.getElementById('actions-modal').classList.remove('show');
    switch (action) {
      case 'spellbook':
        showSpellbookModal();
        break;
        
      case 'search': 
        doSearch(); 
        break;
        
      case 'pray': 
        pray(); 
        break;
        
      case 'kick': 
        kick(); 
        break;
        
      case 'engrave': 
        engrave(); 
        break;
        
      case 'use-feature': 
        useFeature(); 
        break;
        
      case 'apply': {
        const tool = player.inventory.find(i => i.type === 'tool' && i.equipped);
        if (!tool) {
          log('You must equip a tool first (use it from inventory).', 'damage');
          return;
        }
        
        currentActionContext = {
          action: 'apply',
          item: tool
        };
        
        log(`Apply your ${getItemDisplayName(tool)} in which direction? (Use direction buttons)`, 'info');
        updateStats();
        break;
      }
      
      case 'zap':
        currentActionContext = {
          action: 'look-zap',
          item: null
        };
        log('Zap mode ON: Select a wand, then a direction.', 'info');
        updateStats();
        break;
        
      case 'disarm':
        const adjacentTrap = traps.find(t =>
          Math.abs(t.x - player.x) <= 1 &&
          Math.abs(t.y - player.y) <= 1 &&
          !t.hidden
        );

        if (adjacentTrap) {
          currentActionContext = {
            action: 'disarm'
          };
          log('Disarm which trap? (Choose direction)', 'info');
        } else {
          log('No visible traps nearby to disarm.', 'damage');
        }
        break;
        
      case 'rage':
        if (!player.canRage) {
          log('Only Barbarians can rage.', 'damage');
          return;
        }
        if (player.rageTurns > 0) {
          log('You are already enraged!', 'info');
          return;
        }
        if (!safeSpendAP(AP_COSTS.RAGE, 'enter rage')) return;

        player.rageTurns = 20;
        log('PRIMAL FURY COURSES THROUGH YOU!', 'damage');
        updateStats();
        processTurn();
        break;
        
      case 'look-throw':
        const throwableItem = player.inventory.find(i =>
          i.type === 'potion' || i.type === 'weapon' || i.type === 'scroll'
        );
        if (!throwableItem) {
          log('You have nothing to throw!', 'damage');
          return;
        }
        currentActionContext = {
          action: 'look-throw',
          item: throwableItem
        };
        player.isLooking = true;
        player.lookCursor = {
          x: player.x,
          y: player.y
        };
        document.getElementById('look-btn').classList.add('action-mode');
        log(`Throwing ${throwableItem.name}. Move cursor with direction keys, then click Activate to throw.`, 'info');
        updateStats();
        needsRedraw = true;
        break;

      case 'look-shoot':
        if (!player.rangedWeapon || !player.rangedWeapon.equipped) {
          log('You need to equip a bow first!', 'damage');
          return;
        }

        const ammoType = player.rangedWeapon.ammoType || 'arrows';
        const ammoResult = getAvailableAmmo(ammoType);

        if (!ammoResult) {
          log(`You have no ${ammoType}!`, 'damage');
          return;
        }

        currentActionContext = {
          action: 'look-shoot',
          ammo: ammoResult
        };
        player.isLooking = true;
        player.lookCursor = {
          x: player.x,
          y: player.y
        };
        document.getElementById('look-btn').classList.add('action-mode');
        log(`Look-Shoot: Aiming ${getItemDisplayName(player.rangedWeapon)}. Move cursor with directions, then Activate to shoot.`, 'info');
        updateStats();
        updateActivateButton();
        needsRedraw = true;
        break;
        
      case 'close': 
        cancelActionModes();
        break;
    }
  }
});

document.getElementById('toggle-action').addEventListener('click', (e) => {
e.preventDefault();
cancelActionModes(); // disable to preserve look-action context
itemAction = itemAction === 'use' ? 'drop': 'use';
const btn = document.getElementById('toggle-action');
if (itemAction === 'drop') {
btn.textContent = 'Drop Mode';
btn.classList.add('drop-mode');
log('Drop mode ON.', 'info');
} else {
btn.textContent = 'Use/Drop Mode';
btn.classList.remove('drop-mode');
log('Use mode ON.', 'info');
}
updateStats();
});

document.getElementById('shop-buy-tab').addEventListener('click', () => {
shopMode = 'buy';
updateShopDisplay();
});
document.getElementById('shop-sell-tab').addEventListener('click', () => {
shopMode = 'sell';
updateShopDisplay();
});
document.getElementById('shop-steal-tab').addEventListener('click', () => {
shopMode = 'steal';
updateShopDisplay();
});
document.getElementById('shop-close').addEventListener('click', () => {
document.getElementById('shop-modal').classList.remove('show');
currentShop = null;
processTurn();
});
document.getElementById('restart-btn').addEventListener('click', () => {
document.getElementById('restart-modal').classList.remove('show');
showCharSelect();
});
document.getElementById('char-select-modal').addEventListener('click', (e) => {
let role = null;
if (e.target.id === 'role-barbarian') role = 'Barbarian';
if (e.target.id === 'role-wizard') role = 'Wizard';
if (e.target.id === 'role-rogue') role = 'Rogue';
if (e.target.id === 'role-archer') role = 'Archer';
if (role) {
// Capture the player name from the input field
const playerNameInput = document.getElementById('player-name-input');
const playerName = playerNameInput.value.trim() || 'Anonymous';

document.getElementById('char-select-modal').classList.remove('show');
initGame(true, role);

// Set the player's name after creation
player.name = playerName;

requestAnimationFrame(gameLoop);
}
});
document.getElementById('zoom-toggle-btn').addEventListener('click', cycleZoom);
document.getElementById('save-btn').addEventListener('click', () => saveGame(true));
document.getElementById('load-btn').addEventListener('click', () => loadGame());
document.getElementById('debug-toggle').addEventListener('click', () => {
const el = document.getElementById('debug-overlay');
if (!el) return;
el.style.display = (el.style.display === 'none' || !el.style.display) ? 'block': 'none';
needsRedraw = true;
});

document.getElementById('activate-btn').addEventListener('click', () => {
  if (!player) return;

if (currentActionContext) {
    if (currentActionContext.action === 'cast-fireball') {
      const spell = currentActionContext.spell;
      executeFireball(spell, player.lookCursor.x, player.lookCursor.y);
      cancelActionModes();
      return;
    }
    
    if (currentActionContext.action === 'cast-piercing-shot') {
      const spell = currentActionContext.spell;
      const dx = Math.sign(player.lookCursor.x - player.x);
      const dy = Math.sign(player.lookCursor.y - player.y);
      if (dx !== 0 || dy !== 0) {
        executePiercingShot(spell, dx, dy);
        cancelActionModes();
        return;
      }
    }
  }

  // Handle Look-Mode actions
  if (player.isLooking && currentActionContext) {

    // Handle Look-Shoot
    if (currentActionContext.action === 'look-shoot') {
      if (currentActionContext.target || target) {
        executeRangedTarget();
        cancelActionModes();
        return;
      } else {
        log('Move cursor to a target first!', 'damage');
        return;
      }
    }

    // Handle Look-Throw
    if (currentActionContext.action === 'look-throw') {
      if (currentActionContext.target || target) {
        const dx = Math.sign(player.lookCursor.x - player.x);
        const dy = Math.sign(player.lookCursor.y - player.y);
        if (dx !== 0 || dy !== 0) {
          executeActionWithDirection(dx, dy);
          cancelActionModes();
          return;
        }
      }
      log('Choose a direction first!', 'damage');
      return;
    }

    // Handle Look-Zap
    if (currentActionContext.action === 'look-zap') {
      if (currentActionContext.target || target) {
        const dx = Math.sign(player.lookCursor.x - player.x);
        const dy = Math.sign(player.lookCursor.y - player.y);
        if (dx !== 0 || dy !== 0) {
          executeActionWithDirection(dx, dy);
          cancelActionModes();
          return;
        }
      }
      log('Choose a direction first!', 'damage');
      return;
    }

    log('Invalid action state!', 'damage');
    cancelActionModes();
    return;
  }

  // NEW: Check for adjacent container first
  const adjacentContainer = environmentals.find(e =>
    Math.abs(e.x - player.x) <= 1 &&
    Math.abs(e.y - player.y) <= 1 &&
    e.canOpen &&
    !e.isOpen
  );

  if (adjacentContainer) {
    handleEnvironmentalInteraction(adjacentContainer, 'open');
    return;
  }

  // Check for stairs
  if (isStairsAt(player.x, player.y)) {
    descendStairs();
  } else {
    // Default to search
    doSearch();
  }
});

document.getElementById('class-skill-btn').addEventListener('click', () => {
const btn = document.getElementById('class-skill-btn');

switch (player.role) {
case 'Archer':
player.autoRange = !player.autoRange;
if (player.autoRange) {
btn.textContent = '🎯 Auto-Range: ON';
btn.style.background = '#004400';
btn.style.borderColor = '#0ff';
log('Auto-range enabled. You will automatically fire at nearby foes.', 'pickup');
} else {
btn.textContent = '🎯 Auto-Range: OFF';
btn.style.background = '#002200';
btn.style.borderColor = '#0f0';
log('Auto-range disabled.', 'info');
}
break;

case 'Barbarian':
// Rage ability
if (player.rageTurns > 0) {
log('You are already enraged!', 'info');
return;
}
if (player.exhaustedTurns > 0) {
log('You are too exhausted to rage!', 'damage');
return;
}
if (!safeSpendAP(AP_COSTS.RAGE, 'enter rage')) return;

player.rageTurns = 20;
log('PRIMAL FURY COURSES THROUGH YOU!', 'damage');
updateStats();
processTurn();
break;

case 'Wizard':
// Auto-zap nearest enemy with a wand
const wand = player.inventory.find(i => i.type === 'wand' && i.charges > 0);
if (!wand) {
log('You have no charged wands!', 'damage');
return;
}

if (player.ap < AP_COSTS.AUTO_ZAP) {
log('Not enough AP to auto-zap!', 'damage');
return;
}

const nearestMonster = monsters.find(m => {
const dist = Math.hypot(m.x - player.x, m.y - player.y);
return dist <= 8 && visible[m.y][m.x] && hasLineOfSight(player.x, player.y, m.x, m.y);
});

if (nearestMonster) {
player.ap -= AP_COSTS.AUTO_ZAP; // Use AUTO_ZAP cost (0 AP)
const dx = Math.sign(nearestMonster.x - player.x);
const dy = Math.sign(nearestMonster.y - player.y);
currentActionContext = {
action: 'zap',
item: wand
};
actionHandlers.zap(dx, dy);
} else {
log('No visible enemies in range to zap!', 'info');
}
break;

case 'Rogue':
// Stealth/sneak - temporarily boost dodge
if (player.sneakTurns > 0) {
log('You are already sneaking!', 'info');
return;
}
if (!safeSpendAP(50, 'sneak', false)) return;

player.sneakTurns = 10;
log('You move silently into the shadows...', 'pickup');
updateStats();
processTurn();
break;

default:
log("You don't have a special class ability.", "info");
break;
}
});


function updateClassSkillButton() {
const btn = document.getElementById('class-skill-btn');
if (!btn) return;

switch (player.role) {
case 'Archer':
btn.textContent = player.autoRange ? '🎯 Auto-Range: ON': '🎯 Auto-Range: OFF';
if (player.autoRange) {
btn.style.background = '#004400';
btn.style.borderColor = '#0ff';
} else {
btn.style.background = '#002200';
btn.style.borderColor = '#0f0';
}
break;
case 'Barbarian':
btn.textContent = '💢 Rage';
btn.style.background = '#002200';
btn.style.borderColor = '#0f0';
break;
case 'Wizard':
btn.textContent = '⚡ Auto-Zap';
btn.style.background = '#002200';
btn.style.borderColor = '#0f0';
break;
case 'Rogue':
btn.textContent = '🗡️ Sneak';
btn.style.background = '#002200';
btn.style.borderColor = '#0f0';
break;
default:
btn.textContent = '🎯 Class Skill';
btn.style.background = '#002200';
btn.style.borderColor = '#0f0';
break;
}
}

function showStartScreen() {
const loadBtn = document.getElementById('start-load-game-btn');
const savedGame = localStorage.getItem(OFFLINE_SAVE_KEY);

if (savedGame) {
loadBtn.disabled = false;
} else {
loadBtn.disabled = true;
}
document.getElementById('start-screen-modal').classList.add('show');
}

document.getElementById('start-new-game-btn').addEventListener('click', () => {
document.getElementById('start-screen-modal').classList.remove('show');
showCharSelect();
});

document.getElementById('start-load-game-btn').addEventListener('click', () => {
document.getElementById('start-screen-modal').classList.remove('show');
loadGame();
requestAnimationFrame(gameLoop);
});

window.addEventListener('resize', resizeCanvas);
window.addEventListener('load', () => {
resizeCanvas();
showStartScreen();
if ('serviceWorker' in navigator) {
navigator.serviceWorker.register('sw.js').then(() => {
log('Offline ready.', 'pickup');
}).catch(() => {
log('Offline setup failed.', 'damage');
});
}
});

function processGasSpread() {
const gases = dungeon.features.filter(f => f.type === 'gas');
if (gases.length === 0) return;

const newGas = [];
const expiredGas = [];

for (const gas of gases) {
gas.duration -= 1;

// Apply damage to creatures in gas
[player,
...monsters,
...pets].forEach(e => {
if (e.x === gas.x && e.y === gas.y) {
const dmg = gas.toxicity || 1;
if (e === player) {
takeDamage(dmg, 'poison');
player.poisonTurns = (player.poisonTurns || 0) + 1;
log('You cough and choke on poisonous fumes!', 'damage');
} else {
e.hp -= dmg;
e.poisonTurns = (e.poisonTurns || 0) + 1;
if (e.hp <= 0) handleEntityDeath(player, e);
}
}
});

if (gas.duration <= 0) {
expiredGas.push(gas);
continue;
}

// Spread
for (let dy = -1; dy <= 1; dy++) {
for (let dx = -1; dx <= 1; dx++) {
if (dx === 0 && dy === 0) continue;

const nx = gas.x + dx;
const ny = gas.y + dy;
if (nx < 0 || nx >= WIDTH || ny < 0 || ny >= HEIGHT) continue;

const tile = dungeon.tiles[ny][nx];
const isOpen = tile === '.' || tile === '\'' || tile === '~';
const hasGas = dungeon.features.some(f => f.x === nx && f.y === ny && f.type === 'gas');

if (isOpen && !hasGas && Math.random() < (gas.spreadChance || 0.15)) {
newGas.push({
x: nx,
y: ny,
type: 'gas',
glyph: '~',
color: '#0f0',
spreadChance: gas.spreadChance || 0.15,
toxicity: gas.toxicity || 1,
duration: rollDice(1, 3, 2),
flammable: gas.flammable !== false
});
}
}
}
}

// Remove expired
if (expiredGas.length > 0) {
dungeon.features = dungeon.features.filter(f => !expiredGas.includes(f));
}

// Add new gas clouds (deduplicated)
if (newGas.length > 0) {
const unique = newGas.filter((f, i, arr) => i === arr.findIndex(o => o.x === f.x && o.y === f.y));
dungeon.features.push(...unique);
}

if (newGas.length > 0 || expiredGas.length > 0) needsRedraw = true;
}
// === Expand / Collapse & Floating Transparency for Log Console ===

(function setupFloatingLog() {
const log = document.getElementById('log');
if (!log) return;

let expanded = false;
let lastTap = 0;
let scrollTimeout;

// --- Expand / collapse on click ---
log.addEventListener('click', () => {
const now = Date.now();
if (now - lastTap < 300) return; // ignore double-taps
expanded = !expanded;
log.classList.toggle('expanded', expanded);
lastTap = now;
});

// --- Optional double-click toggle too ---
log.addEventListener('dblclick',
() => {
expanded = !expanded;
log.classList.toggle('expanded', expanded);
});

// --- Fade transparency when scrolling down ---
// --- Fade transparency when scrolling, then wake up after pause ---
window.addEventListener('scroll',
() => {
clearTimeout(scrollTimeout);

if (window.scrollY > 10) {
log.classList.add('floating');
} else {
log.classList.remove('floating');
}

// Temporarily make it fully visible while scrolling
log.classList.add('interacting');

// When scrolling stops for 1 second, fade back to transparent
scrollTimeout = setTimeout(() => {
log.classList.remove('interacting');
}, 1000);
});
if (typeof window.log === 'function') {
const origLog = window.log;
window.log = function(message, type) {
try {
expandLog(3);
} catch (e) {}
return origLog.apply(this, arguments);
};
}
})();

function hasAmmoInQuiver(player) {
// returns total arrows in player's quiver or 0
if (!player || !player.quiver) return 0;
return Number(player.quiver.arrows || 0);
}

function consumeAmmo(player, count = 1) {
    if (!player) return false;
    
    // 1) Check quiver first (accessory)
    const quiver = player.accessory?.baseName === 'quiver' ? player.accessory : null;
    if (quiver) {
        // Try arrows
        if (typeof quiver.arrows === 'number' && quiver.arrows >= count) {
            quiver.arrows -= count;
            return true;
        }
        // Try bolts
        if (typeof quiver.bolts === 'number' && quiver.bolts >= count) {
            quiver.bolts -= count;
            return true;
        }
    }
    
    // 2) Fall back to inventory stacks of ammo
    for (let i = 0; i < (player.inventory || []).length; i++) {
        const it = player.inventory[i];
        if (it && it.type === 'ammo' && typeof it.count === 'number' && it.count > 0) {
            const take = Math.min(it.count, count);
            it.count -= take;
            count -= take;
            if (it.count <= 0) {
                player.inventory.splice(i, 1);
                i--; // re-check same index
            }
            if (count <= 0) return true;
        }
    }
    
    return false;
}

function tryAutoRangedAttack() {
    // Only if auto-range is enabled
    if (!player.autoRange) return false;

    // Only for equipped ranged weapon
    if (!player.rangedWeapon || !player.rangedWeapon.equipped) {
        return false;
    }

    // Check for ammo
    const ammoType = player.rangedWeapon.ammoType || 'arrows';
    const ammoResult = getAvailableAmmo(ammoType);
    if (!ammoResult) return false;

    // Check AP - use AUTO_SHOOT cost (0 AP)
    if (player.ap < AP_COSTS.AUTO_SHOOT) return false;

    // Find nearest visible monster in range
    const range = player.rangedWeapon.range || 8;
    let nearestMonster = null;
    let nearestDist = Infinity;

    monsters.forEach(m => {
        if (!visible[m.y][m.x]) return;
        const dist = Math.hypot(m.x - player.x, m.y - player.y);
        if (dist <= range && dist > 1.5 && hasLineOfSight(player.x, player.y, m.x, m.y)) {
            if (dist < nearestDist) {
                nearestDist = dist;
                nearestMonster = m;
            }
        }
    });

    // Auto-shoot at nearest target
    if (nearestMonster) {
        // Spend AP for the shot - using AUTO_SHOOT cost
        player.ap -= AP_COSTS.AUTO_SHOOT;

        target = nearestMonster;
        currentActionContext = {
            action: 'look-shoot',
            target: nearestMonster
        };

        // Calculate damage
        const bow = player.rangedWeapon;
        const dmg = getRangedDamage(bow);  // ✅ Now this function exists

        // Apply damage
        takeMonsterDamage(nearestMonster, dmg, 'piercing', player);

        // NetHack-style output
        log(`You automatically fire at ${nearestMonster.name} for ${dmg} damage.`, 'damage');

        // Handle death
        if (nearestMonster.hp <= 0) {
            handleEntityDeath(player, nearestMonster);
        }

        // ✅ FIX: Use consumeAmmo function
        const ammoType = bow.ammoType || 'arrows';
        if (!consumeAmmo(player, 1)) {
            log(`You're out of ${ammoType}!`, 'damage');
            player.autoRange = false;
            updateClassSkillButton();
        }

        updateStats();
        return true; // Shot was fired
    }

    return false; // No valid target
}

function getRangedDamage(weapon) {
    let damage = rollDice(1, weapon.damage);
    
    if (player.strengthTurns > 0) {
        damage += 2;
    }
    
    if (player.ring && player.ring.equipped && player.ring.effect?.damageBonus) {
        damage += player.ring.effect.damageBonus;
    }
    
    if (player.exhaustedTurns > 0) {
        damage = Math.max(1, damage - 3);
    }
    
    return Math.max(1, damage);
}

function executeRangedTarget(mon = target, isAuto = false) {
    if (!player.rangedWeapon || !mon) return;
    const weapon = player.rangedWeapon;
    const ammoType = weapon.ammoType || 'arrows';
    const quiver = player.accessory?.baseName === 'quiver' ? player.accessory : null;

    if (quiver && quiver[ammoType] > 0) {
        quiver[ammoType]--;
        const dmg = getRangedDamage(weapon);
        takeMonsterDamage(mon, dmg, 'piercing', player);
        log(`You shoot ${mon.name} for ${dmg} damage.`, 'damage');
        
        if (mon.hp <= 0) {
            handleEntityDeath(player, mon);
        }

        if (quiver[ammoType] <= 0) {
            log(`Your quiver is empty!`, 'damage');
            autoRefillQuiver();
        }
        updateStats();
    }

    if (!isAuto) {
        player.ap -= AP_COSTS.SHOOT;
        processTurn();
    }
}

function spawnEnvironmentals(count) {
  environmentals = [];
  
  const validTypes = ENVIRONMENTAL_TYPES.filter(t => t.depth <= dungeonLevel);
  
  for (let i = 0; i < count; i++) {
    const type = validTypes[Math.floor(Math.random() * validTypes.length)];
    const room = dungeon.rooms[Math.floor(Math.random() * dungeon.rooms.length)];
    if (!room || room.isVault) continue;
    
    // Special spawning patterns based on type
    if (type.name === 'thorny vines') {
      spawnThornyCorridor(type);
    } else if (type.name === 'bookshelf') {
      spawnLibrary(room, type);
    } else if (type.name === 'barrel') {
      spawnBarrelCluster(room, type);
    } else if (type.name === 'wooden barrier' || type.name === 'iron barrier') {
      spawnBarricade(room, type);
    } else if (type.name === 'explosive barrel') {
      spawnExplosiveBarrel(room, type);
    } else {
      // Single spawn for chests and other containers
      const pos = findWalkable(room);
      environmentals.push({
        ...type,
        x: pos.x,
        y: pos.y,
        hp: type.hp,
        maxHp: type.maxHp,
        isOpen: false,
        discovered: false
      });
    }
  }
}

// Spawn thorny vines blocking a corridor
function spawnThornyCorridor(type) {
  // Find a corridor section (not in a room)
  const corridorTiles = [];
  
  for (let y = 1; y < HEIGHT - 1; y++) {
    for (let x = 1; x < WIDTH - 1; x++) {
      const tile = dungeon.tiles[y][x];
      if (tile === '.') {
        // Check if it's a narrow corridor (walls on 2+ sides)
        const walls = [
          dungeon.tiles[y-1][x] === '#',
          dungeon.tiles[y+1][x] === '#',
          dungeon.tiles[y][x-1] === '#',
          dungeon.tiles[y][x+1] === '#'
        ].filter(w => w).length;
        
        if (walls >= 2) {
          const inRoom = dungeon.rooms.some(r => 
            x >= r.x && x < r.x + r.w && y >= r.y && y < r.y + r.h
          );
          
          if (!inRoom) {
            corridorTiles.push({x, y});
          }
        }
      }
    }
  }
  
  if (corridorTiles.length === 0) return;
  
  // Pick a random corridor tile
  const start = corridorTiles[Math.floor(Math.random() * corridorTiles.length)];
  
  // Determine corridor direction
  const isVertical = dungeon.tiles[start.y-1][start.x] === '#' || 
                     dungeon.tiles[start.y+1][start.x] === '#';
  
  // Spawn 2-4 vines in a line
  const vineCount = 2 + Math.floor(Math.random() * 3);
  
  for (let i = 0; i < vineCount; i++) {
    const x = isVertical ? start.x : start.x + i;
    const y = isVertical ? start.y + i : start.y;
    
    if (x >= WIDTH || y >= HEIGHT || dungeon.tiles[y][x] !== '.') break;
    if (environmentals.some(e => e.x === x && e.y === y)) continue;
    if (monsters.some(m => m.x === x && m.y === y)) continue;
    
    environmentals.push({
      ...type,
      x, y,
      hp: type.hp,
      maxHp: type.maxHp,
      isOpen: false,
      discovered: false
    });
  }
}

// Spawn bookshelves along room walls (library style)
function spawnLibrary(room, type) {
  const shelves = [];
  const shelfCount = 3 + Math.floor(Math.random() * 4);
  
  // Try to line shelves along one wall
  const wall = Math.floor(Math.random() * 4); // 0=north, 1=east, 2=south, 3=west
  
  for (let i = 0; i < shelfCount; i++) {
    let x, y;
    
    switch (wall) {
      case 0: // North wall
        x = room.x + 1 + i;
        y = room.y + 1;
        break;
      case 1: // East wall
        x = room.x + room.w - 2;
        y = room.y + 1 + i;
        break;
      case 2: // South wall
        x = room.x + 1 + i;
        y = room.y + room.h - 2;
        break;
      case 3: // West wall
        x = room.x + 1;
        y = room.y + 1 + i;
        break;
    }
    
    if (x >= room.x + room.w - 1 || y >= room.y + room.h - 1) break;
    if (environmentals.some(e => e.x === x && e.y === y)) continue;
    if (x === player?.x && y === player?.y) continue;
    
    shelves.push({
      ...type,
      x, y,
      hp: type.hp,
      maxHp: type.maxHp,
      isOpen: false,
      discovered: false
    });
  }
  
  environmentals.push(...shelves);
}

// Spawn barrels in a cluster (storage room style)
function spawnBarrelCluster(room, type) {
  const clusterSize = 3 + Math.floor(Math.random() * 4);
  const centerX = room.x + Math.floor(room.w / 2);
  const centerY = room.y + Math.floor(room.h / 2);
  
  const positions = [
    {dx: 0, dy: 0},
    {dx: -1, dy: 0}, {dx: 1, dy: 0},
    {dx: 0, dy: -1}, {dx: 0, dy: 1},
    {dx: -1, dy: -1}, {dx: 1, dy: -1},
    {dx: -1, dy: 1}, {dx: 1, dy: 1}
  ];
  
  for (let i = 0; i < Math.min(clusterSize, positions.length); i++) {
    const pos = positions[i];
    const x = centerX + pos.dx;
    const y = centerY + pos.dy;
    
    if (x <= room.x || x >= room.x + room.w - 1) continue;
    if (y <= room.y || y >= room.y + room.h - 1) continue;
    if (environmentals.some(e => e.x === x && e.y === y)) continue;
    if (x === player?.x && y === player?.y) continue;
    
    environmentals.push({
      ...type,
      x, y,
      hp: type.hp,
      maxHp: type.maxHp,
      isOpen: false,
      discovered: false
    });
  }
}

// Spawn barriers blocking room entrance or creating maze-like obstacles
function spawnBarricade(room, type) {
  const barrierCount = 2 + Math.floor(Math.random() * 3);
  
  // Option 1: Block a doorway (30% chance)
  if (Math.random() < 0.3) {
    // Find doors connected to this room
    const nearbyDoors = dungeon.features.filter(f => 
      f.type === 'door' &&
      Math.abs(f.x - room.cx) < room.w &&
      Math.abs(f.y - room.cy) < room.h
    );
    
    if (nearbyDoors.length > 0) {
      const door = nearbyDoors[Math.floor(Math.random() * nearbyDoors.length)];
      
      // Place barriers adjacent to door
      const directions = [{dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy: -1}];
      
      for (let i = 0; i < Math.min(barrierCount, 2); i++) {
        const dir = directions[i];
        const x = door.x + dir.dx;
        const y = door.y + dir.dy;
        
        if (!isWalkable(x, y)) continue;
        if (environmentals.some(e => e.x === x && e.y === y)) continue;
        
        environmentals.push({
          ...type,
          x, y,
          hp: type.hp,
          maxHp: type.maxHp,
          isOpen: false,
          discovered: false
        });
      }
      return;
    }
  }
  
  // Option 2: Create a line of barriers in the room (maze-like)
  const isVertical = Math.random() < 0.5;
  const startX = room.x + 2 + Math.floor(Math.random() * (room.w - 4));
  const startY = room.y + 2 + Math.floor(Math.random() * (room.h - 4));
  
  for (let i = 0; i < barrierCount; i++) {
    const x = isVertical ? startX : startX + i;
    const y = isVertical ? startY + i : startY;
    
    if (x >= room.x + room.w - 1 || y >= room.y + room.h - 1) break;
    if (!isWalkable(x, y)) continue;
    if (environmentals.some(e => e.x === x && e.y === y)) continue;
    if (x === player?.x && y === player?.y) continue;
    
    environmentals.push({
      ...type,
      x, y,
      hp: type.hp,
      maxHp: type.maxHp,
      isOpen: false,
      discovered: false
    });
  }
}

// Spawn explosive barrels away from player start but near monsters
function spawnExplosiveBarrel(room, type) {
  // Don't spawn in first room (where player starts)
  if (room === dungeon.rooms[0]) {
    room = dungeon.rooms[Math.floor(Math.random() * (dungeon.rooms.length - 1)) + 1];
  }
  
  const pos = findWalkable(room);
  
  // Try to spawn near a monster for tactical gameplay
  const nearbyMonster = monsters.find(m => 
    Math.abs(m.x - pos.x) < 4 && 
    Math.abs(m.y - pos.y) < 4
  );
  
  if (nearbyMonster) {
    // Position between player start and monster
    const midX = Math.floor((dungeon.rooms[0].cx + nearbyMonster.x) / 2);
    const midY = Math.floor((dungeon.rooms[0].cy + nearbyMonster.y) / 2);
    
    if (isWalkable(midX, midY)) {
      pos.x = midX;
      pos.y = midY;
    }
  }
  
  environmentals.push({
    ...type,
    x: pos.x,
    y: pos.y,
    hp: type.hp,
    maxHp: type.maxHp,
    isOpen: false,
    discovered: false
  });
}

function getEnvironmentalAt(x, y) {
  return environmentals.find(e => e.x === x && e.y === y);
}

function handleEnvironmentalInteraction(env, action = 'bump') {
  if (action === 'bump') {
    // HAZARDS - damage on bump
    if (env.type === 'hazard' && env.bumpDamage) {
      takeDamage(env.bumpDamage);
      log(env.damageMessage || `You are hurt by the ${env.name}!`, 'damage');
      return true;
    }
    
    // PUSHABLE - try to push
    if (env.pushable) {
      return tryPushEnvironmental(env);
    }
    
    // Otherwise just block movement
    log(`You bump into the ${env.name}.`, 'info');
    return false;
  }
  
  if (action === 'open') {
    if (!env.canOpen) {
      log(`You cannot open the ${env.name}.`, 'info');
      return false;
    }
    
    if (env.isOpen) {
      log(`The ${env.name} is already open.`, 'info');
      return false;
    }
    
    if (env.locked) {
      const key = player.inventory.find(i => i.type === 'key');
      if (key) {
        env.locked = false;
        log('You unlock the container.', 'pickup');
        player.inventory.splice(player.inventory.indexOf(key), 1);
      } else {
        log(`The ${env.name} is locked!`, 'damage');
        return false;
      }
    }
    
    openContainer(env);
    return true;
  }
  
  if (action === 'attack') {
    return attackEnvironmental(env);
  }
}

function tryPushEnvironmental(env) {
  const dx = Math.sign(env.x - player.x);
  const dy = Math.sign(env.y - player.y);
  
  const newX = env.x + dx;
  const newY = env.y + dy;
  
  // Check if destination is valid
  if (newX < 0 || newX >= WIDTH || newY < 0 || newY >= HEIGHT) {
    log(`You can't push the ${env.name} that way.`, 'info');
    return false;
  }
  
  const targetTile = dungeon.tiles[newY][newX];
  const doorAtTarget = dungeon.features.find(f => f.x === newX && f.y === newY && f.type === 'door');
  const blockedByMonster = monsters.some(m => m.x === newX && m.y === newY);
  const blockedByEnv = environmentals.some(e => e.x === newX && e.y === newY);
  
  // Push into wall or closed door = break
  if (targetTile === '#' || (doorAtTarget && !doorAtTarget.open)) {
    if (env.breakable) {
      log(`The ${env.name} shatters against the ${doorAtTarget ? 'door' : 'wall'}!`, 'damage');
      
      // If it's an explosive barrel, damage the door
      if (env.type === 'explosive' && doorAtTarget) {
        log('The explosion blasts the door open!', 'pickup');
        doorAtTarget.open = true;
        doorAtTarget.locked = false;
        dungeon.tiles[newY][newX] = '\'';
        needsRedraw = true;
      }
      
      destroyEnvironmental(env);
      return true;
    } else {
      log(`You can't push the ${env.name} into the ${doorAtTarget ? 'door' : 'wall'}.`, 'info');
      return false;
    }
  }
  
  // Can't push into occupied space
  if (blockedByMonster || blockedByEnv || !isWalkable(newX, newY)) {
    log(`You can't push the ${env.name} there.`, 'info');
    return false;
  }
  
  // Successfully push
  env.x = newX;
  env.y = newY;
  log(`You push the ${env.name}.`, 'info');
  
  player.ap -= AP_COSTS.MOVE;
  processTurn();
  needsRedraw = true;
  return true;
}

function openContainer(env) {
  if (!safeSpendAP(50, 'open container', true)) return;
  
  env.isOpen = true;
  env.glyph = '▣'; // Open chest visual
  log(`You open the ${env.name}.`, 'pickup');
  
  // Generate loot
  const [minLoot, maxLoot] = env.lootCount || [1, 3];
  const lootAmount = rollDice(1, maxLoot - minLoot + 1, minLoot - 1);
  
  for (let i = 0; i < lootAmount; i++) {
    const lootCategory = env.lootTable[Math.floor(Math.random() * env.lootTable.length)];
    
    if (lootCategory === 'gold') {
      const goldValue = rollDice(2, 10, dungeonLevel * 5);
      items.push({
        x: env.x,
        y: env.y,
        glyph: '$',
        name: 'gold',
        color: '#ff0',
        value: goldValue,
        identified: true,
        type: 'gold',
        baseName: 'gold'
      });
    } else {
      const validItems = ITEM_TYPES.filter(i => 
        i.type === lootCategory && 
        i.depth <= dungeonLevel + 1 &&
        !i.isStairs
      );
      
      if (validItems.length > 0) {
        const itemType = validItems[Math.floor(Math.random() * validItems.length)];
        const newItem = {
          ...itemType,
          x: env.x,
          y: env.y,
          name: itemType.identified ? (itemType.baseName || itemType.name) : 
                (itemType.visualName || itemType.baseName || itemType.name),
          identified: itemType.identified || false,
          status: generateItemStatus()
        };
        items.push(newItem);
      }
    }
  }
  
  log(`You find ${lootAmount} item(s) inside!`, 'pickup');
  
  // Check if player is standing on the chest already
  const itemsHere = items.filter(i => i.x === player.x && i.y === player.y);
  if (itemsHere.length > 0) {
    log(`Items here: ${itemsHere.map(getItemDisplayName).join(', ')}.`, 'info');
  }
  
  processTurn();
  needsRedraw = true;
}

function attackEnvironmental(env) {
  if (!env.breakable) {
    log(`The ${env.name} is indestructible!`, 'info');
    return false;
  }
  
  if (player.ap < AP_COSTS.ATTACK) {
    log('Not enough AP to attack!', 'damage');
    return false;
  }
  
  player.ap -= AP_COSTS.ATTACK;
  
  const damage = calculateDamage(player, {defense: 0});
  env.hp -= damage;
  
  log(`You hit the ${env.name} for ${damage} damage! (${env.hp}/${env.maxHp} HP)`, 'damage');
  
  if (env.hp <= 0) {
    destroyEnvironmental(env);
  }
  
  processTurn();
  return true;
}

function destroyEnvironmental(env) {
  // EXPLOSIVE - kaboom!
  if (env.type === 'explosive') {
    log(`The ${env.name} EXPLODES!`, 'damage');
    
    const radius = env.explosionRadius || 2;
    const [minDmg, maxDmg] = env.explosionDamage || [2, 6];
    
    // Damage everything in radius
    for (let dy = -radius; dy <= radius; dy++) {
      for (let dx = -radius; dx <= radius; dx++) {
        const dist = Math.hypot(dx, dy);
        if (dist > radius) continue;
        
        const x = env.x + dx;
        const y = env.y + dy;
        
        const explosionDmg = rollDice(minDmg, maxDmg);
        
        // Player
        if (player.x === x && player.y === y) {
          takeDamage(explosionDmg);
          log('You are caught in the explosion!', 'damage');
        }
        
        // Monsters
        monsters.forEach(m => {
          if (m.x === x && m.y === y) {
            m.hp -= explosionDmg;
            if (m.hp <= 0) handleEntityDeath(player, m);
          }
        });
        
        // Other environmentals
        environmentals.forEach(e => {
          if (e !== env && e.x === x && e.y === y && e.breakable) {
            e.hp -= explosionDmg;
            if (e.hp <= 0) {
              log(`The ${e.name} is destroyed in the blast!`, 'damage');
              environmentals = environmentals.filter(o => o !== e);
            }
          }
        });
      }
    }
  }
  
  // Drop any unopened loot
  if (env.type === 'container' && !env.isOpen && Math.random() < 0.3) {
    const lootCategory = env.lootTable[Math.floor(Math.random() * env.lootTable.length)];
    if (lootCategory === 'gold') {
      const goldValue = rollDice(1, 10, dungeonLevel * 2);
      items.push({
        x: env.x,
        y: env.y,
        glyph: '$',
        name: 'gold',
        color: '#ff0',
        value: goldValue,
        identified: true,
        type: 'gold',
        baseName: 'gold'
      });
    }
  }
  
  log(`The ${env.name} is destroyed!`, 'damage');
  environmentals = environmentals.filter(e => e !== env);
  needsRedraw = true;
}

function showSpellbookModal() {
  const modal = document.getElementById('spellbook-modal');
  const spellList = document.getElementById('spell-list');
  
  spellList.innerHTML = '';
  
  if (!player.spells || player.spells.length === 0) {
    spellList.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">No spells learned yet.</div>';
  } else {
    player.spells.forEach(spellKey => {
      const spell = SPELL_TYPES[spellKey];
      
      const spellDiv = document.createElement('button');
      spellDiv.className = 'modal-btn';
      spellDiv.style.cssText = `
        text-align: left;
        padding: 10px;
        background: ${player.ap >= spell.cost ? '#002200' : '#220000'};
        opacity: ${player.ap >= spell.cost ? '1' : '0.5'};
        cursor: ${player.ap >= spell.cost ? 'pointer' : 'not-allowed'};
      `;
      
      spellDiv.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <div style="flex: 1;">
            <div style="font-weight: bold; font-size: 14px;">${spell.name}</div>
            <div style="font-size: 11px; color: #888; margin-top: 2px;">${spell.description}</div>
          </div>
          <div style="text-align: right;">
            <div style="color: #0af; font-weight: bold;">${spell.cost} AP</div>
          </div>
        </div>
      `;
      
      spellDiv.addEventListener('click', () => {
        if (player.ap >= spell.cost) {
          modal.classList.remove('show');
          castSpell(spellKey);
        }
      });
      
      spellList.appendChild(spellDiv);
    });
  }
  
  modal.classList.add('show');
}

document.getElementById('close-spellbook').addEventListener('click', () => {
  document.getElementById('spellbook-modal').classList.remove('show');
});

document.addEventListener('DOMContentLoaded', () => {
const title = document.querySelector('h1');
if (!title) return;

setTimeout(() => title.classList.add('flash'), 0);
// Step 1: fade out after 1s
setTimeout(() => title.classList.add('fade-out'), 2000);

// Step 2: shrink and vanish after fade completes
setTimeout(() => title.classList.add('hide'), 10000);
});


const statsHeader = document.getElementById('stats-header');
const statsBody = document.getElementById('stats-body');
const statsArrow = document.getElementById('stats-arrow');
const statsArrow2 = document.getElementById('stats-arrow-2');
let statsCollapsed = false;

statsHeader.addEventListener('click', () => {
statsCollapsed = !statsCollapsed;
statsBody.style.display = statsCollapsed ? 'none': 'block';
statsArrow.textContent = statsCollapsed ? '▲': '▼';
statsArrow2.textContent = statsCollapsed ? '▲': '▼';
});

const invHeader = document.getElementById('inventory-header');
const invBody = document.getElementById('inventory-body');
let invCollapsed = false;

invHeader.addEventListener('click', () => {
invCollapsed = !invCollapsed;
invBody.style.display = invCollapsed ? 'none': 'block';
invHeader.textContent = invCollapsed ? 'Inventory ▲': 'Inventory ▼';
});
</script>
</body>
</html>
