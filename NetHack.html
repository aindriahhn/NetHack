<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NetHack Roguelike</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #000;
      color: #0f0;
      font-family: 'Courier New', monospace;
      display: flex;
      gap: 20px;
      justify-content: center;
    }
    #game-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    canvas {
      border: 2px solid #0f0;
      background: #000;
      image-rendering: pixelated;
    }
    #stats {
      padding: 10px;
      border: 2px solid #0f0;
      background: #001100;
    }
    #log {
      padding: 10px;
      border: 2px solid #0f0;
      background: #001100;
      height: 150px;
      overflow-y: auto;
      font-size: 12px;
    }
    .log-entry { margin: 2px 0; }
    .damage { color: #f00; }
    .pickup { color: #ff0; }
    .death { color: #f0f; }
    #controls {
      display: grid;
      grid-template-columns: repeat(3, 60px);
      grid-template-rows: repeat(3, 60px);
      gap: 5px;
      margin: 0 auto;
      width: fit-content;
    }
    .control-btn {
      background: #001100;
      border: 2px solid #0f0;
      color: #0f0;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.1s;
    }
    .control-btn:hover {
      background: #002200;
      border-color: #0ff;
    }
    .control-btn:active {
      background: #003300;
      transform: scale(0.95);
    }
    .control-btn.center {
      background: #000;
      cursor: default;
      border-color: #050;
    }
    .control-btn.center:hover {
      background: #000;
      border-color: #050;
    }
    #restart-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #restart-modal.show {
      display: flex;
    }
    .modal-content {
      background: #001100;
      border: 3px solid #f00;
      padding: 30px;
      text-align: center;
      max-width: 400px;
    }
    .modal-content h2 {
      color: #f00;
      margin: 0 0 20px 0;
      font-size: 32px;
    }
    .modal-stats {
      margin: 20px 0;
      color: #0f0;
      font-size: 16px;
      line-height: 1.8;
    }
    #restart-btn {
      background: #002200;
      border: 2px solid #0f0;
      color: #0f0;
      padding: 12px 30px;
      font-size: 18px;
      font-family: 'Courier New', monospace;
      cursor: pointer;
      margin-top: 10px;
    }
    #restart-btn:hover {
      background: #003300;
      border-color: #0ff;
    }
    @media (max-width: 768px) {
      body {
        padding: 10px;
        flex-direction: column;
        align-items: center;
      }
      canvas {
        width: 100%;
        height: auto;
      }
      #controls {
        grid-template-columns: repeat(3, 70px);
        grid-template-rows: repeat(3, 70px);
      }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="nethack" width="640" height="480"></canvas>
    <div id="stats">
      <div>HP: <span id="hp">20/20</span> | Level: <span id="level">1</span> | XP: <span id="xp">0</span> | Depth: <span id="depth">1</span></div>
      <div>Weapon: <span id="weapon">Fists</span> | Gold: <span id="gold">0</span></div>
    </div>
    <div id="log">
      <div class="log-entry">Welcome to NetHack! Use arrow keys to move. Bump into monsters to attack.</div>
    </div>
    <div id="inventory" style="padding: 10px; border: 2px solid #0f0; background: #001100; max-height: 150px; overflow-y: auto; font-size: 12px;">
      <div>Inventory (Keys 1-5 to use): <span id="inventory-list">Empty</span></div>
    </div>
    <div id="controls">
      <button class="control-btn" data-dir="nw">↖</button>
      <button class="control-btn" data-dir="n">↑</button>
      <button class="control-btn" data-dir="ne">↗</button>
      <button class="control-btn" data-dir="w">←</button>
      <button class="control-btn center">@</button>
      <button class="control-btn" data-dir="e">→</button>
      <button class="control-btn" data-dir="sw">↙</button>
      <button class="control-btn" data-dir="s">↓</button>
      <button class="control-btn" data-dir="se">↘</button>
    </div>
  </div>

  <div id="restart-modal">
    <div class="modal-content">
      <h2>YOU DIED</h2>
      <div class="modal-stats">
        <div>Final Level: <span id="final-level">1</span></div>
        <div>Gold Collected: <span id="final-gold">0</span></div>
        <div>Monsters Slain: <span id="final-kills">0</span></div>
        <div>Turns Survived: <span id="final-turns">0</span></div>
      </div>
      <button id="restart-btn">Play Again</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("nethack");
    const ctx = canvas.getContext("2d");
    const TILE_SIZE = 16;
    const WIDTH = 40;
    const HEIGHT = 30;
    
    ctx.font = `${TILE_SIZE}px monospace`;
    
    // Game state
    let player = {
      x: 0, y: 0,
      glyph: '@', color: '#fff',
      hp: 20, maxHp: 20,
      level: 1, xp: 0,
      weapon: null,
      gold: 0,
      inventory: [], // Array to store items
      inventorySize: 5 // Maximum inventory slots
    };
    
    let dungeon = { tiles: [], width: WIDTH, height: HEIGHT };
    let monsters = [];
    let items = [];
    let traps = [];
    let turn = 0;
    let kills = 0;
    let dungeonLevel = 1;
    
    // Monster types
    const MONSTER_TYPES = [
      { glyph: 'g', name: 'goblin', color: '#0a0', hp: 5, damage: 2, xp: 5 },
      { glyph: 'o', name: 'orc', color: '#f80', hp: 8, damage: 3, xp: 10 },
      { glyph: 'T', name: 'troll', color: '#0f0', hp: 15, damage: 5, xp: 20 },
      { glyph: 'D', name: 'dragon', color: '#f00', hp: 30, damage: 8, xp: 50 }
    ];
    
    // Item types (Updated with healing potion)
    const ITEM_TYPES = [
      { glyph: ')', name: 'dagger', color: '#ccc', damage: 3 },
      { glyph: ')', name: 'sword', color: '#aaf', damage: 5 },
      { glyph: ')', name: 'axe', color: '#faa', damage: 7 },
      { glyph: '$', name: 'gold', color: '#ff0', value: 0 },
      { glyph: '>', name: 'stairs', color: '#fff', isStairs: true },
      { glyph: '!', name: 'healing potion', color: '#0ff', heal: 5 }
    ];

    // Define trap types (Updated to be hidden)
    const TRAP_TYPES = [
      { glyph: '^', name: 'spike trap', color: '#f00', damage: 5, hidden: true },
      { glyph: '^', name: 'teleport trap', color: '#0ff', teleport: true, hidden: true },
      { glyph: '^', name: 'poison trap', color: '#0f0', poison: 3, hidden: true }
    ];
    
    // Generate dungeon with rooms and corridors
    function generateDungeon(w, h) {
      let tiles = Array(h).fill().map(() => Array(w).fill('#'));
      let rooms = [];
      
      // Generate rooms
      for (let i = 0; i < 15; i++) {
        let rw = Math.floor(Math.random() * 6) + 4;
        let rh = Math.floor(Math.random() * 4) + 3;
        let rx = Math.floor(Math.random() * (w - rw - 2)) + 1;
        let ry = Math.floor(Math.random() * (h - rh - 2)) + 1;
        
        // Check overlap
        let overlap = false;
        for (let room of rooms) {
          if (rx < room.x + room.w + 1 && rx + rw + 1 > room.x &&
              ry < room.y + room.h + 1 && ry + rh + 1 > room.y) {
            overlap = true;
            break;
          }
        }
        
        if (!overlap) {
          // Carve room
          for (let y = ry; y < ry + rh; y++) {
            for (let x = rx; x < rx + rw; x++) {
              tiles[y][x] = '.';
            }
          }
          rooms.push({ x: rx, y: ry, w: rw, h: rh, 
                       cx: Math.floor(rx + rw / 2), 
                       cy: Math.floor(ry + rh / 2) });
        }
      }
      
      // Connect rooms with corridors
      for (let i = 1; i < rooms.length; i++) {
        let prev = rooms[i - 1];
        let curr = rooms[i];
        
        // Horizontal then vertical corridor
        if (Math.random() < 0.5) {
          // Horizontal
          for (let x = Math.min(prev.cx, curr.cx); x <= Math.max(prev.cx, curr.cx); x++) {
            tiles[prev.cy][x] = '.';
          }
          // Vertical
          for (let y = Math.min(prev.cy, curr.cy); y <= Math.max(prev.cy, curr.cy); y++) {
            tiles[y][curr.cx] = '.';
          }
        } else {
          // Vertical
          for (let y = Math.min(prev.cy, curr.cy); y <= Math.max(prev.cy, curr.cy); y++) {
            tiles[y][prev.cx] = '.';
          }
          // Horizontal
          for (let x = Math.min(prev.cx, curr.cx); x <= Math.max(prev.cx, curr.cx); x++) {
            tiles[curr.cy][x] = '.';
          }
        }
      }
      
      return { tiles, width: w, height: h, rooms };
    }
    
    // Find walkable position
    function findWalkable() {
      while (true) {
        let x = Math.floor(Math.random() * (WIDTH - 2)) + 1;
        let y = Math.floor(Math.random() * (HEIGHT - 2)) + 1;
        // Check if walkable and not overlapping player, monsters, items, or traps
        if (dungeon.tiles[y][x] === '.' && 
            !(x === player.x && y === player.y) &&
            !monsters.some(m => m.x === x && m.y === y) &&
            !items.some(i => i.x === x && i.y === y) &&
            !traps.some(t => t.x === x && t.y === y)) {
          return { x, y };
        }
      }
    }

    // New: Find a walkable position that isn't adjacent to a monster
    function findSafeWalkable() {
      let attempts = 0;
      const maxAttempts = 10;
      while (attempts < maxAttempts) {
        const pos = findWalkable();
        // Check if any monster is adjacent
        const isSafe = !monsters.some(m => Math.abs(m.x - pos.x) <= 1 && Math.abs(m.y - pos.y) <= 1);
        if (isSafe) return pos;
        attempts++;
      }
      return findWalkable(); // Fallback to any walkable position
    }
    
    // Spawn monsters
    function spawnMonsters(count) {
      monsters = [];
      for (let i = 0; i < count; i++) {
        let type = MONSTER_TYPES[Math.floor(Math.random() * Math.min(MONSTER_TYPES.length, 1 + player.level))];
        let pos = findWalkable();
        monsters.push({
          ...pos,
          glyph: type.glyph,
          color: type.color,
          name: type.name,
          hp: type.hp,
          maxHp: type.hp,
          damage: type.damage,
          xp: type.xp
        });
      }
    }
    
    // Spawn items
    function spawnItems(count) {
      items = [];
      // Always spawn one stair
      let stairPos = findWalkable();
      items.push({
        x: stairPos.x,
        y: stairPos.y,
        glyph: '>',
        color: '#fff',
        name: 'stairs',
        isStairs: true
      });
      // Spawn other items
      for (let i = 0; i < count; i++) {
        // Exclude stairs from random item generation
        let itemIndex = Math.floor(Math.random() * (ITEM_TYPES.length - 1));
        let type = ITEM_TYPES[itemIndex]; 
        let pos = findWalkable();
        let item = {
          ...pos,
          glyph: type.glyph,
          color: type.color,
          name: type.name
        };
        if (type.damage) item.damage = type.damage;
        if (type.value !== undefined) item.value = Math.floor(Math.random() * 50) + 10;
        if (type.heal) item.heal = type.heal;
        items.push(item);
      }
    }

    // Spawn traps
    function spawnTraps(count) {
      traps = [];
      for (let i = 0; i < count; i++) {
        let type = TRAP_TYPES[Math.floor(Math.random() * TRAP_TYPES.length)];
        let pos = findWalkable();
        // findWalkable already checks for overlaps with player, monsters, and items
        traps.push({ ...pos, ...type });
      }
    }
    
    // Initialize game
    function initGame() {
      dungeon = generateDungeon(WIDTH, HEIGHT);
      let pos = findWalkable(); // findWalkable will find a good spot
      player.x = pos.x;
      player.y = pos.y;
      player.hp = player.maxHp;
      // Adjust monster count for difficulty
      spawnMonsters(Math.min(30, 10 + dungeonLevel * 2)); 
      spawnItems(8);
      spawnTraps(5); // Spawn 5 traps per level
      turn = 0;
      document.getElementById('restart-modal').classList.remove('show');
      updateStats();
      gameLoop();
    }
    
    // Show death modal
    function showDeathScreen() {
      document.getElementById('final-level').textContent = player.level;
      document.getElementById('final-gold').textContent = player.gold;
      document.getElementById('final-kills').textContent = kills;
      document.getElementById('final-turns').textContent = turn;
      document.getElementById('restart-modal').classList.add('show');
    }
    
    // Restart game
    function restartGame() {
      player.hp = 20;
      player.maxHp = 20;
      player.level = 1;
      player.xp = 0;
      player.weapon = null;
      player.gold = 0;
      player.inventory = [];
      dungeonLevel = 1;
      kills = 0;
      document.getElementById('log').innerHTML = '<div class="log-entry">Welcome to NetHack! Use arrow keys to move. Bump into monsters to attack.</div>';
      initGame();
    }
    
    // Log message
    function log(msg, cls = '') {
      const logDiv = document.getElementById('log');
      const entry = document.createElement('div');
      entry.className = `log-entry ${cls}`;
      entry.textContent = msg;
      logDiv.appendChild(entry);
      logDiv.scrollTop = logDiv.scrollHeight;
    }
    
    // Update stats display
    function updateStats() {
      document.getElementById('hp').textContent = `${player.hp}/${player.maxHp}`;
      document.getElementById('level').textContent = player.level;
      document.getElementById('xp').textContent = player.xp;
      document.getElementById('weapon').textContent = player.weapon ? player.weapon.name : 'Fists';
      document.getElementById('gold').textContent = player.gold;
      document.getElementById('depth').textContent = dungeonLevel;
      document.getElementById('inventory-list').textContent = player.inventory.length > 0 
        ? player.inventory.map((item, i) => `(${i + 1}) ${item.name}`).join(', ') 
        : 'Empty';
    }
    
    // Combat
    function attack(attacker, defender) {
      let damage = attacker === player 
        ? (player.weapon ? player.weapon.damage : 2)
        : attacker.damage;
      damage = Math.max(1, damage + Math.floor(Math.random() * 3) - 1);
      
      defender.hp -= damage;
      
      if (attacker === player) {
        log(`You hit the ${defender.name} for ${damage} damage!`, 'damage');
      } else {
        log(`The ${attacker.name} hits you for ${damage} damage!`, 'damage');
      }
      
      if (defender.hp <= 0) {
        if (defender === player) {
          log('You died!', 'death');
          setTimeout(showDeathScreen, 500);
        } else {
          kills++;
        }
        return true;
      }
      
      return false;
    }
    
    // Check for level up
    function checkLevelUp() {
      let needed = player.level * 20;
      if (player.xp >= needed) {
        player.level++;
        player.maxHp += 5;
        player.hp = player.maxHp;
        log(`Level up! You are now level ${player.level}!`, 'pickup');
        updateStats();
      }
    }
    
    // Move entity (Updated to handle traps and inventory)
    function moveEntity(entity, dx, dy) {
      let newX = entity.x + dx;
      let newY = entity.y + dy;
      
      if (newX < 0 || newX >= WIDTH || newY < 0 || newY >= HEIGHT) return false;
      if (dungeon.tiles[newY][newX] === '#') return false;
      
      if (entity === player) {
        let monster = monsters.find(m => m.x === newX && m.y === newY);
        if (monster) {
          if (attack(player, monster)) {
            log(`You killed the ${monster.name}!`, 'death');
            player.xp += monster.xp;
            monsters = monsters.filter(m => m !== monster);
            checkLevelUp();
            updateStats();
          }
          return false;
        }
        
        // Handle items
        let item = items.find(i => i.x === newX && i.y === newY);
        if (item) {
          if (item.isStairs) {
            log(`You descend to level ${dungeonLevel + 1}!`, 'pickup');
            dungeonLevel++;
            initGame();
            return false;
          }
          if (item.value !== undefined) {
            player.gold += item.value;
            log(`You picked up ${item.value} gold!`, 'pickup');
            items = items.filter(i => i !== item);
          } else if (item.damage || item.heal) { // Pick up weapon or potion
            if (player.inventory.length < player.inventorySize) {
              player.inventory.push(item);
              log(`You picked up a ${item.name}!`, 'pickup');
              items = items.filter(i => i !== item);
            } else {
              log('Your inventory is full!', 'damage');
              return false;
            }
          }
          updateStats();
        }

        // Handle traps (Player)
        let trap = traps.find(t => t.x === newX && t.y === newY);
        if (trap) {
          trap.hidden = false; // Reveal for rendering (though it will be removed)
          
          if (trap.damage) {
            player.hp -= trap.damage;
            log(`You triggered a ${trap.name}! You take ${trap.damage} damage!`, 'damage');
            if (player.hp <= 0) {
              log('You died!', 'death');
              setTimeout(showDeathScreen, 500);
              traps = traps.filter(t => t !== trap); // Remove trap after triggering
              return false;
            }
          } else if (trap.teleport) {
            let newPos = findSafeWalkable(); // Use findSafeWalkable
            player.x = newPos.x;
            player.y = newPos.y;
            log('You triggered a teleport trap! You are whisked away!', 'pickup');
            updateStats();
            traps = traps.filter(t => t !== trap); // Remove trap after triggering
            return false;
          } else if (trap.poison) {
            // Simple poison: lose 1 HP immediately and log effect (full poison not implemented)
            player.hp -= 1; 
            log(`You triggered a ${trap.name}! You are poisoned! (T: ${trap.poison})`, 'damage');
            if (player.hp <= 0) {
              log('You died!', 'death');
              setTimeout(showDeathScreen, 500);
              traps = traps.filter(t => t !== trap); // Remove trap after triggering
              return false;
            }
          }
          traps = traps.filter(t => t !== trap); // Remove trap after triggering
          updateStats();
        }
      } else {
        // Handle traps (Monster)
        let trap = traps.find(t => t.x === newX && t.y === newY);
        if (trap && trap.teleport) {
          trap.hidden = false; // Reveal trap
          let newPos = findSafeWalkable(); // Use findSafeWalkable
          entity.x = newPos.x;
          entity.y = newPos.y;
          log(`The ${entity.name} triggered a teleport trap and vanished!`, 'pickup');
          traps = traps.filter(t => t !== trap); // Remove trap after triggering
          return false;
        }
      }
      
      entity.x = newX;
      entity.y = newY;
      return true;
    }
    
    // AI movement
    function moveMonsters() {
      // Loop backward to handle monster death/removal cleanly
      for (let i = monsters.length - 1; i >= 0; i--) {
        let monster = monsters[i];
        let dx = Math.sign(player.x - monster.x);
        let dy = Math.sign(player.y - monster.y);
        
        // Check if adjacent to player
        if (Math.abs(player.x - monster.x) <= 1 && Math.abs(player.y - monster.y) <= 1 
            && (dx !== 0 || dy !== 0)) {
          attack(monster, player);
          updateStats();
        } else {
          // Move towards player
          if (Math.random() < 0.5) {
            if (!moveEntity(monster, dx, 0)) moveEntity(monster, 0, dy);
          } else {
            if (!moveEntity(monster, 0, dy)) moveEntity(monster, dx, 0);
          }
        }
      }
    }
    
    // Render (Updated to skip rendering hidden traps)
    function gameLoop() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Render dungeon
      for (let y = 0; y < dungeon.height; y++) {
        for (let x = 0; x < dungeon.width; x++) {
          let glyph = dungeon.tiles[y][x];
          ctx.fillStyle = glyph === '#' ? '#666' : '#222';
          ctx.fillText(glyph, x * TILE_SIZE, (y + 1) * TILE_SIZE);
        }
      }

      // Render visible traps only
      for (let trap of traps) {
        if (!trap.hidden) {
          ctx.fillStyle = trap.color;
          ctx.fillText(trap.glyph, trap.x * TILE_SIZE, (trap.y + 1) * TILE_SIZE);
        }
      }
      
      // Render items
      for (let item of items) {
        ctx.fillStyle = item.color;
        ctx.fillText(item.glyph, item.x * TILE_SIZE, (item.y + 1) * TILE_SIZE);
      }
      
      // Render monsters
      for (let monster of monsters) {
        ctx.fillStyle = monster.color;
        ctx.fillText(monster.glyph, monster.x * TILE_SIZE, (monster.y + 1) * TILE_SIZE);
      }
      
      // Render player
      ctx.fillStyle = player.color;
      ctx.fillText(player.glyph, player.x * TILE_SIZE, (player.y + 1) * TILE_SIZE);
    }
    
    // Input handling (Updated to include inventory use)
    function handleMove(dx, dy) {
      if (dx !== 0 || dy !== 0) {
        // Player moves, if successful, then turn passes
        if (moveEntity(player, dx, dy)) {
          turn++;
          moveMonsters();
          gameLoop();
        } else {
          // If player didn't move (e.g., attacked monster or hit wall), just redraw
          gameLoop();
        }
      }
    }
    
    document.addEventListener("keydown", e => {
      let dx = 0, dy = 0;
      if (e.key === "ArrowUp" || e.key === 'k') dy = -1;
      if (e.key === "ArrowDown" || e.key === 'j') dy = 1;
      if (e.key === "ArrowLeft" || e.key === 'h') dx = -1;
      if (e.key === "ArrowRight" || e.key === 'l') dx = 1;
      
      // Diagonal movement (using NetHack keys)
      if (e.key === 'y') { dx = -1; dy = -1; } // NW
      if (e.key === 'u') { dx = 1; dy = -1; }  // NE
      if (e.key === 'b') { dx = -1; dy = 1; }  // SW
      if (e.key === 'n') { dx = 1; dy = 1; }   // SE
      
      // Inventory actions (Keys 1-5)
      if (e.key >= '1' && e.key <= '5') { // Limit to inventory size
        const index = parseInt(e.key) - 1;
        if (player.inventory[index]) {
          const item = player.inventory[index];
          if (item.damage) {
            player.weapon = item;
            log(`You equip the ${item.name}!`, 'pickup');
          } else if (item.heal) {
            const healing = item.heal;
            const preHp = player.hp;
            player.hp = Math.min(player.maxHp, player.hp + healing);
            const healedAmount = player.hp - preHp;
            log(`You drink the ${item.name} and heal ${healedAmount} HP!`, 'pickup');
            player.inventory.splice(index, 1); // Remove used potion
          }
          updateStats();
          e.preventDefault();
          // After inventory action, let monsters move
          turn++;
          moveMonsters();
          gameLoop();
        }
      }
      
      if (dx !== 0 || dy !== 0) {
        e.preventDefault();
        handleMove(dx, dy);
      }
    });
    
    // On-screen controls
    document.querySelectorAll('.control-btn[data-dir]').forEach(btn => {
      // Handle both click and touch
      const handleInput = (e) => {
        e.preventDefault(); // Prevent double-firing on touch devices
        const dir = btn.dataset.dir;
        let dx = 0, dy = 0;
        
        if (dir.includes('n')) dy = -1;
        if (dir.includes('s')) dy = 1;
        if (dir.includes('w')) dx = -1;
        if (dir.includes('e')) dx = 1;
        
        handleMove(dx, dy);
      };
      
      btn.addEventListener('click', handleInput);
      btn.addEventListener('touchstart', handleInput, { passive: false });
    });
    
    // Restart button
    document.getElementById('restart-btn').addEventListener('click', restartGame);
    
    // Start game
    initGame();
  </script>
</body>
</html>
